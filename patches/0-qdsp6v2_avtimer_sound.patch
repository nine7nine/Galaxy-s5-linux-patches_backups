diff -Nuarb a/include/linux/avtimer_kernel.h b/include/linux/avtimer_kernel.h
--- a/include/linux/avtimer_kernel.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/linux/avtimer_kernel.h	2015-12-01 05:57:38.000000000 -0500
@@ -0,0 +1,24 @@
+/*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+
+#ifndef _AVTIMER_H
+#define _AVTIMER_H
+
+#include <uapi/linux/avtimer.h>
+
+int avcs_core_open(void);
+int avcs_core_disable_power_collapse(int disable);/* true or flase */
+int avcs_core_query_timer(uint64_t *avtimer_tick);
+
+#endif
diff -Nuarb a/include/uapi/linux/avtimer.h b/include/uapi/linux/avtimer.h
--- a/include/uapi/linux/avtimer.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/uapi/linux/avtimer.h	2015-12-01 05:58:01.000000000 -0500
@@ -0,0 +1,19 @@
+#ifndef _UAPI_AVTIMER_H
+#define _UAPI_AVTIMER_H
+
+#include <linux/ioctl.h>
+
+#define MAJOR_NUM 100
+
+#define IOCTL_GET_AVTIMER_TICK _IOR(MAJOR_NUM, 0, char *)
+/*
+ * This IOCTL is used read the avtimer tick value.
+ * Avtimer is a 64 bit timer tick, hence the expected
+ * argument is of type uint64_t
+ */
+struct dev_avtimer_data {
+	uint32_t avtimer_msw_phy_addr;
+	uint32_t avtimer_lsw_phy_addr;
+};
+
+#endif
diff -X dontdiff -Nuarb a/arch/arm/mach-msm/qdsp6v2/ultrasound/version_b/q6usm_b.c b/arch/arm/mach-msm/qdsp6v2/ultrasound/version_b/q6usm_b.c
--- a/arch/arm/mach-msm/qdsp6v2/ultrasound/version_b/q6usm_b.c	2016-01-09 17:36:53.152742937 -0500
+++ b/arch/arm/mach-msm/qdsp6v2/ultrasound/version_b/q6usm_b.c	2016-01-09 17:36:38.545742155 -0500
@@ -745,7 +745,7 @@
 		int_format = US_RAW_FORMAT_V2;
 		break;
 	case FORMAT_USPROX:
-		int_format = US_PROX_FORMAT_V2;
+		int_format = US_PROX_FORMAT_V4;
 		break;
 	case FORMAT_USGES_SYNC:
 		int_format = US_GES_SYNC_FORMAT;
diff -X dontdiff -Nuarb a/drivers/platform/msm/avtimer.c b/drivers/platform/msm/avtimer.c
--- a/drivers/platform/msm/avtimer.c	2016-01-06 15:00:42.903590561 -0500
+++ b/drivers/platform/msm/avtimer.c	2015-12-01 05:56:22.000000000 -0500
@@ -25,11 +25,15 @@
 #include <linux/wait.h>
 #include <linux/sched.h>
 #include <mach/qdsp6v2/apr.h>
+#include <sound/q6core.h>
 
 #define DEVICE_NAME "avtimer"
 #define TIMEOUT_MS 1000
 #define CORE_CLIENT 1
 #define TEMP_PORT ((CORE_CLIENT << 8) | 0x0001)
+#define SSR_WAKETIME 1000
+#define Q6_READY_RETRY 250
+#define Q6_READY_MAX_RETRIES 40
 
 #define AVCS_CMD_REMOTE_AVTIMER_VOTE_REQUEST 0x00012914
 #define AVCS_CMD_RSP_REMOTE_AVTIMER_VOTE_REQUEST 0x00012915
@@ -53,11 +57,15 @@
 	struct mutex avtimer_lock;
 	int avtimer_open_cnt;
 	struct dev_avtimer_data avtimer_pdata;
+	struct delayed_work ssr_dwork;
 	wait_queue_head_t adsp_resp_wait;
 	int enable_timer_resp_recieved;
 	int timer_handle;
 	void __iomem *p_avtimer_msw;
 	void __iomem *p_avtimer_lsw;
+	uint32_t clk_div;
+	atomic_t adsp_ready;
+	int num_retries;
 };
 
 static struct avtimer_t avtimer;
@@ -102,6 +110,10 @@
 		pr_debug("%s: Reset event received in AV timer\n", __func__);
 		apr_reset(avtimer.core_handle_q);
 		avtimer.core_handle_q = NULL;
+		avtimer.avtimer_open_cnt = 0;
+		atomic_set(&avtimer.adsp_ready, 0);
+		schedule_delayed_work(&avtimer.ssr_dwork,
+				  msecs_to_jiffies(SSR_WAKETIME));
 		break;
 	}
 
@@ -239,8 +251,10 @@
 			goto done;
 		}
 		rc = avcs_core_enable_avtimer("timer");
-		if (!rc)
+		if (!rc) {
 			avtimer.avtimer_open_cnt++;
+			atomic_set(&avtimer.adsp_ready, 1);
+		}
 	} else {
 		if (avtimer.avtimer_open_cnt > 0) {
 			avtimer.avtimer_open_cnt--;
@@ -257,6 +271,48 @@
 }
 EXPORT_SYMBOL(avcs_core_disable_power_collapse);
 
+static void reset_work(struct work_struct *work)
+{
+	if (q6core_is_adsp_ready()) {
+		avcs_core_disable_power_collapse(1);
+		avtimer.num_retries = Q6_READY_MAX_RETRIES;
+		return;
+	}
+	pr_debug("%s:Q6 not ready-retry after sometime\n", __func__);
+	if (--avtimer.num_retries > 0) {
+		schedule_delayed_work(&avtimer.ssr_dwork,
+			  msecs_to_jiffies(Q6_READY_RETRY));
+	} else {
+		pr_err("%s: Q6 failed responding after multiple retries\n",
+							__func__);
+		avtimer.num_retries = Q6_READY_MAX_RETRIES;
+	}
+}
+
+int avcs_core_query_timer(uint64_t *avtimer_tick)
+{
+	uint32_t avtimer_msw = 0, avtimer_lsw = 0;
+	uint32_t res = 0;
+	uint64_t avtimer_tick_temp;
+
+	if (!atomic_read(&avtimer.adsp_ready)) {
+		pr_debug("%s:In SSR, return\n", __func__);
+		return -ENETRESET;
+	}
+	avtimer_lsw = ioread32(avtimer.p_avtimer_lsw);
+	avtimer_msw = ioread32(avtimer.p_avtimer_msw);
+
+	avtimer_tick_temp =
+		(uint64_t)((uint64_t)avtimer_msw << 32)
+			| avtimer_lsw;
+	res = do_div(avtimer_tick_temp, avtimer.clk_div);
+	*avtimer_tick = avtimer_tick_temp;
+	pr_debug("%s:Avtimer: msw: %u, lsw: %u, tick: %llu\n", __func__,
+			avtimer_msw, avtimer_lsw, *avtimer_tick);
+	return 0;
+}
+EXPORT_SYMBOL(avcs_core_query_timer);
+
 static int avtimer_open(struct inode *inode, struct file *file)
 {
 	return avcs_core_disable_power_collapse(1);
@@ -285,6 +341,7 @@
 			avtimer_msw_2nd = ioread32(avtimer.p_avtimer_msw);
 		} while (avtimer_msw_1st != avtimer_msw_2nd);
 
+		avtimer_lsw = avtimer_lsw/avtimer.clk_div;
 		avtimer_tick =
 		((uint64_t) avtimer_msw_1st << 32) | avtimer_lsw;
 
@@ -317,6 +374,7 @@
 	dev_t dev = MKDEV(major, 0);
 	struct device *device_handle;
 	struct resource *reg_lsb = NULL, *reg_msb = NULL;
+	uint32_t clk_div_val;
 
 	if (!pdev) {
 		pr_err("%s: Invalid params\n", __func__);
@@ -336,6 +394,8 @@
 			"avtimer_msb_addr", __func__);
 		return -EINVAL;
 	}
+	INIT_DELAYED_WORK(&avtimer.ssr_dwork, reset_work);
+
 	avtimer.p_avtimer_lsw = devm_ioremap_nocache(&pdev->dev,
 				reg_lsb->start, resource_size(reg_lsb));
 	if (!avtimer.p_avtimer_lsw) {
@@ -351,6 +411,7 @@
 			__func__);
 		goto unmap;
 	}
+	avtimer.num_retries = Q6_READY_MAX_RETRIES;
 	/* get the device number */
 	if (major)
 		result = register_chrdev_region(dev, 1, DEVICE_NAME);
@@ -360,14 +421,15 @@
 	}
 
 	if (result < 0) {
-		pr_err("%s: Registering avtimer device failed\n", __func__);
+		dev_err(&pdev->dev, "%s: Registering avtimer device failed\n",
+			__func__);
 		goto unmap;
 	}
 
 	avtimer.avtimer_class = class_create(THIS_MODULE, "avtimer");
 	if (IS_ERR(avtimer.avtimer_class)) {
 		result = PTR_ERR(avtimer.avtimer_class);
-		pr_err("%s: Error creating avtimer class: %d\n",
+		dev_err(&pdev->dev, "%s: Error creating avtimer class: %d\n",
 			__func__, result);
 		goto unregister_chrdev_region;
 	}
@@ -376,7 +438,8 @@
 	result = cdev_add(&avtimer.myc, dev, 1);
 
 	if (result < 0) {
-		pr_err("%s: Registering file operations failed\n", __func__);
+		dev_err(&pdev->dev, "%s: Registering file operations failed\n",
+			__func__);
 		goto class_destroy;
 	}
 
@@ -394,6 +457,13 @@
 	pr_debug("%s: Device create done for avtimer major=%d\n",
 			__func__, major);
 
+	if (of_property_read_u32(pdev->dev.of_node,
+			"qcom,clk_div", &clk_div_val))
+		avtimer.clk_div = 1;
+	else
+		avtimer.clk_div = clk_div_val;
+
+	pr_debug("avtimer.clk_div = %d\n", avtimer.clk_div);
 	return 0;
 
 class_destroy:
diff -Nuarb a/include/sound/apr_audio-v2.h b/include/sound/apr_audio-v2.h
--- a/include/sound/apr_audio-v2.h	2016-01-06 22:47:37.664090986 -0500
+++ b/include/sound/apr_audio-v2.h	2015-12-01 05:58:05.000000000 -0500
@@ -6590,52 +6590,6 @@
 	union afe_spkr_prot_config prot_config;
 } __packed;
 
-#ifdef CONFIG_SND_SOC_MAXIM_DSM
-struct afe_dsm_filter_set_params_t {
-  uint32_t dcResistance;
-  uint32_t coilTemp;
-  uint32_t qualityfactor;
-  uint32_t resonanceFreq;
-  uint32_t excursionMeasure;
-  uint32_t rdcroomtemp;
-  uint32_t releasetime;
-  uint32_t coilthermallimit;
-  uint32_t excursionlimit;
-  uint32_t dsmenabled;
-  uint32_t staticgain;
-  uint32_t lfxgain;
-  uint32_t pilotgain;
-  uint32_t flagToWrite;
-  uint32_t featureSetEnable;
-  uint32_t smooFacVoltClip;
-  uint32_t highPassCutOffFactor;
-  uint32_t leadResistance;
-  uint32_t rmsSmooFac;
-  uint32_t clipLimit;
-  uint32_t thermalCoeff;
-  uint32_t qSpk;
-  uint32_t excurLoggingThresh;
-  uint32_t coilTempLoggingThresh;
-  uint32_t resFreq;
-  uint32_t resFreqGuardBand;
-} __packed;
-
-union afe_dsm_spkr_prot_config {
-	struct asm_fbsp_mode_rx_cfg mode_rx_cfg;
-	struct asm_spkr_calib_vi_proc_cfg vi_proc_cfg;
-	struct asm_feedback_path_cfg feedback_path_cfg;
-	struct asm_mode_vi_proc_cfg mode_vi_proc_cfg;
-	struct afe_dsm_filter_set_params_t mode_dsm_proc_cfg;
-} __packed;
-
-struct afe_dsm_spkr_prot_config_command {
-	struct apr_hdr hdr;
-	struct afe_port_cmd_set_param_v2 param;
-	struct afe_port_param_data_v2 pdata;
-	union afe_dsm_spkr_prot_config prot_config;
-} __packed;
-#endif
-
 struct afe_spkr_prot_get_vi_calib {
 	struct afe_port_cmd_get_param_v2 get_param;
 	struct afe_port_param_data_v2 pdata;
@@ -6648,54 +6602,6 @@
 	struct asm_calib_res_cfg res_cfg;
 } __packed;
 
-#ifdef CONFIG_SND_SOC_MAXIM_DSM
-struct afe_dsm_filter_get_params_t {
-  uint32_t dcResistance;
-  uint32_t coilTemp;
-  uint32_t qualityfactor;
-  uint32_t resonanceFreq;
-  uint32_t excursionMeasure;
-  uint32_t rdcroomtemp;
-  uint32_t releasetime;
-  uint32_t coilthermallimit;
-  uint32_t excursionlimit;
-  uint32_t dsmenabled;
-  uint32_t staticgain;
-  uint32_t lfxgain;
-  uint32_t pilotgain;
-  uint32_t flagToWrite;
-  uint32_t featureSetEnable;
-  uint32_t smooFacVoltClip;
-  uint32_t highPassCutOffFactor;
-  uint32_t leadResistance;
-  uint32_t rmsSmooFac;
-  uint32_t clipLimit;
-  uint32_t thermalCoeff;
-  uint32_t qSpk;
-  uint32_t excurLoggingThresh;
-  uint32_t coilTempLoggingThresh;
-  uint32_t resFreq;
-  uint32_t resFreqGuardBand;
-#ifdef USE_DSM_LOG
-  uint8_t  byteLogArray[BEFORE_BUFSIZE];
-  uint32_t intLogArray[BEFORE_BUFSIZE];
-  uint8_t  afterProbByteLogArray[AFTER_BUFSIZE];
-  uint32_t afterProbIntLogArray[AFTER_BUFSIZE];
-#endif
-} __packed;
-
-struct afe_dsm_spkr_prot_get_vi_calib {
-	struct afe_port_cmd_get_param_v2 get_param;
-	struct afe_port_param_data_v2 pdata;
-	struct afe_dsm_filter_get_params_t res_cfg;
-} __packed;
-struct afe_dsm_spkr_prot_calib_get_resp {
-	uint32_t status;
-	struct afe_port_param_data_v2 pdata;
-	struct afe_dsm_filter_get_params_t res_cfg;
-} __packed;
-#endif
-
 
 /* SRS TRUMEDIA start */
 /* topology */
@@ -7382,7 +7288,173 @@
 /* Ultrasound supported formats */
 #define US_POINT_EPOS_FORMAT_V2 0x0001272D
 #define US_RAW_FORMAT_V2        0x0001272C
-#define US_PROX_FORMAT_V2       0x0001272E
+#define US_PROX_FORMAT_V4       0x0001273B
 #define US_RAW_SYNC_FORMAT      0x0001272F
 #define US_GES_SYNC_FORMAT      0x00012730
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+struct afe_dsm_filter_set_params_t {
+	uint32_t dcResistance;
+	uint32_t coilTemp;
+	uint32_t qualityfactor;
+	uint32_t resonanceFreq;
+	uint32_t excursionMeasure;
+	uint32_t rdcroomtemp;
+	uint32_t releasetime;
+	uint32_t coilthermallimit;
+	uint32_t excursionlimit;
+	uint32_t dsmenabled;
+	uint32_t staticgain;
+	uint32_t lfxgain;
+	uint32_t pilotgain;
+	uint32_t flagToWrite;
+	uint32_t featureSetEnable;
+	uint32_t smooFacVoltClip;
+	uint32_t highPassCutOffFactor;
+	uint32_t leadResistance;
+	uint32_t rmsSmooFac;
+	uint32_t clipLimit;
+	uint32_t thermalCoeff;
+	uint32_t qSpk;
+	uint32_t excurLoggingThresh;
+	uint32_t coilTempLoggingThresh;
+	uint32_t resFreq;
+	uint32_t resFreqGuardBand;
+	uint32_t Ambient_Temp;
+	uint32_t STL_attack_time;
+	uint32_t STL_release_time;
+	uint32_t STL_Admittance_a1;
+	uint32_t STL_Admittance_a2;
+	uint32_t STL_Admittance_b0;
+	uint32_t STL_Admittance_b1;
+	uint32_t STL_Admittance_b2;
+	uint32_t Tch1;
+	uint32_t Rth1;
+	uint32_t Tch2;
+	uint32_t Rth2;
+	uint32_t STL_Attenuation_Gain;
+	uint32_t SPT_rampDownFrames;
+	uint32_t SPT_Threshold;
+	uint32_t T_horizon;
+	uint32_t LFX_Admittance_a1;
+	uint32_t LFX_Admittance_a2;
+	uint32_t LFX_Admittance_b0;
+	uint32_t LFX_Admittance_b1;
+	uint32_t LFX_Admittance_b2;
+	uint32_t X_Max;
+	uint32_t SPK_FS;
+	uint32_t Q_GUARD_BAND;
+	uint32_t STImpedModel_a1;
+	uint32_t STImpedModel_a2;
+	uint32_t STImpedModel_b0;
+	uint32_t STImpedModel_b1;
+	uint32_t STImpedModel_b2;
+	uint32_t STImpedModel_Flag;
+	uint32_t Q_Notch;
+	uint32_t Reserve_0;
+	uint32_t Reserve_1;
+	uint32_t Reserve_2;
+	uint32_t Reserve_3;
+	uint32_t Reserve_4;
+} __packed;
+
+union afe_dsm_spkr_prot_config {
+	struct asm_fbsp_mode_rx_cfg mode_rx_cfg;
+	struct asm_spkr_calib_vi_proc_cfg vi_proc_cfg;
+	struct asm_feedback_path_cfg feedback_path_cfg;
+	struct asm_mode_vi_proc_cfg mode_vi_proc_cfg;
+	struct afe_dsm_filter_set_params_t mode_dsm_proc_cfg;
+} __packed;
+
+struct afe_dsm_spkr_prot_config_command {
+	struct apr_hdr hdr;
+	struct afe_port_cmd_set_param_v2 param;
+	struct afe_port_param_data_v2 pdata;
+	union afe_dsm_spkr_prot_config prot_config;
+} __packed;
+
+struct afe_dsm_filter_get_params_t {
+	uint32_t dcResistance;
+	uint32_t coilTemp;
+	uint32_t qualityfactor;
+	uint32_t resonanceFreq;
+	uint32_t excursionMeasure;
+	uint32_t rdcroomtemp;
+	uint32_t releasetime;
+	uint32_t coilthermallimit;
+	uint32_t excursionlimit;
+	uint32_t dsmenabled;
+	uint32_t staticgain;
+	uint32_t lfxgain;
+	uint32_t pilotgain;
+	uint32_t flagToWrite;
+	uint32_t featureSetEnable;
+	uint32_t smooFacVoltClip;
+	uint32_t highPassCutOffFactor;
+	uint32_t leadResistance;
+	uint32_t rmsSmooFac;
+	uint32_t clipLimit;
+	uint32_t thermalCoeff;
+	uint32_t qSpk;
+	uint32_t excurLoggingThresh;
+	uint32_t coilTempLoggingThresh;
+	uint32_t resFreq;
+	uint32_t resFreqGuardBand;
+	uint32_t Ambient_Temp;
+	uint32_t STL_attack_time;
+	uint32_t STL_release_time;
+	uint32_t STL_Admittance_a1;
+	uint32_t STL_Admittance_a2;
+	uint32_t STL_Admittance_b0;
+	uint32_t STL_Admittance_b1;
+	uint32_t STL_Admittance_b2;
+	uint32_t Tch1;
+	uint32_t Rth1;
+	uint32_t Tch2;
+	uint32_t Rth2;
+	uint32_t STL_Attenuation_Gain;
+	uint32_t SPT_rampDownFrames;
+	uint32_t SPT_Threshold;
+	uint32_t T_horizon;
+	uint32_t LFX_Admittance_a1;
+	uint32_t LFX_Admittance_a2;
+	uint32_t LFX_Admittance_b0;
+	uint32_t LFX_Admittance_b1;
+	uint32_t LFX_Admittance_b2;
+	uint32_t X_Max;
+	uint32_t SPK_FS;
+	uint32_t Q_GUARD_BAND;
+	uint32_t STImpedModel_a1;
+	uint32_t STImpedModel_a2;
+	uint32_t STImpedModel_b0;
+	uint32_t STImpedModel_b1;
+	uint32_t STImpedModel_b2;
+	uint32_t STImpedModel_Flag;
+	uint32_t Q_Notch;
+	uint32_t Reserve_0;
+	uint32_t Reserve_1;
+	uint32_t Reserve_2;
+	uint32_t Reserve_3;
+	uint32_t Reserve_4;
+#ifdef USE_DSM_LOG
+	uint8_t byteLogArray[BEFORE_BUFSIZE];
+	uint32_t intLogArray[BEFORE_BUFSIZE];
+	uint8_t afterProbByteLogArray[AFTER_BUFSIZE];
+	uint32_t afterProbIntLogArray[AFTER_BUFSIZE];
+#endif /* USE_DSM_LOG */
+} __packed;
+
+struct afe_dsm_spkr_prot_get_vi_calib {
+	struct afe_port_cmd_get_param_v2 get_param;
+	struct afe_port_param_data_v2 pdata;
+	struct afe_dsm_filter_get_params_t res_cfg;
+} __packed;
+
+struct afe_dsm_spkr_prot_calib_get_resp {
+	uint32_t status;
+	struct afe_port_param_data_v2 pdata;
+	struct afe_dsm_filter_get_params_t res_cfg;
+} __packed;
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+
 #endif /*_APR_AUDIO_V2_H_ */
diff -Nuarb a/include/sound/asound.h b/include/sound/asound.h
--- a/include/sound/asound.h	2016-01-06 22:47:37.665090986 -0500
+++ b/include/sound/asound.h	2015-12-01 05:57:59.000000000 -0500
@@ -95,9 +95,10 @@
 	SNDRV_HWDEP_IFACE_SB_RC,	/* SB Extigy/Audigy2NX remote control */
 	SNDRV_HWDEP_IFACE_HDA,		/* HD-audio */
 	SNDRV_HWDEP_IFACE_USB_STREAM,	/* direct access to usb stream */
+       SNDRV_HWDEP_IFACE_AUDIO_CODEC,  /* codec Audio Control */
 
 	/* Don't forget to change the following: */
-	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_USB_STREAM
+	SNDRV_HWDEP_IFACE_LAST = SNDRV_HWDEP_IFACE_AUDIO_CODEC
 };
 
 struct snd_hwdep_info {
diff -Nuarb a/include/sound/compress_offload.h b/include/sound/compress_offload.h
--- a/include/sound/compress_offload.h	2016-01-06 22:47:37.665090986 -0500
+++ b/include/sound/compress_offload.h	2015-12-01 05:57:59.000000000 -0500
@@ -131,6 +131,8 @@
 enum {
 	SNDRV_COMPRESS_ENCODER_PADDING = 1,
 	SNDRV_COMPRESS_ENCODER_DELAY = 2,
+	SNDRV_COMPRESS_MIN_BLK_SIZE = 3,
+	SNDRV_COMPRESS_MAX_BLK_SIZE = 4,
 };
 
 /**
diff -Nuarb a/include/sound/Kbuild b/include/sound/Kbuild
--- a/include/sound/Kbuild	2016-01-06 22:47:37.663090986 -0500
+++ b/include/sound/Kbuild	2015-12-01 05:57:59.000000000 -0500
@@ -15,3 +14,4 @@
 header-y += lsm_params.h
 header-y += voice_params.h
 header-y += voice_svc.h
+header-y += msmcal-hwdep.h
diff -Nuarb a/include/sound/max98506.h b/include/sound/max98506.h
--- a/include/sound/max98506.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/sound/max98506.h	2015-12-01 05:58:00.000000000 -0500
@@ -0,0 +1,72 @@
+/*
+ * Platform data for MAX98506
+ *
+ * Copyright 2013-2015 Maxim Integrated Products
+ *
+ *  This program is free software; you can redistribute  it and/or modify it
+ *  under  the terms of  the GNU General  Public License as published by the
+ *  Free Software Foundation;  either version 2 of the  License, or (at your
+ *  option) any later version.
+ *
+ */
+
+#ifndef __SOUND_MAX98506_PDATA_H__
+#define __SOUND_MAX98506_PDATA_H__
+
+#define MAX98506_I2C_ADDR	0x62
+#define MAX98506_I2C_ADDR_S (MAX98506_I2C_ADDR >> 1)
+
+/* MAX98506 volume step */
+#define MAX98506_VSTEP_0		0
+#define MAX98506_VSTEP_1		1
+#define MAX98506_VSTEP_2		2
+#define MAX98506_VSTEP_3		3
+#define MAX98506_VSTEP_4		4
+#define MAX98506_VSTEP_5		5
+#define MAX98506_VSTEP_6		6
+#define MAX98506_VSTEP_7		7
+#define MAX98506_VSTEP_8		8
+#define MAX98506_VSTEP_9		9
+#define MAX98506_VSTEP_10		10
+#define MAX98506_VSTEP_11		11
+#define MAX98506_VSTEP_12		12
+#define MAX98506_VSTEP_13		13
+#define MAX98506_VSTEP_14		14
+#define MAX98506_VSTEP_15		15
+#define MAX98506_VSTEP_MAX		MAX98506_VSTEP_15
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM_CAL
+extern struct class *g_class;
+#else
+struct class *g_class;
+#endif /* CONFIG_SND_SOC_MAXIM_DSM_CAL */
+
+struct max98506_volume_step_info {
+	int length;
+	int vol_step;
+	int adc_thres;
+	int boost_step[MAX98506_VSTEP_MAX + 1];
+	bool adc_status;
+};
+
+struct max98506_pc_active {
+	u32 capture_active;
+	u32 playback_active:1;
+};
+
+#define MAX98506_PINFO_SZ	6
+
+struct max98506_pdata {
+	int sysclk;
+	u32 spk_gain;
+	u32 vmon_slot;
+	bool i2c_pull_up;
+#ifdef USE_MAX98506_IRQ
+	int irq;
+#endif /* USE_MAX98506_IRQ */
+	uint32_t pinfo[MAX98506_PINFO_SZ];
+	const uint32_t *reg_arr;
+	uint32_t reg_arr_len;
+};
+
+#endif /* __SOUND_MAX98506_PDATA_H__ */
diff -Nuarb a/include/sound/maxim_dsm_cal.h b/include/sound/maxim_dsm_cal.h
--- a/include/sound/maxim_dsm_cal.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/sound/maxim_dsm_cal.h	2015-12-01 05:58:00.000000000 -0500
@@ -0,0 +1,66 @@
+/*
+ * maxim_dsm_cal.c -- Module for Rdc calibration
+ *
+ * Copyright 2014 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#ifndef __SOUND_MAXIM_DSM_CAL_H__
+#define __SOUND_MAXIM_DSM_CAL_H__
+
+#define DRIVER_AUTHOR		"Kyounghun Jeon<hun.jeon@maximintegrated.com>"
+#define DRIVER_DESC			"For Rdc calibration of MAX98xxx"
+#define DRIVER_SUPPORTED	"MAX98xxx"
+
+#define WQ_NAME				"maxdsm_wq"
+
+#define FILEPATH_TEMP_CAL	"/efs/maxim/temp_cal"
+#define FILEPATH_RDC_CAL	"/efs/maxim/rdc_cal"
+
+#define CLASS_NAME			"maxdsm_cal"
+#define DSM_NAME			"dsm"
+
+#define ADDR_RDC			0x2A0050
+#define ADDR_FEATURE_ENABLE 0x2A006A
+
+struct maxim_dsm_cal_info {
+	uint32_t min;
+	uint32_t max;
+	uint32_t feature_en;
+	int interval;
+	int duration;
+	int remaining;
+	int ignored_t;
+	unsigned long previous_jiffies;
+};
+
+struct maxim_dsm_cal_values {
+	uint32_t status;
+	int rdc;
+	int temp;
+	uint64_t avg;
+	int count;
+};
+
+struct maxim_dsm_cal {
+	struct device *dev;
+	struct class *class;
+	struct mutex mutex;
+	struct workqueue_struct *wq;
+	struct delayed_work work;
+	struct maxim_dsm_cal_values values;
+	struct maxim_dsm_cal_info info;
+	struct regmap *regmap;
+	uint32_t platform_type;
+};
+
+extern struct regmap *maxdsm_cal_set_regmap(
+		struct regmap *regmap);
+extern int maxdsm_cal_get_temp(uint32_t *temp);
+extern int maxdsm_cal_set_temp(uint32_t temp);
+extern int maxdsm_cal_get_rdc(uint32_t *rdc);
+extern int maxdsm_cal_set_rdc(uint32_t rdc);
+#endif /* __SOUND_MAXIM_DSM_CAL_H__ */
diff -Nuarb a/include/sound/maxim_dsm.h b/include/sound/maxim_dsm.h
--- a/include/sound/maxim_dsm.h	2016-01-06 22:47:37.668090986 -0500
+++ b/include/sound/maxim_dsm.h	2015-12-01 05:58:06.000000000 -0500
@@ -1,5 +1,4 @@
 /*
- * Platform data for MAX98504
  *
  * Copyright 2011-2012 Maxim Integrated Products
  *
@@ -15,37 +14,79 @@
 
 #define DSM_RX_PORT_ID	0x4000
 
-#define AFE_PARAM_ID_ENABLE_DSM_RX    0x0F010203
-#define AFE_PARAM_ID_ENABLE_DSM_TX    0x0FF10203
+#define AFE_PARAM_ID_ENABLE_DSM_RX    0x10001062
+#define AFE_PARAM_ID_ENABLE_DSM_TX    0x10001063
 
 #define DSM_ID_FILTER_GET_AFE_PARAMS 0x00000000
 #define DSM_ID_FILTER_SET_AFE_CNTRLS 0x00000001
 
-enum	{
-	MODE_DSM_COPP,
-	MODE_DSM_AFE,	
-	MODE_DSM_MAX,
+#define FLAG_WRITE_ALL 0xabefcdab
+#define FLAG_WRITE_CAL_FROM_FILE 0xffff0000
+#define FLAG_WRITE_ONOFF_ONLY	0xcdababef
+#define FLAG_WRITE_RDC_CAL_ONLY 0xca00ca00
+#define FLAG_WRITE_FEATURE_ONLY 0xfea0fea0
+
+enum maxdsm_version {
+	VERSION_3_0 = 30,
+	VERSION_3_5_A = 35,
+	VERSION_3_5_B,
+	VERSION_4_0_A = 40,
+	VERSION_4_0_B,
 };
 
-enum	{
-	PARAM_VOICE_COIL_TEMP,
-	PARAM_VOICE_COIL_TEMP_SZ,
-	PARAM_EXCURSION,
-	PARAM_EXCURSION_SZ,
+enum maxdsm_platform_type {
+	PLATFORM_TYPE_A = 0,
+	PLATFORM_TYPE_B,
+};
+
+enum maxdsm_ioctl_cmds {
+	MAXDSM_IOCTL_GET_VERSION = 1000,
+	MAXDSM_IOCTL_SET_VERSION,
+	MAXDSM_IOCTL_GET_PARAM,
+	MAXDSM_IOCTL_SET_PARAM,
+	MAXDSM_IOCTL_GET_ALL_PARAMS,
+	MAXDSM_IOCTL_SET_ALL_PARAMS,
+	MAXDSM_IOCTL_GET_CAL_DATA,
+	MAXDSM_IOCTL_SET_CAL_DATA,
+	MAXDSM_IOCTL_GET_PLATFORM_TYPE,
+	MAXDSM_IOCTL_SET_PLATFORM_TYPE,
+};
+
+enum maxdsm_ignore_param {
+	MAXDSM_IGNORE_MASK_VOICE_COIL = 1U << 0,
+	MAXDSM_IGNORE_MASK_AMBIENT_TEMP = 1U << 1,
+	MAXDSM_IGNORE_MASK_ALL	= 1U << 16,
+};
+
+enum maxdsm_offset {
+	PARAM_OFFSET_PLATFORM,
+	PARAM_OFFSET_PORT_ID,
+	PARAM_OFFSET_RX_MOD_ID,
+	PARAM_OFFSET_TX_MOD_ID,
+	PARAM_OFFSET_FILTER_SET,
+	PARAM_OFFSET_VERSION,
+	PARAM_OFFSET_MAX,
+};
+
+enum maxdsm_3_0_params {
 	PARAM_RDC,
 	PARAM_RDC_SZ,
+	PARAM_VOICE_COIL_TEMP,
+	PARAM_VOICE_COIL_TEMP_SZ,
 	PARAM_Q,
 	PARAM_Q_SZ,
 	PARAM_FRES,
 	PARAM_FRES_SZ,
-	PARAM_EXCUR_LIMIT,
-	PARAM_EXCUR_LIMIT_SZ,
+	PARAM_EXCURSION,
+	PARAM_EXCURSION_SZ,
 	PARAM_VOICE_COIL,
 	PARAM_VOICE_COIL_SZ,
-	PARAM_THERMAL_LIMIT,
-	PARAM_THERMAL_LIMIT_SZ,
 	PARAM_RELEASE_TIME,
 	PARAM_RELEASE_TIME_SZ,
+	PARAM_THERMAL_LIMIT,
+	PARAM_THERMAL_LIMIT_SZ,
+	PARAM_EXCUR_LIMIT,
+	PARAM_EXCUR_LIMIT_SZ,
 	PARAM_ONOFF,
 	PARAM_ONOFF_SZ,
 	PARAM_STATIC_GAIN,
@@ -80,18 +121,314 @@
 	PARAM_RES_FREQ_SZ,
 	PARAM_RES_FREQ_GUARD_BAND,
 	PARAM_RES_FREQ_GUARD_BAND_SZ,
-	PARAM_DSM_MAX,
+	PARAM_DSM_3_0_MAX,
 };
 
-#define FLAG_WRITE_ALL 0xabefcdab
-#define FLAG_WRITE_ONOFF_ONLY	0xcdababef
+enum maxdsm_3_5_params {
+	PARAM_AMBIENT_TEMP = PARAM_DSM_3_0_MAX,
+	PARAM_AMBIENT_TEMP_SZ,
+	PARAM_STL_ATTACK_TIME,
+	PARAM_STL_ATTACK_TIME_SZ,
+	PARAM_STL_RELEASE_TIME,
+	PARAM_STL_RELEASE_TIME_SZ,
+	PARAM_ADMITTANCE_A1,
+	PARAM_ADMITTANCE_A1_SZ,
+	PARAM_ADMITTANCE_A2,
+	PARAM_ADMITTANCE_A2_SZ,
+	PARAM_ADMITTANCE_B0,
+	PARAM_ADMITTANCE_B0_SZ,
+	PARAM_ADMITTANCE_B1,
+	PARAM_ADMITTANCE_B1_SZ,
+	PARAM_ADMITTANCE_B2,
+	PARAM_ADMITTANCE_B2_SZ,
+	PARAM_TCH1,
+	PARAM_TCH1_SZ,
+	PARAM_RTH1,
+	PARAM_RTH1_SZ,
+	PARAM_TCH2,
+	PARAM_TCH2_SZ,
+	PARAM_RTH2,
+	PARAM_RTH2_SZ,
+	PARAM_STL_ATTENUATION_GAIN,
+	PARAM_STL_ATTENUATION_GAIN_SZ,
+	PARAM_SPT_RAMP_DOWN_FRAMES,
+	PARAM_SPT_RAMP_DOWN_FRAMES_SZ,
+	PARAM_SPT_THRESHOLD,
+	PARAM_SPT_THRESHOLD_SZ,
+	PARAM_T_HORIZON,
+	PARAM_T_HORIZON_SZ,
+	PARAM_LFX_ADMITTANCE_A1,
+	PARAM_LFX_ADMITTANCE_A1_SZ,
+	PARAM_LFX_ADMITTANCE_A2,
+	PARAM_LFX_ADMITTANCE_A2_SZ,
+	PARAM_LFX_ADMITTANCE_B0,
+	PARAM_LFX_ADMITTANCE_B0_SZ,
+	PARAM_LFX_ADMITTANCE_B1,
+	PARAM_LFX_ADMITTANCE_B1_SZ,
+	PARAM_LFX_ADMITTANCE_B2,
+	PARAM_LFX_ADMITTANCE_B2_SZ,
+	PARAM_DSM_3_5_MAX,
+};
+
+enum maxdsm_4_0_params {
+	PARAM_X_MAX = PARAM_DSM_3_5_MAX,
+	PARAM_X_MAX_SZ,
+	PARAM_SPK_FS,
+	PARAM_SPK_FS_SZ,
+	PARAM_Q_GUARD_BAND,
+	PARAM_Q_GUARD_BAND_SZ,
+	PARAM_STIMPEDMODEL_COEFFS_A1,
+	PARAM_STIMPEDMODEL_COEFFS_A1_SZ,
+	PARAM_STIMPEDMODEL_COEFFS_A2,
+	PARAM_STIMPEDMODEL_COEFFS_A2_SZ,
+	PARAM_STIMPEDMODEL_COEFFS_B0,
+	PARAM_STIMPEDMODEL_COEFFS_B0_SZ,
+	PARAM_STIMPEDMODEL_COEFFS_B1,
+	PARAM_STIMPEDMODEL_COEFFS_B1_SZ,
+	PARAM_STIMPEDMODEL_COEFFS_B2,
+	PARAM_STIMPEDMODEL_COEFFS_B2_SZ,
+	PARAM_STIMPEDMODEL_FLAG,
+	PARAM_STIMPEDMODEL_FLAG_SZ,
+	PARAM_Q_NOTCH,
+	PARAM_Q_NOTCH_SZ,
+	PARAM_DSM_4_0_MAX,
+};
+
+enum maxdsm_3_0_params_a {
+	PARAM_A_VOICE_COIL_TEMP,
+	PARAM_A_VOICE_COIL_TEMP_SZ,
+	PARAM_A_EXCURSION,
+	PARAM_A_EXCURSION_SZ,
+	PARAM_A_RDC,
+	PARAM_A_RDC_SZ,
+	PARAM_A_Q_LO,
+	PARAM_A_Q_LO_SZ,
+	PARAM_A_Q_HI,
+	PARAM_A_Q_HI_SZ,
+	PARAM_A_FRES_LO,
+	PARAM_A_FRES_LO_SZ,
+	PARAM_A_FRES_HI,
+	PARAM_A_FRES_HI_SZ,
+	PARAM_A_EXCUR_LIMIT,
+	PARAM_A_EXCUR_LIMIT_SZ,
+	PARAM_A_VOICE_COIL,
+	PARAM_A_VOICE_COIL_SZ,
+	PARAM_A_THERMAL_LIMIT,
+	PARAM_A_THERMAL_LIMIT_SZ,
+	PARAM_A_RELEASE_TIME,
+	PARAM_A_RELEASE_TIME_SZ,
+	PARAM_A_ONOFF,
+	PARAM_A_ONOFF_SZ,
+	PARAM_A_STATIC_GAIN,
+	PARAM_A_STATIC_GAIN_SZ,
+	PARAM_A_LFX_GAIN,
+	PARAM_A_LFX_GAIN_SZ,
+	PARAM_A_PILOT_GAIN,
+	PARAM_A_PILOT_GAIN_SZ,
+	PARAM_A_FEATURE_SET,
+	PARAM_A_FEATURE_SET_SZ,
+	PARAM_A_SMOOTH_VOLT,
+	PARAM_A_SMOOTH_VOLT_SZ,
+	PARAM_A_HPF_CUTOFF,
+	PARAM_A_HPF_CUTOFF_SZ,
+	PARAM_A_LEAD_R,
+	PARAM_A_LEAD_R_SZ,
+	PARAM_A_RMS_SMOO_FAC,
+	PARAM_A_RMS_SMOO_FAC_SZ,
+	PARAM_A_CLIP_LIMIT,
+	PARAM_A_CLIP_LIMIT_SZ,
+	PARAM_A_THERMAL_COEF,
+	PARAM_A_THERMAL_COEF_SZ,
+	PARAM_A_QSPK,
+	PARAM_A_QSPK_SZ,
+	PARAM_A_EXCUR_LOG_THRESH,
+	PARAM_A_EXCUR_LOG_THRESH_SZ,
+	PARAM_A_TEMP_LOG_THRESH,
+	PARAM_A_TEMP_LOG_THRESH_SZ,
+	PARAM_A_RES_FREQ,
+	PARAM_A_RES_FREQ_SZ,
+	PARAM_A_RES_FREQ_GUARD_BAND,
+	PARAM_A_RES_FREQ_GUARD_BAND_SZ,
+	PARAM_A_DSM_3_0_MAX,
+};
+
+enum maxdsm_3_5_params_a {
+	PARAM_A_AMBIENT_TEMP = PARAM_A_DSM_3_0_MAX,
+	PARAM_A_AMBIENT_TEMP_SZ,
+	PARAM_A_ADMITTANCE_A1,
+	PARAM_A_ADMITTANCE_A1_SZ,
+	PARAM_A_ADMITTANCE_A2,
+	PARAM_A_ADMITTANCE_A2_SZ,
+	PARAM_A_ADMITTANCE_B0,
+	PARAM_A_ADMITTANCE_B0_SZ,
+	PARAM_A_ADMITTANCE_B1,
+	PARAM_A_ADMITTANCE_B1_SZ,
+	PARAM_A_ADMITTANCE_B2,
+	PARAM_A_ADMITTANCE_B2_SZ,
+	PARAM_A_RTH1_HI,
+	PARAM_A_RTH1_HI_SZ,
+	PARAM_A_RTH1_LO,
+	PARAM_A_RTH1_LO_SZ,
+	PARAM_A_RTH2_HI,
+	PARAM_A_RTH2_HI_SZ,
+	PARAM_A_RTH2_LO,
+	PARAM_A_RTH2_LO_SZ,
+	PARAM_A_STL_ATENGAIN_HI,
+	PARAM_A_STL_ATENGAIN_HI_SZ,
+	PARAM_A_STL_ATENGAIN_LO,
+	PARAM_A_STL_ATENGAIN_LO_SZ,
+	PARAM_A_SPT_RAMP_DOWN_FRAMES,
+	PARAM_A_SPT_RAMP_DOWN_FRAMES_SZ,
+	PARAM_A_SPT_THRESHOLD_HI,
+	PARAM_A_SPT_THRESHOLD_HI_SZ,
+	PARAM_A_SPT_THRESHOLD_LO,
+	PARAM_A_SPT_THRESHOLD_LO_SZ,
+	PARAM_A_T_HORIZON,
+	PARAM_A_T_HORIZON_SZ,
+	PARAM_A_LFX_ADMITTANCE_A1,
+	PARAM_A_LFX_ADMITTANCE_A1_SZ,
+	PARAM_A_LFX_ADMITTANCE_A2,
+	PARAM_A_LFX_ADMITTANCE_A2_SZ,
+	PARAM_A_LFX_ADMITTANCE_B0,
+	PARAM_A_LFX_ADMITTANCE_B0_SZ,
+	PARAM_A_LFX_ADMITTANCE_B1,
+	PARAM_A_LFX_ADMITTANCE_B1_SZ,
+	PARAM_A_LFX_ADMITTANCE_B2,
+	PARAM_A_LFX_ADMITTANCE_B2_SZ,
+	PARAM_A_ALGORITHM_X_MAX,
+	PARAM_A_ALGORITHM_X_MAX_SZ,
+	PARAM_A_DSM_3_5_MAX,
+};
+
+enum maxdsm_4_0_params_a {
+	PARAM_A_STL_TCTH1_HI = PARAM_A_DSM_3_5_MAX,
+	PARAM_A_STL_TCTH1_HI_SZ,
+	PARAM_A_STL_TCTH1_LO,
+	PARAM_A_STL_TCTH1_LO_SZ,
+	PARAM_A_STL_TCTH2_HI,
+	PARAM_A_STL_TCTH2_HI_SZ,
+	PARAM_A_STL_TCTH2_LO,
+	PARAM_A_STL_TCTH2_LO_SZ,
+	PARAM_A_STL_ATTACK_HI,
+	PARAM_A_STL_ATTACK_HI_SZ,
+	PARAM_A_STL_ATTACK_LO,
+	PARAM_A_STL_ATTACK_LO_SZ,
+	PARAM_A_STL_RELEASE_HI,
+	PARAM_A_STL_RELEASE_HI_SZ,
+	PARAM_A_STL_RELEASE_LO,
+	PARAM_A_STL_RELEASE_LO_SZ,
+	PARAM_A_STL_SPK_FS,
+	PARAM_A_STL_SPK_FS_SZ,
+	PARAM_A_Q_GUARD_BAND_HI,
+	PARAM_A_Q_GUARD_BAND_HI_SZ,
+	PARAM_A_Q_GUARD_BAND_LO,
+	PARAM_A_Q_GUARD_BAND_LO_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_A1_HI,
+	PARAM_A_STIMPEDMODEL_COEFFS_A1_HI_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_A1_LO,
+	PARAM_A_STIMPEDMODEL_COEFFS_A1_LO_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_A2_HI,
+	PARAM_A_STIMPEDMODEL_COEFFS_A2_HI_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_A2_LO,
+	PARAM_A_STIMPEDMODEL_COEFFS_A2_LO_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_B0_HI,
+	PARAM_A_STIMPEDMODEL_COEFFS_B0_HI_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_B0_LO,
+	PARAM_A_STIMPEDMODEL_COEFFS_B0_LO_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_B1_HI,
+	PARAM_A_STIMPEDMODEL_COEFFS_B1_HI_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_B1_LO,
+	PARAM_A_STIMPEDMODEL_COEFFS_B1_LO_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_B2_HI,
+	PARAM_A_STIMPEDMODEL_COEFFS_B2_HI_SZ,
+	PARAM_A_STIMPEDMODEL_COEFFS_B2_LO,
+	PARAM_A_STIMPEDMODEL_COEFFS_B2_LO_SZ,
+	PARAM_A_STIMPEDMODEL_FLAG,
+	PARAM_A_STIMPEDMODEL_FLAG_SZ,
+	PARAM_A_Q_NOTCH_HI,
+	PARAM_A_Q_NOTCH_HI_SZ,
+	PARAM_A_Q_NOTCH_LO,
+	PARAM_A_Q_NOTCH_LO_SZ,
+	PARAM_A_DSM_4_0_MAX,
+};
+
+enum {
+	WRITE_PROTECT,
+	LOG_AVAILABLE,
+	VERSION_INFO,
+	LAST_2_SEC_TEMP,
+	LAST_2_SEC_EXCUR,
+	RESERVED_1,
+	SEQUENCE_OF_TEMP,
+	SEQUENCE_OF_EXCUR,
+	LAST_2_SEC_RDC,
+	LAST_2_SEC_FREQ,
+	RESERVED_2,
+	RESERVED_3,
+	AFTER_2_SEC_TEMP_TEMP,
+	AFTER_2_SEC_EXCUR_TEMP,
+	AFTER_2_SEC_TEMP_EXCUR,
+	AFTER_2_SEC_EXCUR_EXCUR,
+	AFTER_2_SEC_RDC_TEMP,
+	AFTER_2_SEC_FREQ_TEMP,
+	AFTER_2_SEC_RDC_EXCUR,
+	AFTER_2_SEC_FREQ_EXCUR,
+	MAX_LOG_BUFFER_POS,
+};
+
+struct param_info {
+	int id;
+	uint32_t addr;
+	int size;
+	int type;
+	int val;
+};
+
+struct param_set_data {
+	int name;
+	uint32_t addr;
+	uint32_t value;
+	uint32_t wflag;
+};
+
+struct maxim_dsm {
+	struct regmap *regmap;
+	uint32_t *param;
+	uint32_t param_size;
+	uint32_t platform_type;
+	uint32_t port_id;
+	uint32_t rx_mod_id;
+	uint32_t tx_mod_id;
+	uint32_t filter_set;
+	uint32_t version;
+	uint32_t *binfo;
+	uint32_t registered;
+	uint32_t update_cal;
+	uint32_t ignore_mask;
+};
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+#define USE_DSM_UPDATE_CAL
+#define USE_DSM_LOG
+#define USE_DSM_DEBUG
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 
 int maxdsm_init(void);
 int maxdsm_deinit(void);
 
-#define DEBUG_DSM
+uint32_t maxdsm_get_platform_type(void);
+int maxdsm_set_feature_en(int on);
+int maxdsm_set_rdc_temp(uint32_t rdc, uint32_t temp);
+int maxdsm_set_dsm_onoff_status(int on);
+uint32_t maxdsm_get_dcresistance(void);
+
+int maxdsm_update_info(uint32_t *pinfo);
+int maxdsm_get_port_id(void);
+int maxdsm_get_rx_mod_id(void);
+int maxdsm_get_tx_mod_id(void);
+void maxdsm_set_regmap(struct regmap *regmap);
 
-#define USE_DSM_LOG
+int maxdsm_update_feature_en_adc(int apply);
 
 #ifdef USE_DSM_LOG
 #define LOG_BUFFER_ARRAY_SIZE 10
@@ -100,12 +437,23 @@
 #define BEFORE_BUFSIZE (4+(LOG_BUFFER_ARRAY_SIZE*2))
 #define AFTER_BUFSIZE (LOG_BUFFER_ARRAY_SIZE*4)
 
-extern int maxdsm_get_dump_status(void);
-extern ssize_t maxdsm_log_prepare(char *buf);
-extern void maxdsm_update_param(void);
-extern void maxdsm_log_update(const void *byteLogArray,
-	       const void *intLogArray, const void *afterProbByteLogArray, 
-	       const void *afterProbIntLogArray);
+int maxdsm_get_dump_status(void);
+void maxdsm_update_param(void);
+void maxdsm_log_update(const void *byte_log_array,
+		const void *int_log_array,
+		const void *after_prob_byte_log_array,
+		const void *after_prob_int_log_array);
+ssize_t maxdsm_log_prepare(char *buf);
+void maxdsm_cal_update(const void *byte_log_array,
+		const void *int_log_array,
+		const void *after_prob_byte_log_array,
+		const void *after_prob_int_log_array);
+#endif /* USE_DSM_LOG */
+
+#ifdef USE_DSM_UPDATE_CAL
+int maxdsm_cal_avail(void);
+int maxdsm_update_caldata(int on);
+ssize_t maxdsm_cal_prepare(char *buf);
 #endif
 
-#endif
+#endif /* __SOUND_MAXIM_DSM_H__ */
diff -Nuarb a/include/sound/msmcal-hwdep.h b/include/sound/msmcal-hwdep.h
--- a/include/sound/msmcal-hwdep.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/sound/msmcal-hwdep.h	2015-12-01 05:58:00.000000000 -0500
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef _CALIB_HWDEP_H
+#define _CALIB_HWDEP_H
+
+#define WCD9XXX_CODEC_HWDEP_NODE    1000
+enum wcd_cal_type {
+	WCD9XXX_MIN_CAL,
+	WCD9XXX_ANC_CAL = WCD9XXX_MIN_CAL,
+	WCD9XXX_MAD_CAL,
+	WCD9XXX_MBHC_CAL,
+	WCD9XXX_MAX_CAL,
+};
+
+struct wcdcal_ioctl_buffer {
+	__u32 size;
+	__u8 __user *buffer;
+	enum wcd_cal_type cal_type;
+};
+
+#define SNDRV_CTL_IOCTL_HWDEP_CAL_TYPE \
+	_IOW('U', 0x1, struct wcdcal_ioctl_buffer)
+
+#endif /*_CALIB_HWDEP_H*/
diff -Nuarb a/include/sound/q6afe-v2.h b/include/sound/q6afe-v2.h
--- a/include/sound/q6afe-v2.h	2016-01-06 22:47:37.669090986 -0500
+++ b/include/sound/q6afe-v2.h	2015-12-01 05:58:00.000000000 -0500
@@ -204,4 +204,7 @@
 bool afe_has_config(enum afe_config_type config);
 
 void afe_set_aanc_info(struct aanc_data *aanc_info);
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+int32_t dsm_open(void *data);
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 #endif /* __Q6AFE_V2_H__ */
diff -Nuarb a/include/sound/q6asm-v2.h b/include/sound/q6asm-v2.h
--- a/include/sound/q6asm-v2.h	2016-01-06 22:47:37.669090986 -0500
+++ b/include/sound/q6asm-v2.h	2015-12-01 05:58:06.000000000 -0500
@@ -183,6 +183,7 @@
 	/* audio cache operations fptr*/
 	int (*fptr_cache_ops)(struct audio_buffer *abuff, int cache_op);
 	atomic_t               unmap_cb_success;
+	atomic_t               reset;
 };
 
 void q6asm_audio_client_free(struct audio_client *ac);
diff -Nuarb a/include/sound/q6audio-v2.h b/include/sound/q6audio-v2.h
--- a/include/sound/q6audio-v2.h	2016-01-06 22:47:37.669090986 -0500
+++ b/include/sound/q6audio-v2.h	2015-12-01 05:58:00.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -32,4 +32,6 @@
 
 int q6audio_get_port_id(u16 port_id);
 
+int q6audio_get_port_id_from_index(u16 port_idx);
+
 #endif
diff -Nuarb a/include/sound/q6core.h b/include/sound/q6core.h
--- a/include/sound/q6core.h	1969-12-31 19:00:00.000000000 -0500
+++ b/include/sound/q6core.h	2015-12-01 05:58:00.000000000 -0500
@@ -0,0 +1,106 @@
+/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+
+#ifndef __Q6CORE_H__
+#define __Q6CORE_H__
+#include <mach/qdsp6v2/apr.h>
+#include <mach/ocmem.h>
+
+
+#define AVCS_CMD_GET_LOW_POWER_SEGMENTS_INFO              0x00012903
+
+struct avcs_cmd_get_low_power_segments_info {
+	struct apr_hdr hdr;
+} __packed;
+
+
+#define AVCS_CMDRSP_GET_LOW_POWER_SEGMENTS_INFO           0x00012904
+
+#define AVCS_CMD_ADSP_EVENT_GET_STATE		0x0001290C
+#define AVCS_CMDRSP_ADSP_EVENT_GET_STATE	0x0001290D
+
+/* @brief AVCS_CMDRSP_GET_LOW_POWER_SEGMENTS_INFO payload
+ * structure. Payload for this event comprises one instance of
+ * avcs_cmd_rsp_get_low_power_segments_info_t, followed
+ * immediately by num_segments number of instances of the
+ * avcs_mem_segment_t structure.
+ */
+
+/* Types of Low Power Memory Segments. */
+#define READ_ONLY_SEGMENT      1
+/*< Read Only memory segment. */
+#define READ_WRITE_SEGMENT     2
+/*< Read Write memory segment. */
+/*Category indicates whether audio/os/sensor segments. */
+#define AUDIO_SEGMENT          1
+/*< Audio memory segment. */
+#define OS_SEGMENT             2
+/*< QDSP6's OS memory segment. */
+
+/* @brief Payload structure for AVS low power memory segment
+ *  structure.
+ */
+struct avcs_mem_segment_t {
+	uint16_t              type;
+/*< Indicates which type of memory this segment is.
+ *Allowed values: READ_ONLY_SEGMENT or READ_WRITE_SEGMENT only.
+ */
+	uint16_t              category;
+/*< Indicates whether audio or OS segments.
+ *Allowed values: AUDIO_SEGMENT or OS_SEGMENT only.
+ */
+	uint32_t              size;
+/*< Size (in bytes) of this segment.
+ * Will be a non-zero value.
+ */
+	uint32_t              start_address_lsw;
+/*< Lower 32 bits of the 64-bit physical start address
+ * of this segment.
+ */
+	uint32_t              start_address_msw;
+/*< Upper 32 bits of the 64-bit physical start address
+ * of this segment.
+ */
+};
+
+struct avcs_cmd_rsp_get_low_power_segments_info_t {
+	uint32_t              num_segments;
+/*< Number of segments in this response.
+ * 0: there are no known sections that should be mapped
+ * from DDR to OCMEM.
+ * >0: the number of memory segments in the following list.
+ */
+
+	uint32_t              bandwidth;
+/*< Required OCMEM read/write bandwidth (in bytes per second)
+ * if OCMEM is granted.
+ * 0 if num_segments = 0
+ * >0 if num_segments > 0.
+ */
+	struct avcs_mem_segment_t mem_segment[OCMEM_MAX_CHUNKS];
+};
+
+
+int core_get_low_power_segments(
+			struct avcs_cmd_rsp_get_low_power_segments_info_t **);
+bool q6core_is_adsp_ready(void);
+
+#define ADSP_CMD_SET_DOLBY_MANUFACTURER_ID 0x00012918
+
+struct adsp_dolby_manufacturer_id {
+	struct apr_hdr hdr;
+	int manufacturer_id;
+};
+
+uint32_t core_set_dolby_manufacturer_id(int manufacturer_id);
+
+#endif /* __Q6CORE_H__ */
diff -X dontdiff -Nuarb a/sound/core/compress_offload.c b/sound/core/compress_offload.c
--- a/sound/core/compress_offload.c	2016-01-06 15:00:44.524590648 -0500
+++ b/sound/core/compress_offload.c	2015-12-01 05:58:37.000000000 -0500
@@ -156,9 +156,12 @@
 static int snd_compr_update_tstamp(struct snd_compr_stream *stream,
 		struct snd_compr_tstamp *tstamp)
 {
+	int err = 0;
 	if (!stream->ops->pointer)
 		return -ENOTSUPP;
-	stream->ops->pointer(stream, tstamp);
+	err = stream->ops->pointer(stream, tstamp);
+	if (err)
+		return err;
 	pr_debug("dsp consumed till %d total %d bytes\n",
 		tstamp->byte_offset, tstamp->copied_total);
 	if (stream->direction == SND_COMPRESS_PLAYBACK)
diff -X dontdiff -Nuarb a/sound/core/pcm.c b/sound/core/pcm.c
--- a/sound/core/pcm.c	2016-01-06 15:00:44.527590648 -0500
+++ b/sound/core/pcm.c	2015-12-01 05:58:38.000000000 -0500
@@ -1216,8 +1216,11 @@
 	list_del_init(&pcm->list);
 	for (cidx = 0; cidx < 2; cidx++)
 		for (substream = pcm->streams[cidx].substream; substream; substream = substream->next)
-			if (substream->runtime)
+			if (substream->runtime) {
 				substream->runtime->status->state = SNDRV_PCM_STATE_DISCONNECTED;
+                                wake_up(&substream->runtime->sleep);
+                                wake_up(&substream->runtime->tsleep);
+                        }
 	list_for_each_entry(notify, &snd_pcm_notify_list, list) {
 		notify->n_disconnect(pcm);
 	}
diff -X dontdiff -Nuarb a/sound/soc/codecs/audience/es705.c b/sound/soc/codecs/audience/es705.c
--- a/sound/soc/codecs/audience/es705.c	2016-01-06 15:00:44.609590653 -0500
+++ b/sound/soc/codecs/audience/es705.c	2015-12-01 05:58:57.000000000 -0500
@@ -89,6 +89,10 @@
 #define NETWORK_OFFSET	21
 static int network_type = NARROW_BAND;
 
+#if defined(FORCED_REROUTE_PRESET)
+static int extra_vol_onoff = 0;
+#endif
+
 /* Route state for Internal state management */
 enum es705_power_state {
 ES705_POWER_FW_LOAD,
@@ -1507,7 +1511,8 @@
 #if defined(CONFIG_MACH_KLTE_JPN)
 #define UART_DOWNLOAD_WAKEUP_HWREV 7
 #elif defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KSPORTSLTE_SPR) \
-	|| defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) || defined(CONFIG_MACH_KACTIVELTE_DCM)
+	|| defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 #define UART_DOWNLOAD_WAKEUP_HWREV 0
 #else
 #define UART_DOWNLOAD_WAKEUP_HWREV 6 /* HW rev0.7 */
@@ -1717,6 +1722,11 @@
 
 	dev_info(es705->dev, "%s\n",__func__);
 
+#if defined(FORCED_REROUTE_PRESET)
+	if (delayed_work_pending(&es705->forced_reroute_work))
+		cancel_delayed_work_sync(&es705->forced_reroute_work);
+#endif
+
 	mutex_lock(&es705->pm_mutex);
 
 	es705->current_bwe = 0;
@@ -1871,6 +1881,12 @@
 #if defined(SAMSUNG_ES705_FEATURE)
 	msm_slim_es705_func(es705_priv.gen0_client);
 #endif
+
+#if defined(FORCED_REROUTE_PRESET)
+	if (delayed_work_pending(&es705->forced_reroute_work))
+			cancel_delayed_work_sync(&es705->forced_reroute_work);
+#endif
+
 	if (delayed_work_pending(&es705->sleep_work) ||
 		(es705->pm_state == ES705_POWER_SLEEP_PENDING)) {
 		cancel_delayed_work_sync(&es705->sleep_work);
@@ -2014,18 +2030,12 @@
 	unsigned int reg = mc->reg;
 	unsigned int value =0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
 	value = es705_read(NULL, reg);
 	}
 	ucontrol->value.integer.value[0] = value;
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
 
 	return 0;
 }
@@ -2053,9 +2063,6 @@
 	unsigned int reg = e->reg;
 	unsigned int value=0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
@@ -2063,9 +2070,6 @@
 }
 
 	ucontrol->value.enumerated.item[0] = value;
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
 
 	return 0;
 }
@@ -3480,6 +3484,46 @@
 	return 0;
 }
 
+#if defined(FORCED_REROUTE_PRESET)
+static void es705_forced_reroute(struct work_struct *w)
+{
+	struct es705_priv *es705 = &es705_priv;
+	int rc = 0;
+	int vol = 0;
+	dev_info(es705->dev, "%s(): to %ld %d\n", __func__, es705->internal_route_num, extra_vol_onoff);
+
+	rc = es705_write_block(es705, 
+					&es705_route_configs[es705->internal_route_num][0]);
+
+	if (extra_vol_onoff) {
+		rc = es705_write(NULL, ES705_PRESET, 	ES705_VEQ_OFF_PRESET);
+		
+	} else {
+		vol = es705->current_veq;
+		es705->current_veq = -1;	
+		es705->current_veq_preset = 1;
+
+		es705_put_veq_block(vol);		
+	}
+	extra_vol_onoff = 0;
+}
+
+static int es705_forced_reroute_w(struct snd_kcontrol *kcontrol,
+				       struct snd_ctl_elem_value *ucontrol)
+{
+	struct es705_priv *es705 = &es705_priv;
+
+	if (delayed_work_pending(&es705->forced_reroute_work))
+			cancel_delayed_work_sync(&es705->forced_reroute_work);
+
+	dev_info(es705->dev, "%s(): put work task workqueue after delay(200ms)\n ", __func__);
+	schedule_delayed_work(&es705->forced_reroute_work, msecs_to_jiffies(500));
+	extra_vol_onoff = ucontrol->value.integer.value[0];
+
+	return 0;
+}
+#endif
+
 static int es705_put_internal_route(struct snd_kcontrol *kcontrol,
 				    struct snd_ctl_elem_value *ucontrol)
 {
@@ -3669,18 +3713,12 @@
 	unsigned int reg = mc->reg;
 	unsigned int value=0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
 	value = es705_read(NULL, reg);
 }
 	ucontrol->value.integer.value[0] = es705_gain_to_index(-12, 1, value);
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
 	return 0;
 }
 
@@ -3710,18 +3748,12 @@
 	unsigned int reg = mc->reg;
 	unsigned int value=0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
 	value = es705_read(NULL, reg);
 }
 	ucontrol->value.integer.value[0] = es705_gain_to_index(-10, 1, value);
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
 
 	return 0;
 }
@@ -3752,19 +3784,12 @@
 	unsigned int reg = mc->reg;
 	unsigned int value=0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
 	value = es705_read(NULL, reg);
 }
 	ucontrol->value.integer.value[0] = es705_gain_to_index(-20, 1, value);
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
-
 	return 0;
 }
 
@@ -3990,9 +4015,6 @@
 	unsigned int reg = mc->reg;
 	unsigned int value=0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
@@ -4002,9 +4024,6 @@
 
 	dev_dbg(es705_priv.dev, "%s(): value = %d ucontrol = %ld\n",
 		__func__, value, ucontrol->value.integer.value[0]);
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
 
 	return 0;
 }
@@ -4038,9 +4057,6 @@
 	unsigned int reg = mc->reg;
 	unsigned int value=0;
 
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(1);
-#endif
 	if (es705_priv.rx1_route_enable ||
 		es705_priv.tx1_route_enable ||
 		es705_priv.rx2_route_enable) {
@@ -4050,9 +4066,6 @@
 
 	dev_dbg(es705_priv.dev, "%s(): value = %d ucontrol = %ld\n",
 		__func__, value, ucontrol->value.integer.value[0]);
-#if defined(SAMSUNG_ES705_FEATURE)
-	es705_read_write_power_control(0);
-#endif
 
 	return 0;
 }
@@ -4247,6 +4260,10 @@
 	SOC_SINGLE_EXT("Voice Sense Stream Enable", ES705_VS_STREAM_ENABLE,
 		       0, 1, 0,
 		       es705_get_vs_stream_enable, es705_put_vs_stream_enable),
+#if defined(FORCED_REROUTE_PRESET)
+	SOC_SINGLE_EXT("ES705 Reroute", SND_SOC_NOPM, 0, 1, 0,
+		   NULL, es705_forced_reroute_w),
+#endif
 #if defined(SAMSUNG_ES705_FEATURE)
 	SOC_SINGLE_EXT("ES705 Voice Wakeup Enable", SND_SOC_NOPM, 0, 2, 0,
 		       es705_get_voice_wakeup_enable_value,
@@ -4762,6 +4779,10 @@
 #if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
 	INIT_DELAYED_WORK(&es705_priv.reroute_work, es705_reroute);	
 #endif
+#if defined(FORCED_REROUTE_PRESET)
+	INIT_DELAYED_WORK(&es705_priv.forced_reroute_work, es705_forced_reroute);	
+#endif
+
 #if defined(SAMSUNG_ES705_FEATURE)
 	rc = es705_init_input_device(&es705_priv);
 	if (rc < 0)
@@ -4790,7 +4811,11 @@
 #endif /* CONFIG_ARCH_MSM8226 */
 
 #ifdef ES705_VDDCORE_MAX77826
+#if defined(CONFIG_MACH_KACTIVELTE_KOR)
+	es705_vdd_core = regulator_get(NULL, "max77826_ldo3");
+#else
 	es705_vdd_core = regulator_get(NULL, "max77826_ldo1");
+#endif
 	if (IS_ERR(es705_vdd_core)) {
 		dev_err(dev, "%s(): es705 VDD CORE regulator_get fail\n", __func__);
 		return rc;
diff -X dontdiff -Nuarb a/sound/soc/codecs/audience/es705.h b/sound/soc/codecs/audience/es705.h
--- a/sound/soc/codecs/audience/es705.h	2016-01-06 15:00:44.609590653 -0500
+++ b/sound/soc/codecs/audience/es705.h	2015-12-01 05:58:57.000000000 -0500
@@ -9,7 +9,7 @@
 #ifndef _ES705_H
 #define _ES705_H
 
-#if defined(CONFIG_SEC_S_PROJECT)
+#if defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 #define ES705_VDDCORE_MAX77826
 #endif
 #include <linux/cdev.h>
@@ -483,12 +483,14 @@
  * Default delay before switch to sleep - 2sec
  * To change delay value use SYSFS sleep delay entry
  */
-#define ES705_SLEEP_DEFAULT_DELAY 0
+#define ES705_SLEEP_DEFAULT_DELAY 2000
 
 #if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
 #define ES705_REROUTE_INV 200
 #endif
 
+#define FORCED_REROUTE_PRESET
+
 /* Maximum size of keyword parameter block in bytes. */
 #define ES705_VS_KEYWORD_PARAM_MAX 512
 
@@ -550,6 +552,9 @@
 #if defined(PREVENT_CALL_MUTE_WHEN_SWITCH_NB_AND_WB)
 	struct delayed_work reroute_work;
 #endif
+#if defined(FORCED_REROUTE_PRESET)
+	struct delayed_work forced_reroute_work;
+#endif
 	struct es705_slim_dai_data dai[ES705_NUM_CODEC_SLIM_DAIS];
 	struct es705_slim_ch slim_rx[ES705_SLIM_RX_PORTS];
 	struct es705_slim_ch slim_tx[ES705_SLIM_TX_PORTS];
diff -X dontdiff -Nuarb a/sound/soc/codecs/audience/es705-routes.h b/sound/soc/codecs/audience/es705-routes.h
--- a/sound/soc/codecs/audience/es705-routes.h	2016-01-06 15:00:44.608590653 -0500
+++ b/sound/soc/codecs/audience/es705-routes.h	2015-12-01 05:58:56.000000000 -0500
@@ -626,8 +626,8 @@
 	0xffffffff	/* terminate */
 };
 
-#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
-	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR)
+#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static const u32 route_2Mic_SPK_NB_FO_NSOn[] = {
 	0x9031041b,	/* Route, #1051 */
 	0x90310395,	/* Algo, #917 */
@@ -647,8 +647,8 @@
 	0xffffffff	/* terminate */
 };
 
-#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
-	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR)
+#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static const u32 route_2Mic_SPK_NB_FO_NSOff[] = {
 	0x9031041b,	/* Route, #1051 */
 	0x90310395,	/* Algo, #917 */
@@ -705,8 +705,8 @@
 	0xffffffff	/* terminate */
 };
 
-#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
-	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR)
+#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static const u32 route_TTYHCO[] = {
 	0x903103e9,	/* Route, #1001 */
 	0x9031024e,	/* Algo, #590  */
@@ -758,8 +758,8 @@
 	0xffffffff	/* terminate */
 };
 
-#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
-	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR)
+#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static const u32 route_2Mic_SPK_WB_FO_NSOn[] = {
 	0x9031041b,	/* Route, #1051 */
 	0x90310396,	/* Algo, #918 */
@@ -779,8 +779,8 @@
 	0xffffffff	/* terminate */
 };
 
-#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
-	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR)
+#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static const u32 route_2Mic_SPK_WB_FO_NSOff[] = {
 	0x9031041b,	/* Route, #1051 */
 	0x90310396,	/* Algo, #918 */
@@ -846,8 +846,8 @@
 	0xffffffff	/* terminate */
 };
 
-#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_MACH_KACTIVELTE_SKT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
-	|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR)
+#if  defined(CONFIG_MACH_KACTIVELTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_ATT) || defined(CONFIG_SEC_S_PROJECT) || defined(CONFIG_MACH_KACTIVELTE_CAN) \
+|| defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_HESTIALTE_EUR) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static const u32 *es705_route_configs[] = {
 	route_1Mic_WHS_NB_SWBypass,			/*  0 */
 	route_2Mic_SPK_NB_FO_NSOn,			/*  1 */
diff -X dontdiff -Nuarb a/sound/soc/codecs/es325.c b/sound/soc/codecs/es325.c
--- a/sound/soc/codecs/es325.c	2016-01-06 15:00:44.612590653 -0500
+++ b/sound/soc/codecs/es325.c	2015-12-01 05:58:57.000000000 -0500
@@ -68,6 +68,9 @@
 #include <linux/clk.h>
 #include <linux/of_gpio.h>
 
+#ifdef CONFIG_SND_SOC_ES325_SLIM
+#define PREVENT_SLIMBUS_SLEEP_IN_FW_DL
+#endif
 #define ES325_CMD_ACCESS_WR_MAX 4
 #define ES325_CMD_ACCESS_RD_MAX 4
 struct es325_cmd_access {
@@ -152,6 +155,9 @@
 static unsigned int es325_BWE_enable_new = ES325_MAX_INVALID_BWE;
 static unsigned int es325_Tx_NS = ES325_MAX_INVALID_TX_NS;
 static unsigned int es325_Tx_NS_new = ES325_MAX_INVALID_TX_NS;
+#if defined(PREVENT_SLIMBUS_SLEEP_IN_FW_DL)
+extern void msm_slim_es325_write_flag_set(int flag);
+#endif 
 
 /* codec private data */
 struct es325_priv {
@@ -1903,7 +1909,10 @@
 	msg[1] = ES325_BOOT_CMD >> 8;
 	dev_dbg(&sbdev->dev, "=[ES325]=%s(): msg[0] = 0x%02x msg[1] = 0x%02x msg[2] = 0x%02x msg[3] = 0x%02x\n",
 		__func__, msg[0], msg[1], msg[2], msg[3]);
-
+#if defined(PREVENT_SLIMBUS_SLEEP_IN_FW_DL)
+	/* Enable es325_write_flag before starting FW downloading */	
+    msm_slim_es325_write_flag_set(1);
+#endif
 	/* Keep SLIMBus CG unchangeable during FW downloading time */
 	rc = slim_reservemsg_bw(sbdev, 3072000, true);
 	if (rc < 0)
@@ -1967,6 +1976,10 @@
 	}
 	dev_info(&sbdev->dev, "-[ES325]=%s()\n", __func__);
 	slim_reservemsg_bw(sbdev, 0, true);
+#if defined(PREVENT_SLIMBUS_SLEEP_IN_FW_DL)	
+	/* Disable es325_write_flag after FW downloading */	
+    msm_slim_es325_write_flag_set(0);
+#endif
 	return 0;
 }
 
diff -X dontdiff -Nuarb a/sound/soc/codecs/Kconfig b/sound/soc/codecs/Kconfig
--- a/sound/soc/codecs/Kconfig	2016-01-06 15:00:44.604590652 -0500
+++ b/sound/soc/codecs/Kconfig	2015-12-01 05:58:55.000000000 -0500
@@ -42,6 +42,7 @@
 	select SND_SOC_MAX98504 if I2C
 	select SND_SOC_MAX98504A if I2C
 	select SND_SOC_MAX98505 if I2C
+	select SND_SOC_MAX98506 if I2C
 	select SND_SOC_MAX9850 if I2C
 	select SND_SOC_MAX9877 if I2C
 	select SND_SOC_PCM3008
@@ -243,12 +244,25 @@
 	help
 	MAX98505 driver
 
+config SND_SOC_MAX98506
+	bool "Support MAX98506"
+	depends on I2C
+	help
+	MAX98505 driver
+
 config SND_SOC_MAXIM_DSM
 	bool "Support MAXIM DSM"
-	depends on SND_SOC_MAX98504 || SND_SOC_MAX98505
+	depends on SND_SOC_MAX98504 || SND_SOC_MAX98505 || SND_SOC_MAX98506
 	help
 	MAXIM DSM driver
 
+config SND_SOC_MAXIM_DSM_CAL
+	tristate "Support MAXIM DSM Calibration"
+	default y if SND_SOC_MAX98506=y
+	default m if SND_SOC_MAX98506=m
+	help
+	MAX9850x Calibration Driver
+
 config SND_SOC_MAX9850
 	tristate
 
diff -X dontdiff -Nuarb a/sound/soc/codecs/Makefile b/sound/soc/codecs/Makefile
--- a/sound/soc/codecs/Makefile	2016-01-06 15:00:44.604590652 -0500
+++ b/sound/soc/codecs/Makefile	2015-12-01 05:58:55.000000000 -0500
@@ -30,7 +30,9 @@
 snd-soc-max98504-objs := max98504.o
 snd-soc-max98504a-objs := max98504a.o
 snd-soc-max98505-objs := max98505.o
+snd-soc-max98506-objs := max98506.o
 snd-soc-maxim-dsm-objs := maxim_dsm.o
+snd-soc-maxim-dsm-cal-objs := maxim_dsm_cal.o
 snd-soc-max9850-objs := max9850.o
 snd-soc-pcm3008-objs := pcm3008.o
 snd-soc-rt5631-objs := rt5631.o
@@ -55,8 +57,8 @@
 snd-soc-wcd9304-objs := wcd9304.o wcd9304-tables.o
 snd-soc-wcd9310-objs := wcd9310.o wcd9310-tables.o
 snd-soc-cs8427-objs := cs8427.o
-snd-soc-wcd9320-objs := wcd9xxx-resmgr.o wcd9320.o wcd9320-tables.o wcd9xxx-mbhc.o wcd9xxx-common.o
-snd-soc-wcd9306-objs := wcd9306.o wcd9306-tables.o wcd9xxx-common.o
+snd-soc-wcd9320-objs := wcd9xxx-resmgr.o wcd9320.o wcd9320-tables.o wcd9xxx-mbhc.o wcd9xxx-common.o wcdcal-hwdep.o
+snd-soc-wcd9306-objs := wcd9306.o wcd9306-tables.o wcd9xxx-common.o wcdcal-hwdep.o
 snd-soc-msm8x10-wcd-objs := msm8x10-wcd.o msm8x10-wcd-tables.o wcd9xxx-common.o
 snd-soc-es325-objs := es325.o
 snd-soc-es325_atlantic-objs := es325_atlantic.o
@@ -150,7 +152,9 @@
 obj-$(CONFIG_SND_SOC_MAX98504)	+= snd-soc-max98504.o
 obj-$(CONFIG_SND_SOC_MAX98504A)	+= snd-soc-max98504a.o
 obj-$(CONFIG_SND_SOC_MAX98505)	+= snd-soc-max98505.o
+obj-$(CONFIG_SND_SOC_MAX98506)	+= snd-soc-max98506.o
 obj-$(CONFIG_SND_SOC_MAXIM_DSM)	+= snd-soc-maxim-dsm.o
+obj-$(CONFIG_SND_SOC_MAXIM_DSM_CAL)	+= snd-soc-maxim-dsm-cal.o
 obj-$(CONFIG_SND_SOC_MAX9850)	+= snd-soc-max9850.o
 obj-$(CONFIG_SND_SOC_PCM3008)	+= snd-soc-pcm3008.o
 obj-$(CONFIG_SND_SOC_RT5631)	+= snd-soc-rt5631.o
diff -X dontdiff -Nuarb a/sound/soc/codecs/max98506.c b/sound/soc/codecs/max98506.c
--- a/sound/soc/codecs/max98506.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/codecs/max98506.c	2015-12-01 05:59:06.000000000 -0500
@@ -0,0 +1,1508 @@
+/*
+ * max98506.c -- ALSA SoC MAX98506 driver
+ *
+ * Copyright 2013-2015 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/delay.h>
+#include <linux/i2c.h>
+#include <linux/module.h>
+#include <linux/regmap.h>
+#include <linux/slab.h>
+#include <sound/pcm.h>
+#include <sound/pcm_params.h>
+#include <sound/soc.h>
+#include <sound/tlv.h>
+#include <sound/max98506.h>
+#include "max98506.h"
+#include <linux/regulator/consumer.h>
+
+#define DEBUG_MAX98506
+#ifdef DEBUG_MAX98506
+#define msg_maxim(format, args...) \
+	pr_err("[MAX98506_DEBUG] %s: " format "\n", __func__, ## args)
+#else
+#define msg_maxim(format, args...)
+#endif /* DEBUG_MAX98506 */
+
+static struct reg_default max98506_reg[] = {
+	{ 0x02, 0x00 }, /* Live Status0 */
+	{ 0x03, 0x00 }, /* Live Status1 */
+	{ 0x04, 0x00 }, /* Live Status2 */
+	{ 0x05, 0x00 }, /* State0 */
+	{ 0x06, 0x00 }, /* State1 */
+	{ 0x07, 0x00 }, /* State2 */
+	{ 0x08, 0x00 }, /* Flag0 */
+	{ 0x09, 0x00 }, /* Flag1 */
+	{ 0x0A, 0x00 }, /* Flag2 */
+	{ 0x0B, 0x00 }, /* IRQ Enable0 */
+	{ 0x0C, 0x00 }, /* IRQ Enable1 */
+	{ 0x0D, 0x00 }, /* IRQ Enable2 */
+	{ 0x0E, 0x00 }, /* IRQ Clear0 */
+	{ 0x0F, 0x00 }, /* IRQ Clear1 */
+	{ 0x10, 0x00 }, /* IRQ Clear2 */
+	{ 0x1A, 0x06 }, /* DAI Clock Mode 1 */
+	{ 0x1B, 0xC0 }, /* DAI Clock Mode 2 */
+	{ 0x1F, 0x00 }, /* DAI Clock Divider Numerator LSBs */
+	{ 0x20, 0x50 }, /* Format */
+	{ 0x21, 0x00 }, /* TDM Slot Select */
+	{ 0x22, 0x00 }, /* DOUT Configuration VMON */
+	{ 0x23, 0x00 }, /* DOUT Configuration IMON */
+	{ 0x24, 0x00 }, /* DAI Interleaved Configuration */
+	{ 0x26, 0x00 }, /* DOUT Configuration FLAG */
+	{ 0x27, 0xFF }, /* DOUT HiZ Configuration 1 */
+	{ 0x28, 0xFF }, /* DOUT HiZ Configuration 2 */
+	{ 0x29, 0xFF }, /* DOUT HiZ Configuration 3 */
+	{ 0x2A, 0xFF }, /* DOUT HiZ Configuration 4 */
+	{ 0x2B, 0x02 }, /* DOUT Drive Strength */
+	{ 0x2C, 0x90 }, /* Filters */
+	{ 0x2D, 0x00 }, /* Gain */
+	{ 0x2E, 0x02 }, /* Gain Ramping */
+	{ 0x2F, 0x00 }, /* Speaker Amplifier */
+	{ 0x30, 0x0A }, /* Threshold */
+	{ 0x31, 0x00 }, /* ALC Attack */
+	{ 0x32, 0x80 }, /* ALC Atten and Release */
+	{ 0x33, 0x00 }, /* ALC Infinite Hold Release */
+	{ 0x34, 0x92 }, /* ALC Configuration */
+	{ 0x35, 0x01 }, /* Boost Converter */
+	{ 0x36, 0x00 }, /* Block Enable */
+	{ 0x37, 0x00 }, /* Configuration */
+	{ 0x38, 0x00 }, /* Global Enable */
+	{ 0x3A, 0x00 }, /* Boost Limiter */
+	{ 0xFF, 0x50 }, /* Revision ID */
+};
+
+static bool max98506_volatile_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case MAX98506_R002_LIVE_STATUS0:
+	case MAX98506_R003_LIVE_STATUS1:
+	case MAX98506_R004_LIVE_STATUS2:
+	case MAX98506_R005_STATE0:
+	case MAX98506_R006_STATE1:
+	case MAX98506_R007_STATE2:
+	case MAX98506_R008_FLAG0:
+	case MAX98506_R009_FLAG1:
+	case MAX98506_R00A_FLAG2:
+	case MAX98506_R0FF_VERSION:
+		return true;
+	default:
+		return false;
+	}
+}
+
+static bool max98506_readable_register(struct device *dev, unsigned int reg)
+{
+	switch (reg) {
+	case 0x00:
+	case 0x01:
+	case MAX98506_R00E_IRQ_CLEAR0:
+	case MAX98506_R00F_IRQ_CLEAR1:
+	case MAX98506_R010_IRQ_CLEAR2:
+	case 0x1C:
+	case 0x1D:
+	case 0x1E:
+	case 0x25:
+	case MAX98506_R033_ALC_HOLD_RLS:
+	case 0x39:
+	case 0x3B ... 0xFE:
+		return false;
+	default:
+		return true;
+	}
+};
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+#ifdef USE_DSM_LOG
+static int max98506_get_dump_status(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = maxdsm_get_dump_status();
+	return 0;
+}
+static int max98506_set_dump_status(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+
+	int val;
+
+	regmap_read(max98506->regmap,
+		MAX98506_R038_GLOBAL_ENABLE, &val);
+	msg_maxim("val: %d", val);
+
+	if (val != 0)
+		maxdsm_update_param();
+
+	return 0;
+}
+static ssize_t max98506_log_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return maxdsm_log_prepare(buf);
+}
+
+static DEVICE_ATTR(dsm_log, S_IRUGO, max98506_log_show, NULL);
+#endif /* USE_DSM_LOG */
+
+#ifdef USE_DSM_UPDATE_CAL
+static int max98506_get_dsm_param(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	ucontrol->value.integer.value[0] = maxdsm_cal_avail();
+	return 0;
+}
+
+static int max98506_set_dsm_param(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	maxdsm_update_caldata(ucontrol->value.integer.value[0]);
+	return 0;
+}
+static ssize_t max98506_cal_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return maxdsm_cal_prepare(buf);
+}
+static DEVICE_ATTR(dsm_cal, S_IRUGO, max98506_cal_show, NULL);
+#endif /* USE_DSM_UPDATE_CAL */
+
+#if defined(USE_DSM_LOG) || defined(USE_DSM_UPDATE_CAL)
+#define DEFAULT_LOG_CLASS_NAME "dsm"
+static const char *class_name_log = DEFAULT_LOG_CLASS_NAME;
+
+static struct attribute *max98506_attributes[] = {
+#ifdef USE_DSM_LOG
+	&dev_attr_dsm_log.attr,
+#endif /* USE_DSM_LOG */
+#ifdef USE_DSM_UPDATE_CAL
+	&dev_attr_dsm_cal.attr,
+#endif /* USE_DSM_UPDATE_CAL */
+	NULL
+};
+
+static struct attribute_group max98506_attribute_group = {
+	.attrs = max98506_attributes
+};
+#endif /* USE_DSM_LOG || USE_DSM_UPDATE_CAL */
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+
+static const unsigned int max98506_spk_tlv[] = {
+	TLV_DB_RANGE_HEAD(1),
+	1, 31, TLV_DB_SCALE_ITEM(-600, 100, 0),
+};
+
+static int max98506_spk_gain_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_pdata *pdata = max98506->pdata;
+
+	ucontrol->value.integer.value[0] = pdata->spk_gain;
+
+	return 0;
+}
+
+static int max98506_spk_gain_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_pdata *pdata = max98506->pdata;
+	unsigned int sel = ucontrol->value.integer.value[0];
+
+	regmap_update_bits(max98506->regmap, MAX98506_R02D_GAIN,
+			MAX98506_SPK_GAIN_MASK, sel << MAX98506_SPK_GAIN_SHIFT);
+
+	pdata->spk_gain = sel;
+
+	return 0;
+}
+
+static int max98506_reg_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol, unsigned int reg,
+		unsigned int mask, unsigned int shift)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	int data;
+
+	regmap_read(max98506->regmap, reg, &data);
+
+	ucontrol->value.integer.value[0] =
+		(data & mask) >> shift;
+
+	return 0;
+}
+
+static int max98506_reg_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol, unsigned int reg,
+		unsigned int mask, unsigned int shift)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	unsigned int sel = ucontrol->value.integer.value[0];
+
+	regmap_update_bits(max98506->regmap, reg, mask, sel << shift);
+
+	return 0;
+}
+
+static int max98506_spk_ramp_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_get(kcontrol, ucontrol, MAX98506_R02E_GAIN_RAMPING,
+			MAX98506_SPK_RMP_EN_MASK, MAX98506_SPK_RMP_EN_SHIFT);
+}
+
+static int max98506_spk_ramp_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_put(kcontrol, ucontrol, MAX98506_R02E_GAIN_RAMPING,
+			MAX98506_SPK_RMP_EN_MASK, MAX98506_SPK_RMP_EN_SHIFT);
+}
+
+static int max98506_spk_zcd_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_get(kcontrol, ucontrol, MAX98506_R02E_GAIN_RAMPING,
+			MAX98506_SPK_ZCD_EN_MASK, MAX98506_SPK_ZCD_EN_SHIFT);
+}
+
+static int max98506_spk_zcd_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_put(kcontrol, ucontrol, MAX98506_R02E_GAIN_RAMPING,
+			MAX98506_SPK_ZCD_EN_MASK, MAX98506_SPK_ZCD_EN_SHIFT);
+}
+
+static int max98506_alc_en_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_get(kcontrol, ucontrol, MAX98506_R030_THRESHOLD,
+			MAX98506_ALC_EN_MASK, MAX98506_ALC_EN_SHIFT);
+}
+
+static int max98506_alc_en_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_put(kcontrol, ucontrol, MAX98506_R030_THRESHOLD,
+			MAX98506_ALC_EN_MASK, MAX98506_ALC_EN_SHIFT);
+}
+
+static int max98506_alc_threshold_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_get(kcontrol, ucontrol, MAX98506_R030_THRESHOLD,
+			MAX98506_ALC_TH_MASK, MAX98506_ALC_TH_SHIFT);
+}
+
+static int max98506_alc_threshold_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	return max98506_reg_put(kcontrol, ucontrol, MAX98506_R030_THRESHOLD,
+			MAX98506_ALC_TH_MASK, MAX98506_ALC_TH_SHIFT);
+}
+
+static const char * const max98506_boost_voltage_text[] = {"8.5V", "8.25V",
+		"8.0V", "7.75V", "7.5V", "7.25V", "7.0V", "6.75V",
+		"6.5V", "6.5V", "6.5V", "6.5V", "6.5V", "6.5V", "6.5V", "6.5V"};
+
+static const struct soc_enum max98506_boost_voltage_enum =
+	SOC_ENUM_SINGLE(MAX98506_R037_CONFIGURATION,
+			MAX98506_BST_VOUT_SHIFT, 16,
+			max98506_boost_voltage_text);
+
+static const char * const spk_state_text[] = {"Disable", "Enable"};
+
+static const struct soc_enum spk_state_enum[] = {
+	SOC_ENUM_SINGLE_EXT(ARRAY_SIZE(spk_state_text), spk_state_text),
+};
+
+static void max98506_spk_enable(struct max98506_priv *max98506,
+		int enable)
+{
+	struct max98506_pdata *pdata = max98506->pdata;
+
+	if (enable) {
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R02D_GAIN,
+				MAX98506_SPK_GAIN_MASK,
+				pdata->spk_gain);
+
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R036_BLOCK_ENABLE,
+				MAX98506_BST_EN_MASK |
+				MAX98506_SPK_EN_MASK,
+				MAX98506_BST_EN_MASK |
+				MAX98506_SPK_EN_MASK);
+		regmap_write(max98506->regmap,
+				MAX98506_R038_GLOBAL_ENABLE,
+				MAX98506_EN_MASK);
+	} else {
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R02D_GAIN,
+				MAX98506_SPK_GAIN_MASK,
+				0x00);
+		usleep_range(4999, 5000);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R038_GLOBAL_ENABLE,
+				MAX98506_EN_MASK,
+				0x00);
+	}
+}
+
+static int max98506_spk_out_get(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol) {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	unsigned int val;
+
+	regmap_read(max98506->regmap,
+			MAX98506_R038_GLOBAL_ENABLE, &val);
+	ucontrol->value.integer.value[0] = !!(val & MAX98506_EN_MASK);
+
+	msg_maxim("The status of speaker is '%s'",
+			spk_state_text[ucontrol->value.integer.value[0]]);
+
+	return 0;
+}
+
+static int max98506_spk_out_put(struct snd_kcontrol *kcontrol,
+				struct snd_ctl_elem_value *ucontrol) {
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	int enable = !!ucontrol->value.integer.value[0];
+
+	max98506_spk_enable(max98506, enable);
+
+	msg_maxim("Speaker was set by '%s'", spk_state_text[enable]);
+
+	return 0;
+}
+
+static int max98506_adc_en_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	int data;
+
+	regmap_read(max98506->regmap, MAX98506_R036_BLOCK_ENABLE, &data);
+
+	if (data & MAX98506_ADC_VIMON_EN_MASK)
+		ucontrol->value.integer.value[0] = 1;
+	else
+		ucontrol->value.integer.value[0] = 0;
+
+	return 0;
+}
+
+static int max98506_adc_en_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_volume_step_info *vstep = &max98506->vstep;
+	int sel = (int)ucontrol->value.integer.value[0];
+
+	if (sel)
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R036_BLOCK_ENABLE,
+				MAX98506_ADC_VIMON_EN_MASK,
+				MAX98506_ADC_VIMON_EN_MASK);
+	else
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R036_BLOCK_ENABLE,
+				MAX98506_ADC_VIMON_EN_MASK,
+				0);
+
+	vstep->adc_status = !!sel;
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+	maxdsm_update_feature_en_adc(!!sel);
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+
+	return 0;
+}
+
+static int max98506_adc_thres_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_volume_step_info *vstep = &max98506->vstep;
+
+	ucontrol->value.integer.value[0] = vstep->adc_thres;
+
+	return 0;
+}
+
+static int max98506_adc_thres_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_volume_step_info *vstep = &max98506->vstep;
+	int ret = 0;
+
+	if (ucontrol->value.integer.value[0] >= MAX98506_VSTEP_0 &&
+			ucontrol->value.integer.value[0] <= MAX98506_VSTEP_15)
+		vstep->adc_thres = (int)ucontrol->value.integer.value[0];
+	else
+		ret = -EINVAL;
+
+	return ret;
+}
+
+static int max98506_volume_step_get(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_volume_step_info *vstep = &max98506->vstep;
+
+	ucontrol->value.integer.value[0] = vstep->vol_step;
+
+	return 0;
+}
+
+static int max98506_volume_step_put(struct snd_kcontrol *kcontrol,
+		struct snd_ctl_elem_value *ucontrol)
+{
+	struct snd_soc_codec *codec = snd_kcontrol_chip(kcontrol);
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_volume_step_info *vstep = &max98506->vstep;
+
+	int sel = (int)ucontrol->value.integer.value[0];
+	unsigned int mask = 0;
+	bool adc_status = vstep->adc_status;
+
+	/*
+	 * ADC status will be updated according to the volume.
+	 * Under step 7 : Disable
+	 * Over step 7  : Enable
+	 */
+	if (sel <= vstep->adc_thres
+			&& vstep->adc_status) {
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R036_BLOCK_ENABLE,
+				MAX98506_ADC_VIMON_EN_MASK,
+				0);
+		adc_status = !vstep->adc_status;
+	} else if (sel > vstep->adc_thres
+			&& !vstep->adc_status) {
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R036_BLOCK_ENABLE,
+				MAX98506_ADC_VIMON_EN_MASK,
+				MAX98506_ADC_VIMON_EN_MASK);
+		adc_status = !vstep->adc_status;
+	} else if (sel > MAX98506_VSTEP_MAX) {
+		msg_maxim("Unknown value %d", sel);
+		return -EINVAL;
+	}
+
+	if (adc_status != vstep->adc_status) {
+		vstep->adc_status = adc_status;
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+		maxdsm_update_feature_en_adc((int)adc_status);
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+	}
+
+	/*
+	 * Boost voltage will be updated according to the volume.
+	 * Step 0 ~ Step 13 : 6.5V
+	 * Step 14			: 8.0V
+	 * Over step 15		: 8.5V
+	 */
+	mask |= vstep->boost_step[sel];
+	mask <<= MAX98506_BST_VOUT_SHIFT;
+	regmap_update_bits(max98506->regmap,
+			MAX98506_R037_CONFIGURATION,
+			MAX98506_BST_VOUT_MASK,
+			mask);
+
+	/* Set volume step to ... */
+	vstep->vol_step = sel;
+
+	return 0;
+}
+
+static const struct snd_kcontrol_new max98506_snd_controls[] = {
+	SOC_SINGLE_EXT_TLV("Speaker Gain", MAX98506_R02D_GAIN,
+		MAX98506_SPK_GAIN_SHIFT,
+		(1 << MAX98506_SPK_GAIN_WIDTH) - 1,
+		0,
+		max98506_spk_gain_get,
+		max98506_spk_gain_put,
+		max98506_spk_tlv),
+
+	SOC_SINGLE_EXT("Speaker Ramp", 0, 0, 1, 0,
+		max98506_spk_ramp_get, max98506_spk_ramp_put),
+
+	SOC_SINGLE_EXT("Speaker ZCD", 0, 0, 1, 0,
+		max98506_spk_zcd_get, max98506_spk_zcd_put),
+
+	SOC_SINGLE_EXT("ALC Enable", 0, 0, 1, 0,
+		max98506_alc_en_get, max98506_alc_en_put),
+
+	SOC_SINGLE_EXT("ALC Threshold", 0, 0, (1<<MAX98506_ALC_TH_WIDTH)-1, 0,
+		max98506_alc_threshold_get, max98506_alc_threshold_put),
+
+	SOC_ENUM("Boost Output Voltage", max98506_boost_voltage_enum),
+
+	SOC_ENUM_EXT("SPK out", spk_state_enum[0],
+		max98506_spk_out_get, max98506_spk_out_put),
+
+	SOC_SINGLE_EXT("ADC Enable", 0, 0, 1, 0,
+			max98506_adc_en_get, max98506_adc_en_put),
+
+	SOC_SINGLE_EXT("ADC Threshold", SND_SOC_NOPM, 0, 15, 0,
+			max98506_adc_thres_get, max98506_adc_thres_put),
+
+	SOC_SINGLE_EXT("Volume Step", SND_SOC_NOPM, 0, 15, 0,
+			max98506_volume_step_get, max98506_volume_step_put),
+
+#ifdef USE_DSM_LOG
+	SOC_SINGLE_EXT("DSM LOG", SND_SOC_NOPM, 0, 3, 0,
+		max98506_get_dump_status, max98506_set_dump_status),
+#endif /* USE_DSM_LOG */
+#ifdef USE_DSM_UPDATE_CAL
+	SOC_SINGLE_EXT("DSM SetParam", SND_SOC_NOPM, 0, 1, 0,
+		max98506_get_dsm_param, max98506_set_dsm_param),
+#endif /* USE_DSM_UPDATE_CAL */
+};
+
+/* codec sample rate and n/m dividers parameter table */
+static const struct {
+	u32 rate;
+	u8  sr;
+} rate_table[] = {
+	{  8000, 0 },
+	{ 11025, 1 },
+	{ 12000, 2 },
+	{ 16000, 3 },
+	{ 22050, 4 },
+	{ 24000, 5 },
+	{ 32000, 6 },
+	{ 44100, 7 },
+	{ 48000, 8 },
+};
+
+static inline int max98506_rate_value(int rate, int clock, u8 *value)
+{
+	int ret = -ENODATA;
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(rate_table); i++) {
+		if (rate_table[i].rate >= rate) {
+			*value = rate_table[i].sr;
+			ret = 0;
+			break;
+		}
+	}
+
+	msg_maxim("sample rate is %d, returning %d",
+		rate_table[i].rate, *value);
+
+	return ret;
+}
+
+static int max98506_set_tdm_slot(struct snd_soc_dai *codec_dai,
+		unsigned int tx_mask, unsigned int rx_mask,
+		int slots, int slot_width)
+{
+	msg_maxim("tx_mask 0x%X, rx_mask 0x%X, slots %d, slot width %d",
+			tx_mask, rx_mask, slots, slot_width);
+	return 0;
+}
+
+static void max98506_set_slave(struct max98506_priv *max98506)
+{
+	struct max98506_pdata *pdata = max98506->pdata;
+
+	msg_maxim("enter");
+
+	/*
+	 * 1. use BCLK instead of MCLK
+	 */
+	regmap_update_bits(max98506->regmap,
+			MAX98506_R01A_DAI_CLK_MODE1,
+			MAX98506_DAI_CLK_SOURCE_MASK,
+			MAX98506_DAI_CLK_SOURCE_MASK);
+	/*
+	 * 2. set DAI to slave mode
+	 */
+	regmap_update_bits(max98506->regmap,
+			MAX98506_R01B_DAI_CLK_MODE2,
+			MAX98506_DAI_MAS_MASK,
+			0);
+	/*
+	 * 3. set BLCKs to LRCLKs to 64
+	 */
+	regmap_update_bits(max98506->regmap,
+			MAX98506_R01B_DAI_CLK_MODE2,
+			MAX98506_DAI_BSEL_MASK,
+			MAX98506_DAI_BSEL_32);
+	/*
+	 * 4. set VMON and IMON slots
+	 */
+	if (!pdata->vmon_slot)	{
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R022_DOUT_CFG_VMON,
+				MAX98506_DAI_VMON_EN_MASK,
+				MAX98506_DAI_VMON_EN_MASK);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R022_DOUT_CFG_VMON,
+				MAX98506_DAI_VMON_SLOT_MASK,
+				MAX98506_DAI_VMON_SLOT_02_03);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R023_DOUT_CFG_IMON,
+				MAX98506_DAI_IMON_EN_MASK,
+				MAX98506_DAI_IMON_EN_MASK);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R023_DOUT_CFG_IMON,
+				MAX98506_DAI_IMON_SLOT_MASK,
+				MAX98506_DAI_IMON_SLOT_00_01);
+	} else {
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R022_DOUT_CFG_VMON,
+				MAX98506_DAI_VMON_EN_MASK,
+				MAX98506_DAI_VMON_EN_MASK);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R022_DOUT_CFG_VMON,
+				MAX98506_DAI_VMON_SLOT_MASK,
+				MAX98506_DAI_VMON_SLOT_00_01);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R023_DOUT_CFG_IMON,
+				MAX98506_DAI_IMON_EN_MASK,
+				MAX98506_DAI_IMON_EN_MASK);
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R023_DOUT_CFG_IMON,
+				MAX98506_DAI_IMON_SLOT_MASK,
+				MAX98506_DAI_IMON_SLOT_02_03);
+	}
+}
+
+static void max98506_set_master(struct max98506_priv *max98506)
+{
+	msg_maxim("enter");
+
+	/*
+	 * 1. use MCLK for Left channel, right channel always BCLK
+	 */
+	regmap_update_bits(max98506->regmap, MAX98506_R01A_DAI_CLK_MODE1,
+			MAX98506_DAI_CLK_SOURCE_MASK, 0);
+	/*
+	 * 2. set left channel DAI to master mode, right channel always slave
+	 */
+	regmap_update_bits(max98506->regmap, MAX98506_R01B_DAI_CLK_MODE2,
+			MAX98506_DAI_MAS_MASK, MAX98506_DAI_MAS_MASK);
+}
+
+static int max98506_dai_set_fmt(struct snd_soc_dai *codec_dai,
+				 unsigned int fmt)
+{
+	struct snd_soc_codec *codec = codec_dai->codec;
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	unsigned int invert = 0;
+
+	msg_maxim("fmt 0x%08X", fmt);
+
+	switch (fmt & SND_SOC_DAIFMT_MASTER_MASK) {
+	case SND_SOC_DAIFMT_CBS_CFS:
+		max98506_set_slave(max98506);
+		break;
+	case SND_SOC_DAIFMT_CBM_CFM:
+		max98506_set_master(max98506);
+		break;
+	case SND_SOC_DAIFMT_CBS_CFM:
+	case SND_SOC_DAIFMT_CBM_CFS:
+	default:
+		dev_err(codec->dev, "DAI clock mode unsupported");
+		return -EINVAL;
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_FORMAT_MASK) {
+	case SND_SOC_DAIFMT_I2S:
+		msg_maxim("set SND_SOC_DAIFMT_I2S");
+		break;
+	case SND_SOC_DAIFMT_LEFT_J:
+		msg_maxim("set SND_SOC_DAIFMT_LEFT_J");
+		break;
+	case SND_SOC_DAIFMT_DSP_A:
+		msg_maxim("set SND_SOC_DAIFMT_DSP_A");
+	default:
+		dev_warn(codec->dev, "DAI format unsupported, fmt:0x%x", fmt);
+	}
+
+	switch (fmt & SND_SOC_DAIFMT_INV_MASK) {
+	case SND_SOC_DAIFMT_NB_NF:
+		break;
+	case SND_SOC_DAIFMT_NB_IF:
+		invert = MAX98506_DAI_WCI_MASK;
+		break;
+	case SND_SOC_DAIFMT_IB_NF:
+		invert = MAX98506_DAI_BCI_MASK;
+		break;
+	case SND_SOC_DAIFMT_IB_IF:
+		invert = MAX98506_DAI_BCI_MASK | MAX98506_DAI_WCI_MASK;
+		break;
+	default:
+		dev_err(codec->dev, "DAI invert mode unsupported");
+		return -EINVAL;
+	}
+
+	regmap_update_bits(max98506->regmap, MAX98506_R020_FORMAT,
+			MAX98506_DAI_BCI_MASK | MAX98506_DAI_WCI_MASK, invert);
+
+	return 0;
+}
+
+static int max98506_set_bias_level(struct snd_soc_codec *codec,
+				   enum snd_soc_bias_level level)
+{
+	codec->dapm.bias_level = level;
+	return 0;
+}
+
+static int max98506_set_clock(struct max98506_priv *max98506, unsigned int rate)
+{
+	struct snd_soc_codec *codec = max98506->codec;
+	struct max98506_pdata *pdata = max98506->pdata;
+	unsigned int clock;
+	unsigned int mdll;
+	u8 dai_sr = 0;
+
+	switch (pdata->sysclk) {
+	case 6000000:
+		clock = 0;
+		mdll  = MAX98506_MDLL_MULT_MCLKx16;
+		break;
+	case 11289600:
+		clock = 1;
+		mdll  = MAX98506_MDLL_MULT_MCLKx8;
+		break;
+	case 12000000:
+		clock = 0;
+		mdll  = MAX98506_MDLL_MULT_MCLKx8;
+		break;
+	case 12288000:
+		clock = 2;
+		mdll  = MAX98506_MDLL_MULT_MCLKx8;
+		break;
+	default:
+		dev_info(codec->dev, "unsupported sysclk %d\n",
+					pdata->sysclk);
+		return -EINVAL;
+	}
+
+	if (max98506_rate_value(rate, clock, &dai_sr))
+		return -EINVAL;
+
+	/*
+	 * 1. set DAI_SR to correct LRCLK frequency
+	 */
+	regmap_update_bits(max98506->regmap, MAX98506_R01B_DAI_CLK_MODE2,
+			MAX98506_DAI_SR_MASK, dai_sr << MAX98506_DAI_SR_SHIFT);
+	/*
+	 * 2. set MDLL
+	 */
+	regmap_update_bits(max98506->regmap,
+			MAX98506_R01A_DAI_CLK_MODE1,
+			MAX98506_MDLL_MULT_MASK,
+			mdll << MAX98506_MDLL_MULT_SHIFT);
+
+	return 0;
+}
+
+static int max98506_dai_hw_params(struct snd_pcm_substream *substream,
+				   struct snd_pcm_hw_params *params,
+				   struct snd_soc_dai *dai)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	unsigned int rate;
+
+	msg_maxim("enter");
+
+	rate = params_rate(params);
+
+	switch (params_format(params)) {
+	case SNDRV_PCM_FORMAT_S16_LE:
+		msg_maxim("set SNDRV_PCM_FORMAT_S16_LE");
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R020_FORMAT,
+				MAX98506_DAI_CHANSZ_MASK,
+				MAX98506_DAI_CHANSZ_16);
+		break;
+	case SNDRV_PCM_FORMAT_S24_LE:
+		msg_maxim("set SNDRV_PCM_FORMAT_S24_LE");
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R020_FORMAT,
+				MAX98506_DAI_CHANSZ_MASK,
+				MAX98506_DAI_CHANSZ_32);
+		msg_maxim("(really set to 32 bits)");
+		break;
+	case SNDRV_PCM_FORMAT_S32_LE:
+		msg_maxim("set SNDRV_PCM_FORMAT_S32_LE");
+		regmap_update_bits(max98506->regmap,
+				MAX98506_R020_FORMAT,
+				MAX98506_DAI_CHANSZ_MASK,
+				MAX98506_DAI_CHANSZ_32);
+		break;
+	default:
+		msg_maxim("format unsupported %d", params_format(params));
+		return -EINVAL;
+	}
+
+	return max98506_set_clock(max98506, rate);
+}
+
+static int max98506_dai_set_sysclk(struct snd_soc_dai *dai,
+				   int clk_id, unsigned int freq, int dir)
+{
+	struct snd_soc_codec *codec = dai->codec;
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_pdata *pdata = max98506->pdata;
+
+	msg_maxim("clk_id %d, freq %d, dir %d", clk_id, freq, dir);
+
+	pdata->sysclk = freq;
+
+	return 0;
+}
+
+#define MAX98506_RATES SNDRV_PCM_RATE_8000_48000
+#define MAX98506_FORMATS (SNDRV_PCM_FMTBIT_S16_LE | \
+			SNDRV_PCM_FMTBIT_S24_LE | SNDRV_PCM_FMTBIT_S32_LE)
+static struct snd_soc_dai_ops max98506_dai_ops = {
+	.set_sysclk = max98506_dai_set_sysclk,
+	.set_fmt = max98506_dai_set_fmt,
+	.set_tdm_slot = max98506_set_tdm_slot,
+	.hw_params = max98506_dai_hw_params,
+};
+
+static struct snd_soc_dai_driver max98506_dai[] = {
+	{
+		.name = "max98506-aif1",
+		.playback = {
+			.stream_name = "HiFi Playback",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MAX98506_RATES,
+			.formats = MAX98506_FORMATS,
+		},
+		.capture = {
+			.stream_name = "HiFi Capture",
+			.channels_min = 1,
+			.channels_max = 2,
+			.rates = MAX98506_RATES,
+			.formats = MAX98506_FORMATS,
+		},
+		.ops = &max98506_dai_ops,
+	}
+};
+
+static void max98506_handle_pdata(struct snd_soc_codec *codec)
+{
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_pdata *pdata = max98506->pdata;
+	struct reg_default *reg_chg;
+	int loop;
+	int len = pdata->reg_arr_len / sizeof(uint32_t);
+
+	if (!pdata) {
+		dev_dbg(codec->dev, "No platform data\n");
+		return;
+	}
+
+	if (pdata->reg_arr != NULL) {
+		for (loop = 0; loop < len; loop += 2) {
+			reg_chg = (struct reg_default *)&pdata->reg_arr[loop];
+			msg_maxim("[0x%02x, 0x%02x]",
+					be32_to_cpu(reg_chg->reg),
+					be32_to_cpu(reg_chg->def));
+			regmap_write(max98506->regmap,
+					be32_to_cpu(reg_chg->reg),
+					be32_to_cpu(reg_chg->def));
+		}
+	}
+}
+
+#ifdef CONFIG_PM
+static int max98506_suspend(struct snd_soc_codec *codec)
+{
+	msg_maxim("enter");
+
+	return 0;
+}
+
+static int max98506_resume(struct snd_soc_codec *codec)
+{
+	msg_maxim("enter");
+
+	return 0;
+}
+#else
+#define max98506_suspend NULL
+#define max98506_resume NULL
+#endif /* CONFIG_PM */
+
+#ifdef USE_MAX98506_IRQ
+static irqreturn_t max98506_interrupt(int irq, void *data)
+{
+	struct max98506_priv *max98506 = (struct max98506_priv *) data;
+
+	unsigned int mask0;
+	unsigned int mask1;
+	unsigned int mask2;
+	unsigned int flag0;
+	unsigned int flag1;
+	unsigned int flag2;
+
+	regmap_read(max98506->regmap, MAX98506_R00B_IRQ_ENABLE0, &mask0);
+	regmap_read(max98506->regmap, MAX98506_R008_FLAG0, &flag0);
+
+	regmap_read(max98506->regmap, MAX98506_R00C_IRQ_ENABLE1, &mask1);
+	regmap_read(max98506->regmap, MAX98506_R009_FLAG1, &flag1);
+
+	regmap_read(max98506->regmap, MAX98506_R00D_IRQ_ENABLE2, &mask2);
+	regmap_read(max98506->regmap, MAX98506_R00A_FLAG2, &flag2);
+
+	flag0 &= mask0;
+	flag1 &= mask1;
+	flag2 &= mask2;
+
+	if (!flag0 && !flag1 && !flag2)
+		return IRQ_NONE;
+
+	/* Send work to be scheduled */
+	if (flag0 & MAX98506_THERMWARN_END_STATE_MASK)
+		msg_maxim("MAX98506_THERMWARN_STATE_MASK active!");
+
+	if (flag0 & MAX98506_THERMWARN_BGN_STATE_MASK)
+		msg_maxim("MAX98506_THERMWARN_BGN_STATE_MASK active!");
+
+	if (flag0 & MAX98506_THERMSHDN_END_STATE_MASK)
+		msg_maxim("MAX98506_THERMSHDN_END_STATE_MASK active!");
+
+	if (flag0 & MAX98506_THERMSHDN_BGN_STATE_MASK)
+		msg_maxim("MAX98506_THERMSHDN_BGN_STATE_MASK active!");
+
+	if (flag1 & MAX98506_SPRCURNT_STATE_MASK)
+		msg_maxim("MAX98506_SPRCURNT_STATE_MASK active!");
+
+	if (flag1 & MAX98506_WATCHFAIL_STATE_MASK)
+		msg_maxim("MAX98506_WATCHFAIL_STATE_MASK active!");
+
+	if (flag1 & MAX98506_ALCINFH_STATE_MASK)
+		msg_maxim("MAX98506_ALCINFH_STATE_MASK active!");
+
+	if (flag1 & MAX98506_ALCACT_STATE_MASK)
+		msg_maxim("MAX98506_ALCACT_STATE_MASK active!");
+
+	if (flag1 & MAX98506_ALCMUT_STATE_MASK)
+		msg_maxim("MAX98506_ALCMUT_STATE_MASK active!");
+
+	if (flag1 & MAX98506_ALCP_STATE_MASK)
+		msg_maxim("MAX98506_ALCP_STATE_MASK active!");
+
+	if (flag2 & MAX98506_SLOTOVRN_STATE_MASK)
+		msg_maxim("MAX98506_SLOTOVRN_STATE_MASK active!");
+
+	if (flag2 & MAX98506_INVALSLOT_STATE_MASK)
+		msg_maxim("MAX98506_INVALSLOT_STATE_MASK active!");
+
+	if (flag2 & MAX98506_SLOTCNFLT_STATE_MASK)
+		msg_maxim("MAX98506_SLOTCNFLT_STATE_MASK active!");
+
+	if (flag2 & MAX98506_VBSTOVFL_STATE_MASK)
+		msg_maxim("MAX98506_VBSTOVFL_STATE_MASK active!");
+
+	if (flag2 & MAX98506_VBATOVFL_STATE_MASK)
+		msg_maxim("MAX98506_VBATOVFL_STATE_MASK active!");
+
+	if (flag2 & MAX98506_IMONOVFL_STATE_MASK)
+		msg_maxim("MAX98506_IMONOVFL_STATE_MASK active!");
+
+	if (flag2 & MAX98506_VMONOVFL_STATE_MASK)
+		msg_maxim("MAX98506_VMONOVFL_STATE_MASK active!");
+
+	regmap_write(max98506->regmap, MAX98506_R00E_IRQ_CLEAR0,
+			flag0&0xff);
+	regmap_write(max98506->regmap, MAX98506_R00F_IRQ_CLEAR1,
+			flag1&0xff);
+	regmap_write(max98506->regmap, MAX98506_R010_IRQ_CLEAR2,
+			flag2&0xff);
+
+	return IRQ_HANDLED;
+}
+#endif /* USE_MAX98506_IRQ */
+
+static int reg_set_optimum_mode_check(struct regulator *reg, int load_ua)
+{
+	return (regulator_count_voltages(reg) > 0) ?
+		regulator_set_optimum_mode(reg, load_ua) : 0;
+}
+
+#define VCC_I2C_MIN_UV	1800000
+#define VCC_I2C_MAX_UV	1800000
+#define I2C_LOAD_UA	300000
+static int max98506_regulator_config(struct device *dev)
+{
+	struct regulator *max98506_vcc_i2c;
+	int ret;
+
+	max98506_vcc_i2c = regulator_get(dev, "vcc_i2c");
+	if (IS_ERR(max98506_vcc_i2c)) {
+		ret = PTR_ERR(max98506_vcc_i2c);
+		dev_err(dev, "%s: regulator get failed ret=%d\n",
+				__func__, ret);
+		goto err_get_vtg_i2c;
+	}
+	if (regulator_count_voltages(max98506_vcc_i2c) > 0) {
+		ret = regulator_set_voltage(max98506_vcc_i2c,
+				VCC_I2C_MIN_UV, VCC_I2C_MAX_UV);
+		if (ret) {
+			dev_err(dev, "%s: regulator set_vtg failed ret=%d\n",
+					__func__, ret);
+			goto err_set_vtg_i2c;
+		}
+	}
+
+	ret = reg_set_optimum_mode_check(max98506_vcc_i2c, I2C_LOAD_UA);
+	if (ret < 0) {
+		dev_err(dev, "%s: regulator vcc_i2c set_opt failed ret=%d\n",
+				__func__, ret);
+		goto err_reg_opt_i2c;
+	}
+
+	ret = regulator_enable(max98506_vcc_i2c);
+	if (ret) {
+		dev_err(dev, "%s: regulator vcc_i2c enable failed ret=%d\n",
+				__func__, ret);
+		goto err_reg_en_vcc_i2c;
+	}
+
+	msg_maxim("min_uv:%d max_uv:%d load_ua:%d",
+		VCC_I2C_MIN_UV, VCC_I2C_MAX_UV, I2C_LOAD_UA);
+
+	return 0;
+
+err_set_vtg_i2c:
+	regulator_put(max98506_vcc_i2c);
+
+err_get_vtg_i2c:
+	if (regulator_count_voltages(max98506_vcc_i2c) > 0)
+		regulator_set_voltage(max98506_vcc_i2c, 0, VCC_I2C_MAX_UV);
+
+err_reg_en_vcc_i2c:
+	reg_set_optimum_mode_check(max98506_vcc_i2c, 0);
+
+err_reg_opt_i2c:
+	regulator_disable(max98506_vcc_i2c);
+
+	return ret;
+}
+
+static int max98506_check_version(struct max98506_priv *max98506)
+{
+	uint32_t reg = 0x00;
+	uint32_t version_table[] = {
+		MAX98506_VERSION,
+		MAX98506_VERSION1,
+		MAX98506_VERSION2,
+		MAX98506_VERSION3,
+		MAX98506_VERSION4,
+		MAX98506_VERSION5,
+	};
+	int loop;
+
+	regmap_read(max98506->regmap, MAX98506_R0FF_VERSION, &reg);
+
+	for (loop = 0; loop < ARRAY_SIZE(version_table); loop++) {
+		if (reg == version_table[loop])
+			return reg;
+	}
+
+	return 0;
+}
+
+static int max98506_probe(struct snd_soc_codec *codec)
+{
+	struct max98506_priv *max98506 = snd_soc_codec_get_drvdata(codec);
+	struct max98506_volume_step_info *vstep = &max98506->vstep;
+	int ret = 0;
+	int reg = 0;
+
+	dev_info(codec->dev, "build number %s\n", MAX98506_REVISION);
+
+	max98506->codec = codec;
+	codec->control_data = max98506->regmap;
+
+	ret = snd_soc_codec_set_cache_io(codec, 8, 8, SND_SOC_I2C);
+	if (ret != 0) {
+		dev_err(codec->dev, "Failed to set cache I/O: %d\n", ret);
+		return ret;
+	}
+
+	reg = max98506_check_version(max98506);
+	if (!reg) {
+		dev_err(codec->dev,
+			"device initialization error (0x%02X)\n",
+			reg);
+		goto err_version;
+	}
+	msg_maxim("device version 0x%02x", reg);
+
+	regmap_write(max98506->regmap, MAX98506_R038_GLOBAL_ENABLE, 0x80);
+
+	/* It's not the default but we need to set DAI_DLY */
+	regmap_write(max98506->regmap, MAX98506_R020_FORMAT,
+		MAX98506_DAI_DLY_MASK);
+
+	regmap_write(max98506->regmap, MAX98506_R021_TDM_SLOT_SELECT, 0xC8);
+
+	regmap_write(max98506->regmap, MAX98506_R027_DOUT_HIZ_CFG1, 0xFF);
+	regmap_write(max98506->regmap, MAX98506_R028_DOUT_HIZ_CFG2, 0xFF);
+	regmap_write(max98506->regmap, MAX98506_R029_DOUT_HIZ_CFG3, 0xFF);
+	regmap_write(max98506->regmap, MAX98506_R02A_DOUT_HIZ_CFG4, 0xF0);
+	regmap_write(max98506->regmap, MAX98506_R02C_FILTERS, 0xD9);
+
+	regmap_update_bits(max98506->regmap,
+		MAX98506_R02D_GAIN, MAX98506_DAC_IN_SEL_MASK,
+		MAX98506_DAC_IN_SEL_DIV2_SUMMED_DAI);
+
+	regmap_write(max98506->regmap, MAX98506_R02F_SPK_AMP, 0x02);
+	regmap_write(max98506->regmap, MAX98506_R034_ALC_CONFIGURATION, 0x12);
+
+	/* Enable ADC and Speaker */
+	regmap_update_bits(max98506->regmap,
+			MAX98506_R036_BLOCK_ENABLE,
+			MAX98506_ADC_VIMON_EN_MASK |
+			MAX98506_SPK_EN_MASK,
+			MAX98506_ADC_VIMON_EN_MASK |
+			MAX98506_SPK_EN_MASK);
+	vstep->adc_status = 1;
+
+	/* Set boost output to maximum */
+	regmap_write(max98506->regmap, MAX98506_R037_CONFIGURATION, 0x00);
+
+	/* Disable ALC muting */
+	regmap_write(max98506->regmap, MAX98506_R03A_BOOST_LIMITER, 0xF8);
+
+	max98506_set_slave(max98506);
+	max98506_handle_pdata(codec);
+
+#if defined(USE_DSM_LOG) || defined(USE_DSM_UPDATE_CAL)
+	if (!g_class)
+		g_class = class_create(THIS_MODULE, class_name_log);
+	max98506->dev_log_class = g_class;
+	if (max98506->dev_log_class) {
+		max98506->dev_log =
+			device_create(max98506->dev_log_class,
+					NULL, 1, NULL, "max98506");
+		if (IS_ERR(max98506->dev_log)) {
+			ret = sysfs_create_group(&codec->dev->kobj,
+				&max98506_attribute_group);
+			if (ret)
+				msg_maxim(
+				"failed to create sysfs group [%d]", ret);
+		} else {
+			ret = sysfs_create_group(&max98506->dev_log->kobj,
+				&max98506_attribute_group);
+			if (ret)
+				msg_maxim(
+				"failed to create sysfs group [%d]", ret);
+		}
+	}
+	msg_maxim("g_class=%p %p", g_class, max98506->dev_log_class);
+#endif /* USE_DSM_LOG */
+
+err_version:
+	msg_maxim("exit %d", ret);
+
+	return ret;
+}
+
+static int max98506_remove(struct snd_soc_codec *codec)
+{
+	msg_maxim("enter");
+
+	return 0;
+}
+
+static struct snd_soc_codec_driver soc_codec_dev_max98506 = {
+	.probe			= max98506_probe,
+	.remove			= max98506_remove,
+	.set_bias_level		= max98506_set_bias_level,
+	.suspend		= max98506_suspend,
+	.resume			= max98506_resume,
+	.controls		= max98506_snd_controls,
+	.num_controls		= ARRAY_SIZE(max98506_snd_controls),
+};
+
+static const struct regmap_config max98506_regmap = {
+	.reg_bits         = 8,
+	.val_bits         = 8,
+	.max_register     = MAX98506_R0FF_VERSION,
+	.reg_defaults     = max98506_reg,
+	.num_reg_defaults = ARRAY_SIZE(max98506_reg),
+	.volatile_reg     = max98506_volatile_register,
+	.readable_reg     = max98506_readable_register,
+	.cache_type       = REGCACHE_RBTREE,
+};
+
+static int max98506_i2c_probe(struct i2c_client *i2c,
+			     const struct i2c_device_id *id)
+{
+	struct max98506_priv *max98506;
+	struct max98506_pdata *pdata;
+	struct max98506_volume_step_info *vstep;
+	int ret;
+	int pinfo_status = 0;
+
+	msg_maxim("enter, device '%s'", id->name);
+
+	max98506 = devm_kzalloc(&i2c->dev,
+			sizeof(struct max98506_priv), GFP_KERNEL);
+	if (!max98506) {
+		ret = -ENOMEM;
+		goto err_allocate_priv;
+	}
+
+	max98506->pdata = devm_kzalloc(&i2c->dev,
+			sizeof(struct max98506_pdata), GFP_KERNEL);
+	if (!max98506->pdata) {
+		ret = -ENOMEM;
+		goto err_allocate_pdata;
+	}
+
+	i2c_set_clientdata(i2c, max98506);
+	pdata = max98506->pdata;
+	vstep = &max98506->vstep;
+
+	if (i2c->dev.of_node) {
+		/* Read system clock */
+		ret = of_property_read_u32(i2c->dev.of_node,
+				"maxim,sysclk", &pdata->sysclk);
+		if (ret) {
+			dev_err(&i2c->dev, "There is no sysclk property.");
+			pdata->sysclk = 12288000;
+		}
+
+		/* Read speaker volume */
+		ret = of_property_read_u32(i2c->dev.of_node,
+				"maxim,spk-gain", &pdata->spk_gain);
+		if (ret) {
+			dev_err(&i2c->dev, "There is no spk_gain property.");
+			pdata->spk_gain = 0x14;
+		}
+
+		/* Read VMON slot info.*/
+		ret = of_property_read_u32(i2c->dev.of_node,
+				"maxim,vmon_slot", &pdata->vmon_slot);
+		if (ret) {
+			dev_err(&i2c->dev, "There is no vmon_slot property.");
+			pdata->vmon_slot = 0;
+		}
+
+		/* Regulator status */
+		pdata->i2c_pull_up = of_property_read_bool(
+				i2c->dev.of_node, "maxim,i2c-pull-up");
+		if (pdata->i2c_pull_up)
+			max98506_regulator_config(&i2c->dev);
+
+#ifdef USE_MAX98506_IRQ
+		pdata->irq = of_get_named_gpio_flags(
+				i2c->dev.of_node, "maxim,irq-gpio", 0, NULL);
+#endif /* USE_MAX98506_IRQ */
+
+		/* Read information related to DSM */
+		ret = of_property_read_u32_array(i2c->dev.of_node,
+			"maxim,platform_info", (u32 *) &pdata->pinfo,
+			sizeof(pdata->pinfo)/sizeof(uint32_t));
+		if (ret)
+			dev_err(&i2c->dev, "There is no platform info. property.\n");
+		else
+			pinfo_status = 1;
+
+		ret = of_property_read_u32_array(i2c->dev.of_node,
+			"maxim,boost_step",
+			(uint32_t *) &vstep->boost_step,
+			sizeof(vstep->boost_step)/sizeof(uint32_t));
+		if (ret) {
+			dev_err(&i2c->dev, "There is no boost_step property.\n");
+			for (ret = 0; ret < MAX98506_VSTEP_14; ret++)
+				vstep->boost_step[ret] = 0x0F;
+			vstep->boost_step[MAX98506_VSTEP_14] = 0x02;
+			vstep->boost_step[MAX98506_VSTEP_15] = 0x00;
+		}
+
+		ret = of_property_read_u32(i2c->dev.of_node,
+				"maxim,adc_threshold", &vstep->adc_thres);
+		if (ret) {
+			dev_err(&i2c->dev, "There is no adc_threshold property.");
+			vstep->adc_thres = MAX98506_VSTEP_7;
+		}
+
+		pdata->reg_arr = of_get_property(i2c->dev.of_node,
+				"maxim,registers-of-amp", &pdata->reg_arr_len);
+		if (pdata->reg_arr == NULL)
+			dev_err(&i2c->dev, "There is no registers-diff property.");
+
+#ifdef USE_DSM_LOG
+		ret = of_property_read_string(i2c->dev.of_node,
+			"maxim,log_class", &class_name_log);
+		if (ret) {
+			dev_err(&i2c->dev, "There is no log_class property.\n");
+			class_name_log = DEFAULT_LOG_CLASS_NAME;
+		}
+#endif /* USE_DSM_LOG */
+	} else {
+		pdata->sysclk = 12288000;
+		pdata->spk_gain = 0x14;
+		pdata->vmon_slot = 0;
+	}
+
+#ifdef USE_MAX98506_IRQ
+	if (pdata != NULL && gpio_is_valid(pdata->irq)) {
+		ret = gpio_request(pdata->irq, "max98506_irq_gpio");
+		if (ret) {
+			dev_err(&i2c->dev, "unable to request gpio [%d]",
+					pdata->irq);
+			goto err_irq_gpio_req;
+		}
+		ret = gpio_direction_input(pdata->irq);
+		if (ret) {
+			dev_err(&i2c->dev,
+					"unable to set direction for gpio [%d]",
+					pdata->irq);
+			goto err_irq_gpio_req;
+		}
+		i2c->irq = gpio_to_irq(pdata->irq);
+
+		ret = request_threaded_irq(i2c->irq, NULL, max98506_interrupt,
+				IRQF_TRIGGER_FALLING | IRQF_ONESHOT,
+				"max98506_interrupt", max98506);
+		if (ret)
+			dev_err(&i2c->dev, "Failed to register interrupt");
+	} else {
+		dev_err(&i2c->dev, "irq gpio not provided\n");
+	}
+	dev_dbg(&i2c->dev, "requested irq for max98506");
+	goto go_ahead_next_step;
+
+err_irq_gpio_req:
+	if (gpio_is_valid(pdata->irq))
+		gpio_free(pdata->irq);
+
+go_ahead_next_step:
+#endif /* USE_MAX98506_IRQ */
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+	maxdsm_init();
+	if (pinfo_status)
+#ifdef CONFIG_MACH_KACTIVELTE_KOR
+		maxdsm_update_info(pdata->pinfo);
+#else
+		dev_info(&i2c->dev, "pinfo will be ignored.\n");
+#endif /* CONFIG_MACH_KACTIVELTE_KOR */
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+
+	ret = snd_soc_register_codec(&i2c->dev, &soc_codec_dev_max98506,
+			max98506_dai, ARRAY_SIZE(max98506_dai));
+	if (ret) {
+		dev_err(&i2c->dev, "Failed to register codec");
+		goto err_register_codec;
+	}
+
+	max98506->regmap = regmap_init_i2c(i2c, &max98506_regmap);
+	if (IS_ERR(max98506->regmap)) {
+		ret = PTR_ERR(max98506->regmap);
+		dev_err(&i2c->dev, "Failed to initialize regmap: %d", ret);
+		goto err_regmap;
+	}
+
+	msg_maxim("exit, device '%s'", id->name);
+
+	return 0;
+
+err_regmap:
+	snd_soc_unregister_codec(&i2c->dev);
+	if (max98506->regmap)
+		regmap_exit(max98506->regmap);
+
+err_register_codec:
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+	maxdsm_deinit();
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+	devm_kfree(&i2c->dev, max98506->pdata);
+
+err_allocate_pdata:
+	devm_kfree(&i2c->dev, max98506);
+
+err_allocate_priv:
+	msg_maxim("exit with errors. ret=%d", ret);
+
+	return ret;
+}
+
+static int max98506_i2c_remove(struct i2c_client *client)
+{
+	struct max98506_priv *max98506 = i2c_get_clientdata(client);
+
+	snd_soc_unregister_codec(&client->dev);
+	if (max98506->regmap)
+		regmap_exit(max98506->regmap);
+	devm_kfree(&client->dev, max98506->pdata);
+	devm_kfree(&client->dev, max98506);
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+	maxdsm_deinit();
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+
+	msg_maxim("exit");
+
+	return 0;
+}
+
+#ifdef CONFIG_OF
+static const struct of_device_id max98506_dt_ids[] = {
+	{ .compatible = "maxim,max98506" },
+	{ }
+};
+#else
+#define max98506_dt_ids NULL
+#endif /* CONFIG_OF */
+
+static const struct i2c_device_id max98506_i2c_id[] = {
+	{ "max98506", MAX98506 },
+	{ }
+};
+MODULE_DEVICE_TABLE(i2c, max98506_i2c_id);
+
+static struct i2c_driver max98506_i2c_driver = {
+	.driver = {
+		.name = "max98506",
+		.owner = THIS_MODULE,
+		.of_match_table = max98506_dt_ids,
+	},
+	.probe  = max98506_i2c_probe,
+	.remove = max98506_i2c_remove,
+	.id_table = max98506_i2c_id,
+};
+
+module_i2c_driver(max98506_i2c_driver);
+
+MODULE_DESCRIPTION("ALSA SoC MAX98506 driver");
+MODULE_AUTHOR("Ralph Birt <rdbirt@gmail.com>");
+MODULE_AUTHOR("KyoungHun Jeon <hun.jeon@maximintegrated.com>");
+MODULE_LICENSE("GPL");
diff -X dontdiff -Nuarb a/sound/soc/codecs/max98506.h b/sound/soc/codecs/max98506.h
--- a/sound/soc/codecs/max98506.h	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/codecs/max98506.h	2015-12-01 05:58:58.000000000 -0500
@@ -0,0 +1,721 @@
+/*
+ * max98506.h -- MAX98506 ALSA SoC Audio driver
+ *
+ * Copyright 2013-2015 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+#ifndef _MAX98506_H
+#define _MAX98506_H
+
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+#include <sound/maxim_dsm.h>
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+
+/*
+ * The version of max98506
+ */
+#define MAX98506_VERSION			0x51
+#define	MAX98506_VERSION1			0x80
+#define	MAX98506_VERSION2			0x8A
+#define	MAX98506_VERSION3			0x8B
+#define	MAX98506_VERSION4			0x40
+#define	MAX98506_VERSION5			0x50
+
+/*
+ * Driver revision
+ */
+#define MAX98506_REVISION				"0.00.0010"
+
+/*
+ * MAX98506 Register Definitions
+ */
+#define MAX98506_R002_LIVE_STATUS0			0x02
+#define MAX98506_R003_LIVE_STATUS1			0x03
+#define MAX98506_R004_LIVE_STATUS2			0x04
+#define MAX98506_R005_STATE0				0x05
+#define MAX98506_R006_STATE1				0x06
+#define MAX98506_R007_STATE2				0x07
+#define MAX98506_R008_FLAG0				0x08
+#define MAX98506_R009_FLAG1				0x09
+#define MAX98506_R00A_FLAG2				0x0A
+#define MAX98506_R00B_IRQ_ENABLE0			0x0B
+#define MAX98506_R00C_IRQ_ENABLE1			0x0C
+#define MAX98506_R00D_IRQ_ENABLE2			0x0D
+#define MAX98506_R00E_IRQ_CLEAR0			0x0E
+#define MAX98506_R00F_IRQ_CLEAR1			0x0F
+#define MAX98506_R010_IRQ_CLEAR2			0x10
+#define MAX98506_R01A_DAI_CLK_MODE1			0x1A
+#define MAX98506_R01B_DAI_CLK_MODE2			0x1B
+#define MAX98506_R01F_DAI_CLK_DIV_N_LSBS		0x1F
+#define MAX98506_R020_FORMAT				0x20
+#define MAX98506_R021_TDM_SLOT_SELECT			0x21
+#define MAX98506_R022_DOUT_CFG_VMON			0x22
+#define MAX98506_R023_DOUT_CFG_IMON			0x23
+#define MAX98506_R024_DAI_INT_CFG			0x24
+#define MAX98506_R026_DOUT_CFG_FLAG			0x26
+#define MAX98506_R027_DOUT_HIZ_CFG1			0x27
+#define MAX98506_R028_DOUT_HIZ_CFG2			0x28
+#define MAX98506_R029_DOUT_HIZ_CFG3			0x29
+#define MAX98506_R02A_DOUT_HIZ_CFG4			0x2A
+#define MAX98506_R02B_DOUT_DRV_STRENGTH			0x2B
+#define MAX98506_R02C_FILTERS				0x2C
+#define MAX98506_R02D_GAIN				0x2D
+#define MAX98506_R02E_GAIN_RAMPING			0x2E
+#define MAX98506_R02F_SPK_AMP				0x2F
+#define MAX98506_R030_THRESHOLD				0x30
+#define MAX98506_R031_ALC_ATTACK			0x31
+#define MAX98506_R032_ALC_ATTEN_RLS			0x32
+#define MAX98506_R033_ALC_HOLD_RLS			0x33
+#define MAX98506_R034_ALC_CONFIGURATION			0x34
+#define MAX98506_R035_BOOST_CONVERTER			0x35
+#define MAX98506_R036_BLOCK_ENABLE			0x36
+#define MAX98506_R037_CONFIGURATION			0x37
+#define MAX98506_R038_GLOBAL_ENABLE			0x38
+#define MAX98506_R03A_BOOST_LIMITER			0x3A
+#define MAX98506_R0FF_VERSION				0xFF
+
+#define MAX98506_REG_CNT	(MAX98506_R03A_BOOST_LIMITER+1)
+
+/* MAX98506 Register Bit Fields */
+
+/* MAX98506_R002_LIVE_STATUS0 */
+#define MAX98506_THERMWARN_STATUS_MASK			(1<<3)
+#define MAX98506_THERMWARN_STATUS_SHIFT			3
+#define MAX98506_THERMWARN_STATUS_WIDTH			1
+#define MAX98506_THERMSHDN_STATUS_MASK			(1<<1)
+#define MAX98506_THERMSHDN_STATUS_SHIFT			1
+#define MAX98506_THERMSHDN_STATUS_WIDTH			1
+
+/* MAX98506_R003_LIVE_STATUS1 */
+#define MAX98506_SPKCURNT_STATUS_MASK			(1<<5)
+#define MAX98506_SPKCURNT_STATUS_SHIFT			5
+#define MAX98506_SPKCURNT_STATUS_WIDTH			1
+#define MAX98506_WATCHFAIL_STATUS_MASK			(1<<4)
+#define MAX98506_WATCHFAIL_STATUS_SHIFT			4
+#define MAX98506_WATCHFAIL_STATUS_WIDTH			1
+#define MAX98506_ALCINFH_STATUS_MASK			(1<<3)
+#define MAX98506_ALCINFH_STATUS_SHIFT			3
+#define MAX98506_ALCINFH_STATUS_WIDTH			1
+#define MAX98506_ALCACT_STATUS_MASK			(1<<2)
+#define MAX98506_ALCACT_STATUS_SHIFT			2
+#define MAX98506_ALCACT_STATUS_WIDTH			1
+#define MAX98506_ALCMUT_STATUS_MASK			(1<<1)
+#define MAX98506_ALCMUT_STATUS_SHIFT			1
+#define MAX98506_ALCMUT_STATUS_WIDTH			1
+#define MAX98506_ACLP_STATUS_MASK			(1<<0)
+#define MAX98506_ACLP_STATUS_SHIFT			0
+#define MAX98506_ACLP_STATUS_WIDTH			1
+
+/* MAX98506_R004_LIVE_STATUS2 */
+#define MAX98506_SLOTOVRN_STATUS_MASK			(1<<6)
+#define MAX98506_SLOTOVRN_STATUS_SHIFT			6
+#define MAX98506_SLOTOVRN_STATUS_WIDTH			1
+#define MAX98506_INVALSLOT_STATUS_MASK			(1<<5)
+#define MAX98506_INVALSLOT_STATUS_SHIFT			5
+#define MAX98506_INVALSLOT_STATUS_WIDTH			1
+#define MAX98506_SLOTCNFLT_STATUS_MASK			(1<<4)
+#define MAX98506_SLOTCNFLT_STATUS_SHIFT			4
+#define MAX98506_SLOTCNFLT_STATUS_WIDTH			1
+#define MAX98506_VBSTOVFL_STATUS_MASK			(1<<3)
+#define MAX98506_VBSTOVFL_STATUS_SHIFT			3
+#define MAX98506_VBSTOVFL_STATUS_WIDTH			1
+#define MAX98506_VBATOVFL_STATUS_MASK			(1<<2)
+#define MAX98506_VBATOVFL_STATUS_SHIFT			2
+#define MAX98506_VBATOVFL_STATUS_WIDTH			1
+#define MAX98506_IMONOVFL_STATUS_MASK			(1<<1)
+#define MAX98506_IMONOVFL_STATUS_SHIFT			1
+#define MAX98506_IMONOVFL_STATUS_WIDTH			1
+#define MAX98506_VMONOVFL_STATUS_MASK			(1<<0)
+#define MAX98506_VMONOVFL_STATUS_SHIFT			0
+#define MAX98506_VMONOVFL_STATUS_WIDTH			1
+
+/* MAX98506_R005_STATE0 */
+#define MAX98506_THERMWARN_END_STATE_MASK		(1<<3)
+#define MAX98506_THERMWARN_END_STATE_SHIFT		3
+#define MAX98506_THERMWARN_END_STATE_WIDTH		1
+#define MAX98506_THERMWARN_BGN_STATE_MASK		(1<<2)
+#define MAX98506_THERMWARN_BGN_STATE_SHIFT		1
+#define MAX98506_THERMWARN_BGN_STATE_WIDTH		1
+#define MAX98506_THERMSHDN_END_STATE_MASK		(1<<1)
+#define MAX98506_THERMSHDN_END_STATE_SHIFT		1
+#define MAX98506_THERMSHDN_END_STATE_WIDTH		1
+#define MAX98506_THERMSHDN_BGN_STATE_MASK		(1<<0)
+#define MAX98506_THERMSHDN_BGN_STATE_SHIFT		0
+#define MAX98506_THERMSHDN_BGN_STATE_WIDTH		1
+
+/* MAX98506_R006_STATE1 */
+#define MAX98506_SPRCURNT_STATE_MASK			(1<<5)
+#define MAX98506_SPRCURNT_STATE_SHIFT			5
+#define MAX98506_SPRCURNT_STATE_WIDTH			1
+#define MAX98506_WATCHFAIL_STATE_MASK			(1<<4)
+#define MAX98506_WATCHFAIL_STATE_SHIFT			4
+#define MAX98506_WATCHFAIL_STATE_WIDTH			1
+#define MAX98506_ALCINFH_STATE_MASK			(1<<3)
+#define MAX98506_ALCINFH_STATE_SHIFT			3
+#define MAX98506_ALCINFH_STATE_WIDTH			1
+#define MAX98506_ALCACT_STATE_MASK			(1<<2)
+#define MAX98506_ALCACT_STATE_SHIFT			2
+#define MAX98506_ALCACT_STATE_WIDTH			1
+#define MAX98506_ALCMUT_STATE_MASK			(1<<1)
+#define MAX98506_ALCMUT_STATE_SHIFT			1
+#define MAX98506_ALCMUT_STATE_WIDTH			1
+#define MAX98506_ALCP_STATE_MASK			(1<<0)
+#define MAX98506_ALCP_STATE_SHIFT			0
+#define MAX98506_ALCP_STATE_WIDTH			1
+
+/* MAX98506_R007_STATE2 */
+#define MAX98506_SLOTOVRN_STATE_MASK			(1<<6)
+#define MAX98506_SLOTOVRN_STATE_SHIFT			6
+#define MAX98506_SLOTOVRN_STATE_WIDTH			1
+#define MAX98506_INVALSLOT_STATE_MASK			(1<<5)
+#define MAX98506_INVALSLOT_STATE_SHIFT			5
+#define MAX98506_INVALSLOT_STATE_WIDTH			1
+#define MAX98506_SLOTCNFLT_STATE_MASK			(1<<4)
+#define MAX98506_SLOTCNFLT_STATE_SHIFT			4
+#define MAX98506_SLOTCNFLT_STATE_WIDTH			1
+#define MAX98506_VBSTOVFL_STATE_MASK			(1<<3)
+#define MAX98506_VBSTOVFL_STATE_SHIFT			3
+#define MAX98506_VBSTOVFL_STATE_WIDTH			1
+#define MAX98506_VBATOVFL_STATE_MASK			(1<<2)
+#define MAX98506_VBATOVFL_STATE_SHIFT			2
+#define MAX98506_VBATOVFL_STATE_WIDTH			1
+#define MAX98506_IMONOVFL_STATE_MASK			(1<<1)
+#define MAX98506_IMONOVFL_STATE_SHIFT			1
+#define MAX98506_IMONOVFL_STATE_WIDTH			1
+#define MAX98506_VMONOVFL_STATE_MASK			(1<<0)
+#define MAX98506_VMONOVFL_STATE_SHIFT			0
+#define MAX98506_VMONOVFL_STATE_WIDTH			1
+
+/* MAX98506_R008_FLAG0 */
+#define MAX98506_THERMWARN_END_FLAG_MASK		(1<<3)
+#define MAX98506_THERMWARN_END_FLAG_SHIFT		3
+#define MAX98506_THERMWARN_END_FLAG_WIDTH		1
+#define MAX98506_THERMWARN_BGN_FLAG_MASK		(1<<2)
+#define MAX98506_THERMWARN_BGN_FLAG_SHIFT		2
+#define MAX98506_THERMWARN_BGN_FLAG_WIDTH		1
+#define MAX98506_THERMSHDN_END_FLAG_MASK		(1<<1)
+#define MAX98506_THERMSHDN_END_FLAG_SHIFT		1
+#define MAX98506_THERMSHDN_END_FLAG_WIDTH		1
+#define MAX98506_THERMSHDN_BGN_FLAG_MASK		(1<<0)
+#define MAX98506_THERMSHDN_BGN_FLAG_SHIFT		0
+#define MAX98506_THERMSHDN_BGN_FLAG_WIDTH		1
+
+/* MAX98506_R009_FLAG1 */
+#define MAX98506_SPKCURNT_FLAG_MASK			(1<<5)
+#define MAX98506_SPKCURNT_FLAG_SHIFT			5
+#define MAX98506_SPKCURNT_FLAG_WIDTH			1
+#define MAX98506_WATCHFAIL_FLAG_MASK			(1<<4)
+#define MAX98506_WATCHFAIL_FLAG_SHIFT			4
+#define MAX98506_WATCHFAIL_FLAG_WIDTH			1
+#define MAX98506_ALCINFH_FLAG_MASK			(1<<3)
+#define MAX98506_ALCINFH_FLAG_SHIFT			3
+#define MAX98506_ALCINFH_FLAG_WIDTH			1
+#define MAX98506_ALCACT_FLAG_MASK			(1<<2)
+#define MAX98506_ALCACT_FLAG_SHIFT			2
+#define MAX98506_ALCACT_FLAG_WIDTH			1
+#define MAX98506_ALCMUT_FLAG_MASK			(1<<1)
+#define MAX98506_ALCMUT_FLAG_SHIFT			1
+#define MAX98506_ALCMUT_FLAG_WIDTH			1
+#define MAX98506_ALCP_FLAG_MASK				(1<<0)
+#define MAX98506_ALCP_FLAG_SHIFT			0
+#define MAX98506_ALCP_FLAG_WIDTH			1
+
+/* MAX98506_R00A_FLAG2 */
+#define MAX98506_SLOTOVRN_FLAG_MASK			(1<<6)
+#define MAX98506_SLOTOVRN_FLAG_SHIFT			6
+#define MAX98506_SLOTOVRN_FLAG_WIDTH			1
+#define MAX98506_INVALSLOT_FLAG_MASK			(1<<5)
+#define MAX98506_INVALSLOT_FLAG_SHIFT			5
+#define MAX98506_INVALSLOT_FLAG_WIDTH			1
+#define MAX98506_SLOTCNFLT_FLAG_MASK			(1<<4)
+#define MAX98506_SLOTCNFLT_FLAG_SHIFT			4
+#define MAX98506_SLOTCNFLT_FLAG_WIDTH			1
+#define MAX98506_VBSTOVFL_FLAG_MASK			(1<<3)
+#define MAX98506_VBSTOVFL_FLAG_SHIFT			3
+#define MAX98506_VBSTOVFL_FLAG_WIDTH			1
+#define MAX98506_VBATOVFL_FLAG_MASK			(1<<2)
+#define MAX98506_VBATOVFL_FLAG_SHIFT			2
+#define MAX98506_VBATOVFL_FLAG_WIDTH			1
+#define MAX98506_IMONOVFL_FLAG_MASK			(1<<1)
+#define MAX98506_IMONOVFL_FLAG_SHIFT			1
+#define MAX98506_IMONOVFL_FLAG_WIDTH			1
+#define MAX98506_VMONOVFL_FLAG_MASK			(1<<0)
+#define MAX98506_VMONOVFL_FLAG_SHIFT			0
+#define MAX98506_VMONOVFL_FLAG_WIDTH			1
+
+/* MAX98506_R00B_IRQ_ENABLE0 */
+#define MAX98506_THERMWARN_END_EN_MASK			(1<<3)
+#define MAX98506_THERMWARN_END_EN_SHIFT			3
+#define MAX98506_THERMWARN_END_EN_WIDTH			1
+#define MAX98506_THERMWARN_BGN_EN_MASK			(1<<2)
+#define MAX98506_THERMWARN_BGN_EN_SHIFT			2
+#define MAX98506_THERMWARN_BGN_EN_WIDTH			1
+#define MAX98506_THERMSHDN_END_EN_MASK			(1<<1)
+#define MAX98506_THERMSHDN_END_EN_SHIFT			1
+#define MAX98506_THERMSHDN_END_EN_WIDTH			1
+#define MAX98506_THERMSHDN_BGN_EN_MASK			(1<<0)
+#define MAX98506_THERMSHDN_BGN_EN_SHIFT			0
+#define MAX98506_THERMSHDN_BGN_EN_WIDTH			1
+
+/* MAX98506_R00C_IRQ_ENABLE1 */
+#define MAX98506_SPKCURNT_EN_MASK			(1<<5)
+#define MAX98506_SPKCURNT_EN_SHIFT			5
+#define MAX98506_SPKCURNT_EN_WIDTH			1
+#define MAX98506_WATCHFAIL_EN_MASK			(1<<4)
+#define MAX98506_WATCHFAIL_EN_SHIFT			4
+#define MAX98506_WATCHFAIL_EN_WIDTH			1
+#define MAX98506_ALCINFH_EN_MASK			(1<<3)
+#define MAX98506_ALCINFH_EN_SHIFT			3
+#define MAX98506_ALCINFH_EN_WIDTH			1
+#define MAX98506_ALCACT_EN_MASK				(1<<2)
+#define MAX98506_ALCACT_EN_SHIFT			2
+#define MAX98506_ALCACT_EN_WIDTH			1
+#define MAX98506_ALCMUT_EN_MASK				(1<<1)
+#define MAX98506_ALCMUT_EN_SHIFT			1
+#define MAX98506_ALCMUT_EN_WIDTH			1
+#define MAX98506_ALCP_EN_MASK				(1<<0)
+#define MAX98506_ALCP_EN_SHIFT				0
+#define MAX98506_ALCP_EN_WIDTH				1
+
+/* MAX98506_R00D_IRQ_ENABLE2 */
+#define MAX98506_SLOTOVRN_EN_MASK			(1<<6)
+#define MAX98506_SLOTOVRN_EN_SHIFT			6
+#define MAX98506_SLOTOVRN_EN_WIDTH			1
+#define MAX98506_INVALSLOT_EN_MASK			(1<<5)
+#define MAX98506_INVALSLOT_EN_SHIFT			5
+#define MAX98506_INVALSLOT_EN_WIDTH			1
+#define MAX98506_SLOTCNFLT_EN_MASK			(1<<4)
+#define MAX98506_SLOTCNFLT_EN_SHIFT			4
+#define MAX98506_SLOTCNFLT_EN_WIDTH			1
+#define MAX98506_VBSTOVFL_EN_MASK			(1<<3)
+#define MAX98506_VBSTOVFL_EN_SHIFT			3
+#define MAX98506_VBSTOVFL_EN_WIDTH			1
+#define MAX98506_VBATOVFL_EN_MASK			(1<<2)
+#define MAX98506_VBATOVFL_EN_SHIFT			2
+#define MAX98506_VBATOVFL_EN_WIDTH			1
+#define MAX98506_IMONOVFL_EN_MASK			(1<<1)
+#define MAX98506_IMONOVFL_EN_SHIFT			1
+#define MAX98506_IMONOVFL_EN_WIDTH			1
+#define MAX98506_VMONOVFL_EN_MASK			(1<<0)
+#define MAX98506_VMONOVFL_EN_SHIFT			0
+#define MAX98506_VMONOVFL_EN_WIDTH			1
+
+/* MAX98506_R00E_IRQ_CLEAR0 */
+#define MAX98506_THERMWARN_END_CLR_MASK			(1<<3)
+#define MAX98506_THERMWARN_END_CLR_SHIFT		3
+#define MAX98506_THERMWARN_END_CLR_WIDTH		1
+#define MAX98506_THERMWARN_BGN_CLR_MASK			(1<<2)
+#define MAX98506_THERMWARN_BGN_CLR_SHIFT		2
+#define MAX98506_THERMWARN_BGN_CLR_WIDTH		1
+#define MAX98506_THERMSHDN_END_CLR_MASK			(1<<1)
+#define MAX98506_THERMSHDN_END_CLR_SHIFT		1
+#define MAX98506_THERMSHDN_END_CLR_WIDTH		1
+#define MAX98506_THERMSHDN_BGN_CLR_MASK			(1<<0)
+#define MAX98506_THERMSHDN_BGN_CLR_SHIFT		0
+#define MAX98506_THERMSHDN_BGN_CLR_WIDTH		1
+
+/* MAX98506_R00F_IRQ_CLEAR1 */
+#define MAX98506_SPKCURNT_CLR_MASK			(1<<5)
+#define MAX98506_SPKCURNT_CLR_SHIFT			5
+#define MAX98506_SPKCURNT_CLR_WIDTH			1
+#define MAX98506_WATCHFAIL_CLR_MASK			(1<<4)
+#define MAX98506_WATCHFAIL_CLR_SHIFT			4
+#define MAX98506_WATCHFAIL_CLR_WIDTH			1
+#define MAX98506_ALCINFH_CLR_MASK			(1<<3)
+#define MAX98506_ALCINFH_CLR_SHIFT			3
+#define MAX98506_ALCINFH_CLR_WIDTH			1
+#define MAX98506_ALCACT_CLR_MASK			(1<<2)
+#define MAX98506_ALCACT_CLR_SHIFT			2
+#define MAX98506_ALCACT_CLR_WIDTH			1
+#define MAX98506_ALCMUT_CLR_MASK			(1<<1)
+#define MAX98506_ALCMUT_CLR_SHIFT			1
+#define MAX98506_ALCMUT_CLR_WIDTH			1
+#define MAX98506_ALCP_CLR_MASK				(1<<0)
+#define MAX98506_ALCP_CLR_SHIFT				0
+#define MAX98506_ALCP_CLR_WIDTH				1
+
+/* MAX98506_R010_IRQ_CLEAR2 */
+#define MAX98506_SLOTOVRN_CLR_MASK			(1<<6)
+#define MAX98506_SLOTOVRN_CLR_SHIFT			6
+#define MAX98506_SLOTOVRN_CLR_WIDTH			1
+#define MAX98506_INVALSLOT_CLR_MASK			(1<<5)
+#define MAX98506_INVALSLOT_CLR_SHIFT			5
+#define MAX98506_INVALSLOT_CLR_WIDTH			1
+#define MAX98506_SLOTCNFLT_CLR_MASK			(1<<4)
+#define MAX98506_SLOTCNFLT_CLR_SHIFT			4
+#define MAX98506_SLOTCNFLT_CLR_WIDTH			1
+#define MAX98506_VBSTOVFL_CLR_MASK			(1<<3)
+#define MAX98506_VBSTOVFL_CLR_SHIFT			3
+#define MAX98506_VBSTOVFL_CLR_WIDTH			1
+#define MAX98506_VBATOVFL_CLR_MASK			(1<<2)
+#define MAX98506_VBATOVFL_CLR_SHIFT			2
+#define MAX98506_VBATOVFL_CLR_WIDTH			1
+#define MAX98506_IMONOVFL_CLR_MASK			(1<<1)
+#define MAX98506_IMONOVFL_CLR_SHIFT			1
+#define MAX98506_IMONOVFL_CLR_WIDTH			1
+#define MAX98506_VMONOVFL_CLR_MASK			(1<<0)
+#define MAX98506_VMONOVFL_CLR_SHIFT			0
+#define MAX98506_VMONOVFL_CLR_WIDTH			1
+
+/* MAX98506_R01A_DAI_CLK_MODE1 */
+#define MAX98506_DAI_CLK_SOURCE_MASK			(1<<6)
+#define MAX98506_DAI_CLK_SOURCE_SHIFT			6
+#define MAX98506_DAI_CLK_SOURCE_WIDTH			1
+#define MAX98506_MDLL_MULT_MASK				(0x0F<<0)
+#define MAX98506_MDLL_MULT_SHIFT			0
+#define MAX98506_MDLL_MULT_WIDTH			4
+#define MAX98506_MDLL_MULT_MCLKx8			6
+#define MAX98506_MDLL_MULT_MCLKx16			8
+
+/* MAX98506_R01B_DAI_CLK_MODE2 */
+#define MAX98506_DAI_SR_MASK				(0x0F<<4)
+#define MAX98506_DAI_SR_SHIFT				4
+#define MAX98506_DAI_SR_WIDTH				4
+#define MAX98506_DAI_MAS_MASK				(1<<3)
+#define MAX98506_DAI_MAS_SHIFT				3
+#define MAX98506_DAI_MAS_WIDTH				1
+#define MAX98506_DAI_BSEL_MASK				(0x07<<0)
+#define MAX98506_DAI_BSEL_SHIFT				0
+#define MAX98506_DAI_BSEL_WIDTH				3
+#define MAX98506_DAI_BSEL_32 	(0 << MAX98506_DAI_BSEL_SHIFT)
+#define MAX98506_DAI_BSEL_48 	(1 << MAX98506_DAI_BSEL_SHIFT)
+#define MAX98506_DAI_BSEL_64 	(2 << MAX98506_DAI_BSEL_SHIFT)
+#define MAX98506_DAI_BSEL_256 	(6 << MAX98506_DAI_BSEL_SHIFT)
+
+/* MAX98506_R01F_DAI_CLK_DIV_N_LSBS */
+#define MAX98506_DAI_N_LSBS_MASK			(0xFF<<0)
+#define MAX98506_DAI_N_LSBS_SHIFT			0
+#define MAX98506_DAI_N_LSBS_WIDTH			8
+
+/* MAX98506_R020_FORMAT */
+#define MAX98506_DAI_CHANSZ_MASK			(0x03<<6)
+#define MAX98506_DAI_CHANSZ_SHIFT			6
+#define MAX98506_DAI_CHANSZ_WIDTH			2
+#define MAX98506_DAI_EXTBCLK_HIZ_MASK			(1<<4)
+#define MAX98506_DAI_EXTBCLK_HIZ_SHIFT			4
+#define MAX98506_DAI_EXTBCLK_HIZ_WIDTH			1
+#define MAX98506_DAI_WCI_MASK				(1<<3)
+#define MAX98506_DAI_WCI_SHIFT				3
+#define MAX98506_DAI_WCI_WIDTH				1
+#define MAX98506_DAI_BCI_MASK				(1<<2)
+#define MAX98506_DAI_BCI_SHIFT				2
+#define MAX98506_DAI_BCI_WIDTH				1
+#define MAX98506_DAI_DLY_MASK				(1<<1)
+#define MAX98506_DAI_DLY_SHIFT				1
+#define MAX98506_DAI_DLY_WIDTH				1
+#define MAX98506_DAI_TDM_MASK				(1<<0)
+#define MAX98506_DAI_TDM_SHIFT				0
+#define MAX98506_DAI_TDM_WIDTH				1
+#define MAX98506_DAI_CHANSZ_16	(1 << MAX98506_DAI_CHANSZ_SHIFT)
+#define MAX98506_DAI_CHANSZ_24	(2 << MAX98506_DAI_CHANSZ_SHIFT)
+#define MAX98506_DAI_CHANSZ_32	(3 << MAX98506_DAI_CHANSZ_SHIFT)
+
+/* MAX98506_R021_TDM_SLOT_SELECT */
+#define MAX98506_DAI_DO_EN_MASK				(1<<7)
+#define MAX98506_DAI_DO_EN_SHIFT			7
+#define MAX98506_DAI_DO_EN_WIDTH			1
+#define MAX98506_DAI_DIN_EN_MASK			(1<<6)
+#define MAX98506_DAI_DIN_EN_SHIFT			6
+#define MAX98506_DAI_DIN_EN_WIDTH			1
+#define MAX98506_DAI_INR_SOURCE_MASK			(0x07<<3)
+#define MAX98506_DAI_INR_SOURCE_SHIFT			3
+#define MAX98506_DAI_INR_SOURCE_WIDTH			3
+#define MAX98506_DAI_INL_SOURCE_MASK			(0x07<<0)
+#define MAX98506_DAI_INL_SOURCE_SHIFT			0
+#define MAX98506_DAI_INL_SOURCE_WIDTH			3
+
+/* MAX98506_R022_DOUT_CFG_VMON */
+#define MAX98506_DAI_VMON_EN_MASK			(1<<5)
+#define MAX98506_DAI_VMON_EN_SHIFT			5
+#define MAX98506_DAI_VMON_EN_WIDTH			1
+#define MAX98506_DAI_VMON_SLOT_MASK			(0x1F<<0)
+#define MAX98506_DAI_VMON_SLOT_SHIFT			0
+#define MAX98506_DAI_VMON_SLOT_WIDTH			5
+#define MAX98506_DAI_VMON_SLOT_00_01 (0 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_01_02 (1 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_02_03 (2 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_03_04 (3 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_04_05 (4 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_05_06 (5 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_06_07 (6 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_07_08 (7 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_08_09 (8 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_09_0A (9 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_0A_0B (10 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_0B_0C (11 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_0C_0D (12 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_0D_0E (13 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_0E_0F (14 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_0F_10 (15 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_10_11 (16 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_11_12 (17 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_12_13 (18 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_13_14 (19 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_14_15 (20 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_15_16 (21 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_16_17 (22 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_17_18 (23 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_18_19 (24 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_19_1A (25 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_1A_1B (26 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_1B_1C (27 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_1C_1D (28 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_1D_1E (29 << MAX98506_DAI_VMON_SLOT_SHIFT)
+#define MAX98506_DAI_VMON_SLOT_1E_1F (30 << MAX98506_DAI_VMON_SLOT_SHIFT)
+
+/* MAX98506_R023_DOUT_CFG_IMON */
+#define MAX98506_DAI_IMON_EN_MASK			(1<<5)
+#define MAX98506_DAI_IMON_EN_SHIFT			5
+#define MAX98506_DAI_IMON_EN_WIDTH			1
+#define MAX98506_DAI_IMON_SLOT_MASK			(0x1F<<0)
+#define MAX98506_DAI_IMON_SLOT_SHIFT			0
+#define MAX98506_DAI_IMON_SLOT_WIDTH			5
+#define MAX98506_DAI_IMON_SLOT_00_01 (0 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_01_02 (1 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_02_03 (2 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_03_04 (3 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_04_05 (4 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_05_06 (5 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_06_07 (6 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_07_08 (7 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_08_09 (8 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_09_0A (9 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_0A_0B (10 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_0B_0C (11 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_0C_0D (12 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_0D_0E (13 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_0E_0F (14 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_0F_10 (15 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_10_11 (16 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_11_12 (17 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_12_13 (18 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_13_14 (19 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_14_15 (20 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_15_16 (21 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_16_17 (22 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_17_18 (23 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_18_19 (24 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_19_1A (25 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_1A_1B (26 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_1B_1C (27 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_1C_1D (28 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_1D_1E (29 << MAX98506_DAI_IMON_SLOT_SHIFT)
+#define MAX98506_DAI_IMON_SLOT_1E_1F (30 << MAX98506_DAI_IMON_SLOT_SHIFT)
+
+/* MAX98506_R024_DOUT_CFG_VBAT */
+#define MAX98506_DAI_VBAT_EN_MASK			(1<<5)
+#define MAX98506_DAI_VBAT_EN_SHIFT			5
+#define MAX98506_DAI_VBAT_EN_WIDTH			1
+#define MAX98506_DAI_VBAT_SLOT_MASK			(0x1F<<0)
+#define MAX98506_DAI_VBAT_SLOT_SHIFT			0
+#define MAX98506_DAI_VBAT_SLOT_WIDTH			5
+
+/* MAX98506_R025_DOUT_CFG_VBST */
+#define MAX98506_DAI_VBST_EN_MASK			(1<<5)
+#define MAX98506_DAI_VBST_EN_SHIFT			5
+#define MAX98506_DAI_VBST_EN_WIDTH			1
+#define MAX98506_DAI_VBST_SLOT_MASK			(0x1F<<0)
+#define MAX98506_DAI_VBST_SLOT_SHIFT			0
+#define MAX98506_DAI_VBST_SLOT_WIDTH			5
+
+/* MAX98506_R026_DOUT_CFG_FLAG */
+#define MAX98506_DAI_FLAG_EN_MASK			(1<<5)
+#define MAX98506_DAI_FLAG_EN_SHIFT			5
+#define MAX98506_DAI_FLAG_EN_WIDTH			1
+#define MAX98506_DAI_FLAG_SLOT_MASK			(0x1F<<0)
+#define MAX98506_DAI_FLAG_SLOT_SHIFT			0
+#define MAX98506_DAI_FLAG_SLOT_WIDTH			5
+
+/* MAX98506_R027_DOUT_HIZ_CFG1 */
+#define MAX98506_DAI_SLOT_HIZ_CFG1_MASK			(0xFF<<0)
+#define MAX98506_DAI_SLOT_HIZ_CFG1_SHIFT		0
+#define MAX98506_DAI_SLOT_HIZ_CFG1_WIDTH		8
+
+/* MAX98506_R028_DOUT_HIZ_CFG2 */
+#define MAX98506_DAI_SLOT_HIZ_CFG2_MASK			(0xFF<<0)
+#define MAX98506_DAI_SLOT_HIZ_CFG2_SHIFT		0
+#define MAX98506_DAI_SLOT_HIZ_CFG2_WIDTH		8
+
+/* MAX98506_R029_DOUT_HIZ_CFG3 */
+#define MAX98506_DAI_SLOT_HIZ_CFG3_MASK			(0xFF<<0)
+#define MAX98506_DAI_SLOT_HIZ_CFG3_SHIFT		0
+#define MAX98506_DAI_SLOT_HIZ_CFG3_WIDTH		8
+
+/* MAX98506_R02A_DOUT_HIZ_CFG4 */
+#define MAX98506_DAI_SLOT_HIZ_CFG4_MASK			(0xFF<<0)
+#define MAX98506_DAI_SLOT_HIZ_CFG4_SHIFT		0
+#define MAX98506_DAI_SLOT_HIZ_CFG4_WIDTH		8
+
+/* MAX98506_R02B_DOUT_DRV_STRENGTH */
+#define MAX98506_DAI_OUT_DRIVE_MASK			(0x03<<0)
+#define MAX98506_DAI_OUT_DRIVE_SHIFT			0
+#define MAX98506_DAI_OUT_DRIVE_WIDTH			2
+
+/* MAX98506_R02C_FILTERS */
+#define MAX98506_ADC_DITHER_EN_MASK			(1<<7)
+#define MAX98506_ADC_DITHER_EN_SHIFT			7
+#define MAX98506_ADC_DITHER_EN_WIDTH			1
+#define MAX98506_IV_DCB_EN_MASK				(1<<6)
+#define MAX98506_IV_DCB_EN_SHIFT			6
+#define MAX98506_IV_DCB_EN_WIDTH			1
+#define MAX98506_DAC_DITHER_EN_MASK			(1<<4)
+#define MAX98506_DAC_DITHER_EN_SHIFT			4
+#define MAX98506_DAC_DITHER_EN_WIDTH			1
+#define MAX98506_DAC_FILTER_MODE_MASK			(1<<3)
+#define MAX98506_DAC_FILTER_MODE_SHIFT			3
+#define MAX98506_DAC_FILTER_MODE_WIDTH			1
+#define MAX98506_DAC_HPF_MASK				(0x07<<0)
+#define MAX98506_DAC_HPF_SHIFT				0
+#define MAX98506_DAC_HPF_WIDTH				3
+
+/* MAX98506_R02D_GAIN */
+#define MAX98506_DAC_IN_SEL_MASK			(0x03<<5)
+#define MAX98506_DAC_IN_SEL_SHIFT			5
+#define MAX98506_DAC_IN_SEL_WIDTH			2
+#define MAX98506_SPK_GAIN_MASK				(0x1F<<0)
+#define MAX98506_SPK_GAIN_SHIFT				0
+#define MAX98506_SPK_GAIN_WIDTH				5
+#define MAX98506_DAC_IN_SEL_LEFT_DAI 		(0 << MAX98506_DAC_IN_SEL_SHIFT)
+#define MAX98506_DAC_IN_SEL_RIGHT_DAI 		(1 << MAX98506_DAC_IN_SEL_SHIFT)
+#define MAX98506_DAC_IN_SEL_SUMMED_DAI 		(2 << MAX98506_DAC_IN_SEL_SHIFT)
+#define MAX98506_DAC_IN_SEL_DIV2_SUMMED_DAI 	(3 << MAX98506_DAC_IN_SEL_SHIFT)
+
+/* MAX98506_R02E_GAIN_RAMPING */
+#define MAX98506_SPK_RMP_EN_MASK			(1<<1)
+#define MAX98506_SPK_RMP_EN_SHIFT			1
+#define MAX98506_SPK_RMP_EN_WIDTH			1
+#define MAX98506_SPK_ZCD_EN_MASK			(1<<0)
+#define MAX98506_SPK_ZCD_EN_SHIFT			0
+#define MAX98506_SPK_ZCD_EN_WIDTH			1
+
+/* MAX98506_R02F_SPK_AMP */
+#define MAX98506_SPK_MODE_MASK				(1<<0)
+#define MAX98506_SPK_MODE_SHIFT				0
+#define MAX98506_SPK_MODE_WIDTH				1
+
+/* MAX98506_R030_THRESHOLD */
+#define MAX98506_ALC_EN_MASK				(1<<5)
+#define MAX98506_ALC_EN_SHIFT				5
+#define MAX98506_ALC_EN_WIDTH				1
+#define MAX98506_ALC_TH_MASK				(0x1F<<0)
+#define MAX98506_ALC_TH_SHIFT				0
+#define MAX98506_ALC_TH_WIDTH				5
+
+/* MAX98506_R031_ALC_ATTACK */
+#define MAX98506_ALC_ATK_STEP_MASK			(0x0F<<4)
+#define MAX98506_ALC_ATK_STEP_SHIFT			4
+#define MAX98506_ALC_ATK_STEP_WIDTH			4
+#define MAX98506_ALC_ATK_RATE_MASK			(0x7<<0)
+#define MAX98506_ALC_ATK_RATE_SHIFT			0
+#define MAX98506_ALC_ATK_RATE_WIDTH			3
+
+/* MAX98506_R032_ALC_ATTEN_RLS */
+#define MAX98506_ALC_MAX_ATTEN_MASK			(0x0F<<4)
+#define MAX98506_ALC_MAX_ATTEN_SHIFT			4
+#define MAX98506_ALC_MAX_ATTEN_WIDTH			4
+#define MAX98506_ALC_RLS_RATE_MASK			(0x7<<0)
+#define MAX98506_ALC_RLS_RATE_SHIFT			0
+#define MAX98506_ALC_RLS_RATE_WIDTH			3
+
+/* MAX98506_R033_ALC_HOLD_RLS */
+#define MAX98506_ALC_RLS_TGR_MASK			(1<<0)
+#define MAX98506_ALC_RLS_TGR_SHIFT			0
+#define MAX98506_ALC_RLS_TGR_WIDTH			1
+
+/* MAX98506_R034_ALC_CONFIGURATION */
+#define MAX98506_ALC_MUTE_EN_MASK			(1<<7)
+#define MAX98506_ALC_MUTE_EN_SHIFT			7
+#define MAX98506_ALC_MUTE_EN_WIDTH			1
+#define MAX98506_ALC_MUTE_DLY_MASK			(0x07<<4)
+#define MAX98506_ALC_MUTE_DLY_SHIFT			4
+#define MAX98506_ALC_MUTE_DLY_WIDTH			3
+#define MAX98506_ALC_RLS_DBT_MASK			(0x07<<0)
+#define MAX98506_ALC_RLS_DBT_SHIFT			0
+#define MAX98506_ALC_RLS_DBT_WIDTH			3
+
+/* MAX98506_R035_BOOST_CONVERTER */
+#define MAX98506_BST_SYNC_MASK				(1<<7)
+#define MAX98506_BST_SYNC_SHIFT				7
+#define MAX98506_BST_SYNC_WIDTH				1
+#define MAX98506_BST_PHASE_MASK				(0x03<<4)
+#define MAX98506_BST_PHASE_SHIFT			4
+#define MAX98506_BST_PHASE_WIDTH			2
+#define MAX98506_BST_SKIP_MODE_MASK			(0x03<<0)
+#define MAX98506_BST_SKIP_MODE_SHIFT			0
+#define MAX98506_BST_SKIP_MODE_WIDTH			2
+
+/* MAX98506_R036_BLOCK_ENABLE */
+#define MAX98506_BST_EN_MASK				(1<<7)
+#define MAX98506_BST_EN_SHIFT				7
+#define MAX98506_BST_EN_WIDTH				1
+#define MAX98506_WATCH_EN_MASK				(1<<6)
+#define MAX98506_WATCH_EN_SHIFT				6
+#define MAX98506_WATCH_EN_WIDTH				1
+#define MAX98506_CLKMON_EN_MASK				(1<<5)
+#define MAX98506_CLKMON_EN_SHIFT			5
+#define MAX98506_CLKMON_EN_WIDTH			1
+#define MAX98506_SPK_EN_MASK				(1<<4)
+#define MAX98506_SPK_EN_SHIFT				4
+#define MAX98506_SPK_EN_WIDTH				1
+#define MAX98506_ADC_VBST_EN_MASK			(1<<3)
+#define MAX98506_ADC_VBST_EN_SHIFT			3
+#define MAX98506_ADC_VBST_EN_WIDTH			1
+#define MAX98506_ADC_VBAT_EN_MASK			(1<<2)
+#define MAX98506_ADC_VBAT_EN_SHIFT			2
+#define MAX98506_ADC_VBAT_EN_WIDTH			1
+#define MAX98506_ADC_IMON_EN_MASK			(1<<1)
+#define MAX98506_ADC_IMON_EN_SHIFT			1
+#define MAX98506_ADC_IMON_EN_WIDTH			1
+#define MAX98506_ADC_VMON_EN_MASK			(1<<0)
+#define MAX98506_ADC_VMON_EN_SHIFT			0
+#define MAX98506_ADC_VMON_EN_WIDTH			1
+#define MAX98506_ADC_VIMON_EN_MASK			(3<<0)
+#define MAX98506_ADC_VIMON_EN_SHIFT			0
+#define MAX98506_ADC_VIMON_EN_WIDTH			2
+
+/* MAX98506_R037_CONFIGURATION */
+#define MAX98506_BST_VOUT_MASK					(0x0F<<4)
+#define MAX98506_BST_VOUT_SHIFT					4
+#define MAX98506_BST_VOUT_WIDTH					4
+#define MAX98506_THERMWARN_LEVEL_MASK			(0x03<<2)
+#define MAX98506_THERMWARN_LEVEL_SHIFT			2
+#define MAX98506_THERMWARN_LEVEL_WIDTH			2
+#define MAX98506_WATCH_TIME_MASK				(0x03<<0)
+#define MAX98506_WATCH_TIME_SHIFT				0
+#define MAX98506_WATCH_TIME_WIDTH				2
+
+/* MAX98506_R038_GLOBAL_ENABLE */
+#define MAX98506_EN_MASK						(1<<7)
+#define MAX98506_EN_SHIFT						7
+#define MAX98506_EN_WIDTH						1
+
+/* MAX98506_R03A_BOOST_LIMITER */
+#define MAX98506_BST_ILIM_MASK					(0x1F<<3)
+#define MAX98506_BST_ILIM_SHIFT					3
+#define MAX98506_BST_ILIM_WIDTH					5
+
+/* MAX98506_R0FF_VERSION */
+#define MAX98506_REV_ID_MASK					(0xFF<<0)
+#define MAX98506_REV_ID_SHIFT					0
+#define MAX98506_REV_ID_WIDTH					8
+
+enum max98506_type {
+	MAX98506,
+};
+
+struct max98506_priv {
+	struct regmap *regmap;
+	struct snd_soc_codec *codec;
+	struct max98506_pdata *pdata;
+	struct max98506_pc_active pca;
+	struct max98506_volume_step_info vstep;
+#ifdef USE_DSM_LOG
+	struct class *dev_log_class;
+	struct device *dev_log;
+#endif /* USE_DSM_LOG */
+};
+
+#endif /* _MAX98506_H */
diff -X dontdiff -Nuarb a/sound/soc/codecs/maxim_dsm.c b/sound/soc/codecs/maxim_dsm.c
--- a/sound/soc/codecs/maxim_dsm.c	2016-01-06 15:00:44.614590653 -0500
+++ b/sound/soc/codecs/maxim_dsm.c	2015-12-01 05:59:06.000000000 -0500
@@ -8,92 +8,1008 @@
 #include <sound/soc.h>
 #include <sound/tlv.h>
 #include <sound/maxim_dsm.h>
-#include <sound/q6afe.h>
+#ifdef CONFIG_COMPAT
+#include <linux/compat.h>
+#endif /* CONFIG_COMPAT */
+#if defined(CONFIG_SND_SOC_QDSP6V2) || defined(CONFIG_SND_SOC_QDSP6)
+#include <sound/q6afe-v2.h>
+#endif /* CONFIG_SND_SOC_QDSP6V2 || CONFIG_SND_SOC_QDSP6 */
+
+#define DEBUG_MAXIM_DSM
+#ifdef DEBUG_MAXIM_DSM
+#define dbg_maxdsm(format, args...)	\
+pr_info("[MAXIM_DSM] %s: " format "\n", __func__, ## args)
+#else
+#define dbg_maxdsm(format, args...)
+#endif /* DEBUG_MAXIM_DSM */
+
+static struct maxim_dsm maxdsm = {
+	.regmap = NULL,
+	.param_size = PARAM_DSM_3_5_MAX,
+	.platform_type = PLATFORM_TYPE_A,
+	.port_id = DSM_RX_PORT_ID,
+	.rx_mod_id = AFE_PARAM_ID_ENABLE_DSM_RX,
+	.tx_mod_id = AFE_PARAM_ID_ENABLE_DSM_TX,
+	.filter_set = DSM_ID_FILTER_GET_AFE_PARAMS,
+	.version = VERSION_3_5_A,
+	.registered = 0,
+	.update_cal = 0,
+	.ignore_mask =
+		MAXDSM_IGNORE_MASK_VOICE_COIL |
+		MAXDSM_IGNORE_MASK_AMBIENT_TEMP,
+};
+module_param_named(ignore_mask, maxdsm.ignore_mask, uint,
+		S_IRUSR | S_IWUSR | S_IRGRP | S_IROTH);
 
-static int param[PARAM_DSM_MAX];
+static struct param_set_data maxdsm_saved_params[] = {
+	{
+		.name = PARAM_FEATURE_SET,
+		.value = 0x1F,
+	},
+};
 
-static DEFINE_MUTEX(dsm_lock);
+static struct param_info g_pbi[(PARAM_A_DSM_4_0_MAX >> 1)] = {
+	{
+		.id = PARAM_A_VOICE_COIL_TEMP,
+		.addr = 0x2A004C,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_EXCURSION,
+		.addr = 0x2A004E,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RDC,
+		.addr = 0x2A0050,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_Q_LO,
+		.addr = 0x2A0052,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_Q_HI,
+		.addr = 0x2A0054,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_FRES_LO,
+		.addr = 0x2A0056,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_FRES_HI,
+		.addr = 0x2A0058,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_EXCUR_LIMIT,
+		.addr = 0x2A005A,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_VOICE_COIL,
+		.addr = 0x2A005C,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_THERMAL_LIMIT,
+		.addr = 0x2A005E,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RELEASE_TIME,
+		.addr = 0x2A0060,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ONOFF,
+		.addr = 0x2A0062,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STATIC_GAIN,
+		.addr = 0x2A0064,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LFX_GAIN,
+		.addr = 0x2A0066,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_PILOT_GAIN,
+		.addr = 0x2A0068,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_FEATURE_SET,
+		.addr = 0x2A006A,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_SMOOTH_VOLT,
+		.addr = 0x2A006C,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_HPF_CUTOFF,
+		.addr = 0x2A006E,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LEAD_R,
+		.addr = 0x2A0070,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RMS_SMOO_FAC,
+		.addr = 0x2A0072,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_CLIP_LIMIT,
+		.addr = 0x2A0074,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_THERMAL_COEF,
+		.addr = 0x2A0076,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_QSPK,
+		.addr = 0x2A0078,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_EXCUR_LOG_THRESH,
+		.addr = 0x2A007A,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_TEMP_LOG_THRESH,
+		.addr = 0x2A007C,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RES_FREQ,
+		.addr = 0x2A007E,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RES_FREQ_GUARD_BAND,
+		.addr = 0x2A0080,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_AMBIENT_TEMP,
+		.addr = 0x2A0182,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ADMITTANCE_A1,
+		.addr = 0x2A0184,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ADMITTANCE_A2,
+		.addr = 0x2A0186,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ADMITTANCE_B0,
+		.addr = 0x2A0188,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ADMITTANCE_B1,
+		.addr = 0x2A018A,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ADMITTANCE_B2,
+		.addr = 0x2A018C,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RTH1_HI,
+		.addr = 0x2A018E,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RTH1_LO,
+		.addr = 0x2A0190,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RTH2_HI,
+		.addr = 0x2A0192,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_RTH2_LO,
+		.addr = 0x2A0194,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_ATENGAIN_HI,
+		.addr = 0x2A0196,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_ATENGAIN_LO,
+		.addr = 0x2A0198,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_SPT_RAMP_DOWN_FRAMES,
+		.addr = 0x2A019A,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_SPT_THRESHOLD_HI,
+		.addr = 0x2A019C,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_SPT_THRESHOLD_LO,
+		.addr = 0x2A019E,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_T_HORIZON,
+		.addr = 0x2A01A0,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LFX_ADMITTANCE_A1,
+		.addr = 0x2A01A2,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LFX_ADMITTANCE_A2,
+		.addr = 0x2A01A4,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LFX_ADMITTANCE_B0,
+		.addr = 0x2A01A6,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LFX_ADMITTANCE_B1,
+		.addr = 0x2A01A8,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_LFX_ADMITTANCE_B2,
+		.addr = 0x2A01AA,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_ALGORITHM_X_MAX,
+		.addr = 0x2A01AC,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_TCTH1_HI,
+		.addr = 0x2A01AE,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_TCTH1_LO,
+		.addr = 0x2A01B0,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_TCTH2_HI,
+		.addr = 0x2A01B2,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_TCTH2_LO,
+		.addr = 0x2A01B4,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_ATTACK_HI,
+		.addr = 0x2A01B6,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_ATTACK_LO,
+		.addr = 0x2A01B8,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_RELEASE_HI,
+		.addr = 0x2A01BA,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_RELEASE_LO,
+		.addr = 0x2A01BC,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STL_SPK_FS,
+		.addr = 0x2A01BE,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_Q_GUARD_BAND_HI,
+		.addr = 0x2A01C0,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_Q_GUARD_BAND_LO,
+		.addr = 0x2A01C2,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_A1_HI,
+		.addr = 0x2A01C4,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_A1_LO,
+		.addr = 0x2A01C6,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_A2_HI,
+		.addr = 0x2A01C8,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_A2_LO,
+		.addr = 0x2A01CA,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_B0_HI,
+		.addr = 0x2A01CC,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_B0_LO,
+		.addr = 0x2A01CE,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_B1_HI,
+		.addr = 0x2A01D0,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_B1_LO,
+		.addr = 0x2A01D2,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_B2_HI,
+		.addr = 0x2A01D4,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_COEFFS_B2_LO,
+		.addr = 0x2A01D6,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_STIMPEDMODEL_FLAG,
+		.addr = 0x2A01D8,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_Q_NOTCH_HI,
+		.addr = 0x2A01DA,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+	{
+		.id = PARAM_A_Q_NOTCH_LO,
+		.addr = 0x2A01DC,
+		.size = 2,
+		.type = sizeof(uint32_t),
+		.val = 0,
+	},
+};
+
+static DEFINE_MUTEX(dsm_fs_lock);
+static DEFINE_MUTEX(dsm_dsp_lock);
 
 #ifdef USE_DSM_LOG
 static DEFINE_MUTEX(maxdsm_log_lock);
 
-static uint32_t exSeqCountTemp;
-static uint32_t exSeqCountExcur;
-static uint32_t newLogAvail;
+static uint32_t ex_seq_count_temp;
+static uint32_t ex_seq_count_excur;
+static uint32_t new_log_avail;
 
-int maxdsm_get_dump_status(void)
+static int maxdsm_log_present;
+static struct tm maxdsm_log_timestamp;
+static uint8_t maxdsm_byte_log_array[BEFORE_BUFSIZE];
+static uint32_t maxdsm_int_log_array[BEFORE_BUFSIZE];
+static uint8_t maxdsm_after_prob_byte_log_array[AFTER_BUFSIZE];
+static uint32_t maxdsm_after_prob_int_log_array[AFTER_BUFSIZE];
+
+static struct param_info g_lbi[MAX_LOG_BUFFER_POS] = {
+	{
+		.id = WRITE_PROTECT,
+		.addr = 0x2A0082,
+		.size = 2,
+	},
+	{
+		.id = LOG_AVAILABLE,
+		.addr = 0x2A0084,
+		.size = 2,
+		.type = sizeof(uint8_t),
+	},
+	{
+		.id = VERSION_INFO,
+		.addr = 0x2A0086,
+		.size = 2,
+		.type = sizeof(uint8_t),
+	},
+	{
+		.id = LAST_2_SEC_TEMP,
+		.addr = 0x2A0088,
+		.size = 20,
+		.type = sizeof(uint8_t),
+	},
+	{
+		.id = LAST_2_SEC_EXCUR,
+		.addr = 0x2A009C,
+		.size = 20,
+		.type = sizeof(uint8_t),
+	},
+	{
+		.id = RESERVED_1,
+		.addr = 0x2A00B0,
+		.size = 2,
+	},
+	{
+		.id = SEQUENCE_OF_TEMP,
+		.addr = 0x2A00B2,
+		.size = 2,
+		.type = sizeof(uint32_t),
+	},
+	{
+		.id = SEQUENCE_OF_EXCUR,
+		.addr = 0x2A00B4,
+		.size = 2,
+		.type = sizeof(uint32_t),
+	},
+	{
+		.id = LAST_2_SEC_RDC,
+		.addr = 0x2A00B6,
+		.size = 20,
+		.type = sizeof(uint32_t),
+	},
+	{
+		.id = LAST_2_SEC_FREQ,
+		.addr = 0x2A00CA,
+		.size = 20,
+		.type = sizeof(uint32_t),
+	},
+	{
+		.id = RESERVED_2,
+		.addr = 0x2A00DE,
+		.size = 2,
+	},
+	{
+		.id = RESERVED_3,
+		.addr = 0x2A00E0,
+		.size = 2,
+	},
+	{
+		.id = AFTER_2_SEC_TEMP_TEMP,
+		.addr = 0x2A00E2,
+		.size = 20,
+		.type = sizeof(uint8_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_EXCUR_TEMP,
+		.addr = 0x2A00F6,
+		.size = 20,
+		.type = sizeof(uint8_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_TEMP_EXCUR,
+		.addr = 0x2A010A,
+		.size = 20,
+		.type = sizeof(uint8_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_EXCUR_EXCUR,
+		.addr = 0x2A011E,
+		.size = 20,
+		.type = sizeof(uint8_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_RDC_TEMP,
+		.addr = 0x2A0132,
+		.size = 20,
+		.type = sizeof(uint32_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_FREQ_TEMP,
+		.addr = 0x2A0146,
+		.size = 20,
+		.type = sizeof(uint32_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_RDC_EXCUR,
+		.addr = 0x2A015A,
+		.size = 20,
+		.type = sizeof(uint32_t) * 2,
+	},
+	{
+		.id = AFTER_2_SEC_FREQ_EXCUR,
+		.addr = 0x2A016E,
+		.size = 20,
+		.type = sizeof(uint32_t) * 2,
+	},
+};
+#endif /* USE_DSM_LOG */
+
+#if !defined(CONFIG_SND_SOC_QDSP6V2) && !defined(CONFIG_SND_SOC_QDSP6)
+static inline int32_t dsm_open(void *data)
+{
+	return 0;
+}
+#endif /* !CONFIG_SND_SOC_QDSP6V2 && !CONFIG_SND_SOC_QDSP6 */
+
+static inline int32_t maxdsm_dsm_open(void *data)
 {
-	int ret = (newLogAvail&0x3);
-	newLogAvail &= 0x1;
+	int32_t ret;
+
+	if (maxdsm.ignore_mask == MAXDSM_IGNORE_MASK_ALL &&
+			maxdsm.filter_set == DSM_ID_FILTER_SET_AFE_CNTRLS)
+		return -EPERM;
+
+	mutex_lock(&dsm_dsp_lock);
+	ret = dsm_open(data);
+	mutex_unlock(&dsm_dsp_lock);
+
 	return ret;
 }
 
-void maxdsm_update_param(void)
+void maxdsm_set_regmap(struct regmap *regmap)
+{
+	maxdsm.regmap = regmap;
+	dbg_maxdsm("Regmap for maxdsm was set by 0x%p",
+			maxdsm.regmap);
+}
+EXPORT_SYMBOL_GPL(maxdsm_set_regmap);
+
+static int maxdsm_check_ignore_mask(uint32_t reg, uint32_t mask)
+{
+	int ret = 0;
+
+	if ((mask & MAXDSM_IGNORE_MASK_VOICE_COIL) &&
+			(reg == g_pbi[PARAM_A_VOICE_COIL >> 1].addr))
+		ret = -EPERM;
+	else if ((mask & MAXDSM_IGNORE_MASK_AMBIENT_TEMP) &&
+			(reg == g_pbi[PARAM_A_AMBIENT_TEMP >> 1].addr))
+		ret = -EPERM;
+	else if (mask & MAXDSM_IGNORE_MASK_ALL)
+		ret = -EPERM;
+
+	return ret;
+}
+
+static int maxdsm_regmap_read(unsigned int reg,
+		unsigned int *val)
+{
+	return maxdsm.regmap ?
+		regmap_read(maxdsm.regmap, reg, val) : -ENXIO;
+}
+
+static int maxdsm_regmap_write(unsigned int reg,
+		unsigned int val)
 {
-	uint32_t filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+	if (maxdsm_check_ignore_mask(reg, maxdsm.ignore_mask)) {
+		dbg_maxdsm("Ignored 0x%x register", reg);
+		return 0;
+	}
 
-	mutex_lock(&dsm_lock);
-	dsm_open(DSM_RX_PORT_ID, &filter_set, (u8 *) param);
-	if (param[PARAM_EXCUR_LIMIT] != 0 && param[PARAM_THERMAL_LIMIT] != 0)
-		newLogAvail |= 0x1;
-	mutex_unlock(&dsm_lock);
+	return maxdsm.regmap ?
+		regmap_write(maxdsm.regmap, reg, val) : -ENXIO;
 }
 
-static bool maxdsm_log_present;
-static struct tm maxdsm_log_timestamp;
-static uint8_t maxdsm_byteLogArray[BEFORE_BUFSIZE];
-static uint32_t maxdsm_intLogArray[BEFORE_BUFSIZE];
-static uint8_t maxdsm_afterProbByteLogArray[AFTER_BUFSIZE];
-static uint32_t maxdsm_afterProbIntLogArray[AFTER_BUFSIZE];
+static void maxdsm_read_all(void)
+{
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		{
+		int param_idx, pbi_idx = 0;
+		uint32_t data;
+
+		while (pbi_idx++ < (maxdsm.param_size >> 1)) {
+			param_idx = (pbi_idx - 1) << 1;
+			data = 0;
+			maxdsm_regmap_read(g_pbi[pbi_idx - 1].addr, &data);
+			maxdsm.param[param_idx] = data;
+			maxdsm.param[param_idx + 1] =
+				(1 << maxdsm.binfo[pbi_idx - 1]);
+			dbg_maxdsm("[%d,%d]: 0x%08x / 0x%08x (addr:0x%08x",
+					param_idx, param_idx + 1,
+					maxdsm.param[param_idx],
+					maxdsm.param[param_idx + 1],
+					g_pbi[pbi_idx - 1].addr);
+		}
+		break;
+		}
+	case PLATFORM_TYPE_B:
+		maxdsm.filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+		maxdsm_dsm_open(&maxdsm);
+		break;
+	}
+}
 
-void maxdsm_log_update(const void *byteLogArray, const void *intLogArray, \
-	const void *afterProbByteLogArray, const void *afterProbIntLogArray)
+static void maxdsm_write_all(void)
+{
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		{
+		int param_idx, pbi_idx = 0;
+
+		while (pbi_idx++ < (maxdsm.param_size >> 1)) {
+			param_idx = (pbi_idx - 1) << 1;
+			maxdsm_regmap_write(
+					g_pbi[pbi_idx - 1].addr,
+					maxdsm.param[param_idx]);
+			dbg_maxdsm("[%d,%d]: 0x%08x / 0x%08x (0x%08x)",
+					param_idx, param_idx + 1,
+					maxdsm.param[param_idx],
+					maxdsm.param[param_idx + 1],
+					g_pbi[pbi_idx - 1].addr);
+		}
+		break;
+		}
+	case PLATFORM_TYPE_B:
+		maxdsm.filter_set = DSM_ID_FILTER_SET_AFE_CNTRLS;
+		maxdsm_dsm_open(&maxdsm);
+		break;
+	}
+}
+
+static int maxdsm_read_wrapper(unsigned int reg,
+		unsigned int *val)
+{
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		maxdsm_regmap_read(reg, val);
+		break;
+	case PLATFORM_TYPE_B:
+		maxdsm_read_all();
+		*val = maxdsm.param[reg];
+		break;
+	}
+
+	return *val;
+}
+
+static int maxdsm_write_wrapper(unsigned int reg,
+		unsigned int val, unsigned int flag)
+{
+	int ret = -ENODATA;
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		maxdsm_regmap_write(reg, val);
+		maxdsm_regmap_read(reg, &ret);
+		break;
+	case PLATFORM_TYPE_B:
+		if (reg > maxdsm.param_size)
+			pr_err("%s: Unknown parameter index. %d\n",
+					__func__, reg);
+		else {
+			maxdsm.param[PARAM_WRITE_FLAG] = flag;
+			maxdsm.param[reg] = val;
+			maxdsm_write_all();
+			maxdsm_read_all();
+			ret = maxdsm.param[reg];
+		}
+		break;
+	}
+
+	return ret;
+}
+
+#ifdef USE_DSM_LOG
+void maxdsm_log_update(const void *byte_log_array,
+		const void *int_log_array,
+		const void *after_prob_byte_log_array,
+		const void *after_prob_int_log_array)
 {
 	struct timeval tv;
-	mutex_lock(&maxdsm_log_lock);
 
-	memcpy(maxdsm_byteLogArray, byteLogArray, sizeof(maxdsm_byteLogArray));
-	memcpy(maxdsm_intLogArray, intLogArray, sizeof(maxdsm_intLogArray));
+	mutex_lock(&maxdsm_log_lock);
 
-	memcpy(maxdsm_afterProbByteLogArray, afterProbByteLogArray, \
-		sizeof(maxdsm_afterProbByteLogArray));
-	memcpy(maxdsm_afterProbIntLogArray, afterProbIntLogArray, \
-		sizeof(maxdsm_afterProbIntLogArray));
+	memcpy(maxdsm_byte_log_array,
+			byte_log_array, sizeof(maxdsm_byte_log_array));
+	memcpy(maxdsm_int_log_array,
+			int_log_array, sizeof(maxdsm_int_log_array));
+
+	memcpy(maxdsm_after_prob_byte_log_array,
+			after_prob_byte_log_array,
+			sizeof(maxdsm_after_prob_byte_log_array));
+	memcpy(maxdsm_after_prob_int_log_array,
+			after_prob_int_log_array,
+			sizeof(maxdsm_after_prob_int_log_array));
 
 	do_gettimeofday(&tv);
 	time_to_tm(tv.tv_sec, 0, &maxdsm_log_timestamp);
 
-	maxdsm_log_present = true;
+	maxdsm_log_present = 1;
 
 	mutex_unlock(&maxdsm_log_lock);
 }
+EXPORT_SYMBOL_GPL(maxdsm_log_update);
 
-static void maxdsm_log_free(void **byteLogArray, void **intLogArray, \
-	void **afterbyteLogArray, void **afterintLogArray)
+void maxdsm_read_logbuf_reg(void)
 {
-	if (likely(*byteLogArray)) {
-		kfree(*byteLogArray);
-		*byteLogArray = NULL;
+	int idx;
+	int b_idx, i_idx;
+	int apb_idx, api_idx;
+	int loop;
+	uint32_t data;
+	struct timeval tv;
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_B:
+		return;
 	}
 
-	if (likely(*intLogArray)) {
-		kfree(*intLogArray);
-		*intLogArray = NULL;
+	mutex_lock(&maxdsm_log_lock);
+
+	/* If the following variables are not initialized,
+	* these can not have zero data on some linux platform.
+	*/
+	idx = b_idx = i_idx = apb_idx = api_idx = 0;
+
+	while (idx < MAX_LOG_BUFFER_POS) {
+		for (loop = 0; loop < g_lbi[idx].size; loop += 2) {
+			if (!g_lbi[idx].type)
+				continue;
+			maxdsm_regmap_read(g_lbi[idx].addr + loop, &data);
+			switch (g_lbi[idx].type) {
+			case sizeof(uint8_t):
+				maxdsm_byte_log_array[b_idx++] =
+					data & 0xFF;
+				break;
+			case sizeof(uint32_t):
+				maxdsm_int_log_array[i_idx++] =
+					data & 0xFFFFFFFF;
+				break;
+			case sizeof(uint8_t)*2:
+				maxdsm_after_prob_byte_log_array[apb_idx++] =
+					data & 0xFF;
+				break;
+			case sizeof(uint32_t)*2:
+				maxdsm_after_prob_int_log_array[api_idx++] =
+					data & 0xFFFFFFFF;
+				break;
+			}
+		}
+		idx++;
 	}
 
-	if (likely(*afterbyteLogArray)) {
-		kfree(*afterbyteLogArray);
-		*afterbyteLogArray = NULL;
+	do_gettimeofday(&tv);
+	time_to_tm(tv.tv_sec, 0, &maxdsm_log_timestamp);
+	maxdsm_log_present = 1;
+
+	mutex_unlock(&maxdsm_log_lock);
+}
+
+int maxdsm_get_dump_status(void)
+{
+	int ret = 0;
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		ret = maxdsm_regmap_read(g_lbi[LOG_AVAILABLE].addr,
+				&new_log_avail);
+		break;
 	}
 
-	if (likely(*afterintLogArray)) {
-		kfree(*afterintLogArray);
-		*afterintLogArray = NULL;
+	return !ret ? (new_log_avail & 0x03) : ret;
+}
+EXPORT_SYMBOL_GPL(maxdsm_get_dump_status);
+
+void maxdsm_update_param(void)
+{
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		maxdsm_regmap_write(g_lbi[WRITE_PROTECT].addr, 1);
+		maxdsm_read_logbuf_reg();
+		maxdsm_regmap_write(g_lbi[WRITE_PROTECT].addr, 0);
+		break;
+	case PLATFORM_TYPE_B:
+		maxdsm.filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+		maxdsm_dsm_open(&maxdsm);
+		if (maxdsm.param[PARAM_EXCUR_LIMIT] != 0
+				&& maxdsm.param[PARAM_THERMAL_LIMIT] != 0)
+			new_log_avail |= 0x1;
+		break;
 	}
 }
+EXPORT_SYMBOL_GPL(maxdsm_update_param);
 
-static int maxdsm_log_duplicate(void **byteLogArray, void **intLogArray, \
-	void **afterbyteLogArray, void **afterintLogArray)
+static void maxdsm_log_free(void **byte_log_array, void **int_log_array,
+		void **afterbyte_log_array, void **after_int_log_array)
+{
+	if (likely(*byte_log_array)) {
+		kfree(*byte_log_array);
+		*byte_log_array = NULL;
+	}
+
+	if (likely(*int_log_array)) {
+		kfree(*int_log_array);
+		*int_log_array = NULL;
+	}
+
+	if (likely(*afterbyte_log_array)) {
+		kfree(*afterbyte_log_array);
+		*afterbyte_log_array = NULL;
+	}
+
+	if (likely(*after_int_log_array)) {
+		kfree(*after_int_log_array);
+		*after_int_log_array = NULL;
+	}
+}
+
+static int maxdsm_log_duplicate(void **byte_log_array, void **int_log_array,
+		void **afterbyte_log_array, void **after_int_log_array)
 {
 	void *blog_buf = NULL, *ilog_buf = NULL;
 	void *after_blog_buf = NULL, *after_ilog_buf = NULL;
@@ -106,35 +1022,35 @@
 		goto abort;
 	}
 
-	blog_buf = kzalloc(sizeof(maxdsm_byteLogArray), GFP_KERNEL);
-	ilog_buf = kzalloc(sizeof(maxdsm_intLogArray), GFP_KERNEL);
+	blog_buf = kzalloc(sizeof(maxdsm_byte_log_array), GFP_KERNEL);
+	ilog_buf = kzalloc(sizeof(maxdsm_int_log_array), GFP_KERNEL);
 	after_blog_buf
-		= kzalloc(sizeof(maxdsm_afterProbByteLogArray), GFP_KERNEL);
+		= kzalloc(sizeof(maxdsm_after_prob_byte_log_array), GFP_KERNEL);
 	after_ilog_buf
-		= kzalloc(sizeof(maxdsm_afterProbIntLogArray), GFP_KERNEL);
+		= kzalloc(sizeof(maxdsm_after_prob_int_log_array), GFP_KERNEL);
 
-	if (unlikely(!blog_buf || !ilog_buf \
+	if (unlikely(!blog_buf || !ilog_buf
 		|| !after_blog_buf || !after_ilog_buf)) {
 		rc = -ENOMEM;
 		goto abort;
 	}
 
-	memcpy(blog_buf, maxdsm_byteLogArray, sizeof(maxdsm_byteLogArray));
-	memcpy(ilog_buf, maxdsm_intLogArray, sizeof(maxdsm_intLogArray));
-	memcpy(after_blog_buf, maxdsm_afterProbByteLogArray,
-		sizeof(maxdsm_afterProbByteLogArray));
-	memcpy(after_ilog_buf, maxdsm_afterProbIntLogArray,
-		sizeof(maxdsm_afterProbIntLogArray));
+	memcpy(blog_buf, maxdsm_byte_log_array, sizeof(maxdsm_byte_log_array));
+	memcpy(ilog_buf, maxdsm_int_log_array, sizeof(maxdsm_int_log_array));
+	memcpy(after_blog_buf, maxdsm_after_prob_byte_log_array,
+			sizeof(maxdsm_after_prob_byte_log_array));
+	memcpy(after_ilog_buf, maxdsm_after_prob_int_log_array,
+			sizeof(maxdsm_after_prob_int_log_array));
 
 	goto out;
 
 abort:
 	maxdsm_log_free(&blog_buf, &ilog_buf, &after_blog_buf, &after_ilog_buf);
 out:
-	*byteLogArray = blog_buf;
-	*intLogArray  = ilog_buf;
-	*afterbyteLogArray = after_blog_buf;
-	*afterintLogArray  = after_ilog_buf;
+	*byte_log_array = blog_buf;
+	*int_log_array  = ilog_buf;
+	*afterbyte_log_array = after_blog_buf;
+	*after_int_log_array  = after_ilog_buf;
 	mutex_unlock(&maxdsm_log_lock);
 
 	return rc;
@@ -142,87 +1058,116 @@
 
 ssize_t maxdsm_log_prepare(char *buf)
 {
-	uint8_t *byteLogArray = NULL;
-	uint32_t *intLogArray = NULL;
-	uint8_t *afterbyteLogArray = NULL;
-	uint32_t *afterintLogArray = NULL;
+	uint8_t *byte_log_array = NULL;
+	uint32_t *int_log_array = NULL;
+	uint8_t *afterbyte_log_array = NULL;
+	uint32_t *after_int_log_array = NULL;
 	int rc = 0;
 
-	uint8_t logAvailable;
-	uint8_t versionID;
-	uint8_t *coilTempLogArray;
-	uint8_t *exCurLogArray;
-	uint8_t *AftercoilTempLogArray;
-	uint8_t *AfterexCurLogArray;
-	uint8_t *ExcurAftercoilTempLogArray;
-	uint8_t *ExcurAfterexCurLogArray;
-
-	uint32_t seqCountTemp;
-	uint32_t seqCountExcur;
-	uint32_t *rdcLogArray;
-	uint32_t *freqLogArray;
-	uint32_t *AfterrdcLogArray;
-	uint32_t *AfterfreqLogArray;
-	uint32_t *ExcurAfterrdcLogArray;
-	uint32_t *ExcurAfterfreqLogArray;
-
-	rc = maxdsm_log_duplicate((void **)&byteLogArray, \
-		(void **)&intLogArray, (void **)&afterbyteLogArray, \
-		(void **)&afterintLogArray);
+	uint8_t log_available;
+	uint8_t version_id;
+	uint8_t *coil_temp_log_array;
+	uint8_t *excur_log_array;
+	uint8_t *after_coil_temp_log_array;
+	uint8_t *after_excur_log_array;
+	uint8_t *excur_after_coil_temp_log_array;
+	uint8_t *excur_after_excur_log_array;
+
+	uint32_t seq_count_temp;
+	uint32_t seq_count_excur;
+	uint32_t *rdc_log_array;
+	uint32_t *freq_log_array;
+	uint32_t *after_rdc_log_array;
+	uint32_t *after_freq_log_array;
+	uint32_t *excur_after_rdc_log_array;
+	uint32_t *excur_after_freq_log_array;
+
+	int param_excur_limit = PARAM_A_EXCUR_LIMIT;
+	int param_thermal_limit = PARAM_A_THERMAL_LIMIT;
+	int param_voice_coil = PARAM_A_VOICE_COIL;
+	int param_release_time = PARAM_A_RELEASE_TIME;
+	int param_static_gain = PARAM_A_STATIC_GAIN;
+	int param_lfx_gain = PARAM_A_LFX_GAIN;
+	int param_pilot_gain = PARAM_A_PILOT_GAIN;
+
+	rc = maxdsm_log_duplicate((void **)&byte_log_array,
+			(void **)&int_log_array, (void **)&afterbyte_log_array,
+			(void **)&after_int_log_array);
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		/* Already initialized */
+		break;
+	case PLATFORM_TYPE_B:
+		param_excur_limit = PARAM_EXCUR_LIMIT;
+		param_thermal_limit = PARAM_THERMAL_LIMIT;
+		param_voice_coil = PARAM_VOICE_COIL;
+		param_release_time = PARAM_RELEASE_TIME;
+		param_static_gain = PARAM_STATIC_GAIN;
+		param_lfx_gain = PARAM_LFX_GAIN;
+		param_pilot_gain = PARAM_PILOT_GAIN;
+		break;
+	}
 
 	if (unlikely(rc)) {
 		rc = snprintf(buf, PAGE_SIZE, "no log\n");
-		if (param[PARAM_EXCUR_LIMIT] != 0 &&\
-			param[PARAM_THERMAL_LIMIT] != 0)	{
-			rc += snprintf(buf+rc, PAGE_SIZE,  \
-				"[Parameter Set] excursionlimit:0x%x, "\
-				"rdcroomtemp:0x%x, coilthermallimit:0x%x, "
-				"releasetime:0x%x\n"\
-				, param[PARAM_EXCUR_LIMIT],
-				param[PARAM_VOICE_COIL],
-				param[PARAM_THERMAL_LIMIT],
-				param[PARAM_RELEASE_TIME]);
-			rc += snprintf(buf+rc, PAGE_SIZE,  "[Parameter Set] "\
-				"staticgain:0x%x, lfxgain:0x%x, "\
-				"pilotgain:0x%x\n",
-				param[PARAM_STATIC_GAIN],
-				param[PARAM_LFX_GAIN],
-				param[PARAM_PILOT_GAIN]);
+		if (maxdsm.param[param_excur_limit] != 0 &&
+				maxdsm.param[param_thermal_limit] != 0) {
+			rc += snprintf(buf+rc, PAGE_SIZE,
+					"[Parameter Set] excursionlimit:0x%x, ",
+					maxdsm.param[param_excur_limit]);
+			rc += snprintf(buf+rc, PAGE_SIZE,
+					"rdcroomtemp:0x%x, coilthermallimit:0x%x, ",
+					maxdsm.param[param_voice_coil],
+					maxdsm.param[param_thermal_limit]);
+			rc += snprintf(buf+rc, PAGE_SIZE,
+					"releasetime:0x%x\n",
+					maxdsm.param[param_release_time]);
+			rc += snprintf(buf+rc, PAGE_SIZE,
+					"[Parameter Set] staticgain:0x%x, ",
+					maxdsm.param[param_static_gain]);
+			rc += snprintf(buf+rc, PAGE_SIZE,
+					"lfxgain:0x%x, pilotgain:0x%0x\n",
+					maxdsm.param[param_lfx_gain],
+					maxdsm.param[param_pilot_gain]);
 		}
 		goto out;
 	}
 
-	logAvailable     = byteLogArray[0];
-	versionID        = byteLogArray[1];
-	coilTempLogArray = &byteLogArray[2];
-	exCurLogArray    = &byteLogArray[2+LOG_BUFFER_ARRAY_SIZE];
-
-	seqCountTemp       = intLogArray[0];
-	seqCountExcur   = intLogArray[1];
-	rdcLogArray  = &intLogArray[2];
-	freqLogArray = &intLogArray[2+LOG_BUFFER_ARRAY_SIZE];
-
-	AftercoilTempLogArray = &afterbyteLogArray[0];
-	AfterexCurLogArray = &afterbyteLogArray[LOG_BUFFER_ARRAY_SIZE];
-	AfterrdcLogArray = &afterintLogArray[0];
-	AfterfreqLogArray = &afterintLogArray[LOG_BUFFER_ARRAY_SIZE];
-
-	ExcurAftercoilTempLogArray
-		= &afterbyteLogArray[LOG_BUFFER_ARRAY_SIZE*2];
-	ExcurAfterexCurLogArray = &afterbyteLogArray[LOG_BUFFER_ARRAY_SIZE*3];
-	ExcurAfterrdcLogArray = &afterintLogArray[LOG_BUFFER_ARRAY_SIZE*2];
-	ExcurAfterfreqLogArray = &afterintLogArray[LOG_BUFFER_ARRAY_SIZE*3];
-
-	if (logAvailable > 0 && \
-		(exSeqCountTemp != seqCountTemp \
-		|| exSeqCountExcur != seqCountExcur))	{
-		exSeqCountTemp = seqCountTemp;
-		exSeqCountExcur = seqCountExcur;
-		newLogAvail |= 0x2;
+	log_available     = byte_log_array[0];
+	version_id        = byte_log_array[1];
+	coil_temp_log_array = &byte_log_array[2];
+	excur_log_array    = &byte_log_array[2+LOG_BUFFER_ARRAY_SIZE];
+
+	seq_count_temp       = int_log_array[0];
+	seq_count_excur   = int_log_array[1];
+	rdc_log_array  = &int_log_array[2];
+	freq_log_array = &int_log_array[2+LOG_BUFFER_ARRAY_SIZE];
+
+	after_coil_temp_log_array = &afterbyte_log_array[0];
+	after_excur_log_array = &afterbyte_log_array[LOG_BUFFER_ARRAY_SIZE];
+	after_rdc_log_array = &after_int_log_array[0];
+	after_freq_log_array = &after_int_log_array[LOG_BUFFER_ARRAY_SIZE];
+
+	excur_after_coil_temp_log_array
+		= &afterbyte_log_array[LOG_BUFFER_ARRAY_SIZE*2];
+	excur_after_excur_log_array
+		= &afterbyte_log_array[LOG_BUFFER_ARRAY_SIZE*3];
+	excur_after_rdc_log_array
+		= &after_int_log_array[LOG_BUFFER_ARRAY_SIZE*2];
+	excur_after_freq_log_array
+		= &after_int_log_array[LOG_BUFFER_ARRAY_SIZE*3];
+
+	if (log_available > 0 &&
+			(ex_seq_count_temp != seq_count_temp
+			 || ex_seq_count_excur != seq_count_excur)) {
+		ex_seq_count_temp = seq_count_temp;
+		ex_seq_count_excur = seq_count_excur;
+		new_log_avail |= 0x2;
 	}
 
-	rc += snprintf(buf+rc, PAGE_SIZE, "DSM LogData saved at "\
-		"%4d-%02d-%02d %02d:%02d:%02d (UTC)\n",
+	rc += snprintf(buf+rc, PAGE_SIZE,
+			"DSM LogData saved at %4d-%02d-%02d %02d:%02d:%02d (UTC)\n",
 		(int)(maxdsm_log_timestamp.tm_year + 1900),
 		(int)(maxdsm_log_timestamp.tm_mon + 1),
 		(int)(maxdsm_log_timestamp.tm_mday),
@@ -230,266 +1175,891 @@
 		(int)(maxdsm_log_timestamp.tm_min),
 		(int)(maxdsm_log_timestamp.tm_sec));
 
-	if ((logAvailable & 0x1) == 0x1) {
-		rc += snprintf(buf+rc, PAGE_SIZE, \
+	if ((log_available & 0x1) == 0x1) {
+		rc += snprintf(buf+rc, PAGE_SIZE,
 			"*** Excursion Limit was exceeded.\n");
-		rc += snprintf(buf+rc, PAGE_SIZE, \
-			"Seq:%d, logAvailable=%d, versionID:3.1.%d\n", \
-			seqCountExcur, logAvailable, versionID);
-		rc += snprintf(buf+rc, PAGE_SIZE, "Temperature="\
-			"{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			ExcurAftercoilTempLogArray[0],
-			ExcurAftercoilTempLogArray[1],
-			ExcurAftercoilTempLogArray[2],
-			ExcurAftercoilTempLogArray[3],
-			ExcurAftercoilTempLogArray[4],
-			ExcurAftercoilTempLogArray[5],
-			ExcurAftercoilTempLogArray[6],
-			ExcurAftercoilTempLogArray[7],
-			ExcurAftercoilTempLogArray[8],
-			ExcurAftercoilTempLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE,  \
-			"Excursion="\
-			"{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			ExcurAfterexCurLogArray[0],
-			ExcurAfterexCurLogArray[1],
-			ExcurAfterexCurLogArray[2],
-			ExcurAfterexCurLogArray[3],
-			ExcurAfterexCurLogArray[4],
-			ExcurAfterexCurLogArray[5],
-			ExcurAfterexCurLogArray[6],
-			ExcurAfterexCurLogArray[7],
-			ExcurAfterexCurLogArray[8],
-			ExcurAfterexCurLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE,  "Rdc="\
-			"{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			ExcurAfterrdcLogArray[0],
-			ExcurAfterrdcLogArray[1],
-			ExcurAfterrdcLogArray[2],
-			ExcurAfterrdcLogArray[3],
-			ExcurAfterrdcLogArray[4],
-			ExcurAfterrdcLogArray[5],
-			ExcurAfterrdcLogArray[6],
-			ExcurAfterrdcLogArray[7],
-			ExcurAfterrdcLogArray[8],
-			ExcurAfterrdcLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE,  "Frequency="\
-			"{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			ExcurAfterfreqLogArray[0],
-			ExcurAfterfreqLogArray[1],
-			ExcurAfterfreqLogArray[2],
-			ExcurAfterfreqLogArray[3],
-			ExcurAfterfreqLogArray[4],
-			ExcurAfterfreqLogArray[5],
-			ExcurAfterfreqLogArray[6],
-			ExcurAfterfreqLogArray[7],
-			ExcurAfterfreqLogArray[8],
-			ExcurAfterfreqLogArray[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Seq:%d, log_available=%d, version_id:3.1.%d\n",
+				seq_count_excur, log_available, version_id);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Temperature={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				excur_after_coil_temp_log_array[0],
+				excur_after_coil_temp_log_array[1],
+				excur_after_coil_temp_log_array[2],
+				excur_after_coil_temp_log_array[3],
+				excur_after_coil_temp_log_array[4],
+				excur_after_coil_temp_log_array[5],
+				excur_after_coil_temp_log_array[6],
+				excur_after_coil_temp_log_array[7],
+				excur_after_coil_temp_log_array[8],
+				excur_after_coil_temp_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Excursion={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				excur_after_excur_log_array[0],
+				excur_after_excur_log_array[1],
+				excur_after_excur_log_array[2],
+				excur_after_excur_log_array[3],
+				excur_after_excur_log_array[4],
+				excur_after_excur_log_array[5],
+				excur_after_excur_log_array[6],
+				excur_after_excur_log_array[7],
+				excur_after_excur_log_array[8],
+				excur_after_excur_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Rdc={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				excur_after_rdc_log_array[0],
+				excur_after_rdc_log_array[1],
+				excur_after_rdc_log_array[2],
+				excur_after_rdc_log_array[3],
+				excur_after_rdc_log_array[4],
+				excur_after_rdc_log_array[5],
+				excur_after_rdc_log_array[6],
+				excur_after_rdc_log_array[7],
+				excur_after_rdc_log_array[8],
+				excur_after_rdc_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Frequency={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				excur_after_freq_log_array[0],
+				excur_after_freq_log_array[1],
+				excur_after_freq_log_array[2],
+				excur_after_freq_log_array[3],
+				excur_after_freq_log_array[4],
+				excur_after_freq_log_array[5],
+				excur_after_freq_log_array[6],
+				excur_after_freq_log_array[7],
+				excur_after_freq_log_array[8],
+				excur_after_freq_log_array[9]);
 	}
 
-	if ((logAvailable & 0x2) == 0x2) {
-		rc += snprintf(buf+rc, PAGE_SIZE, \
+	if ((log_available & 0x2) == 0x2) {
+		rc += snprintf(buf+rc, PAGE_SIZE,
 			"*** Temperature Limit was exceeded.\n");
-		rc += snprintf(buf+rc, PAGE_SIZE, \
-			"Seq:%d, logAvailable=%d, versionID:3.1.%d\n", \
-			seqCountTemp, logAvailable, versionID);
-		rc += snprintf(buf+rc, PAGE_SIZE, "Temperature="\
-			"{ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d,\n",
-			coilTempLogArray[0],
-			coilTempLogArray[1],
-			coilTempLogArray[2],
-			coilTempLogArray[3],
-			coilTempLogArray[4],
-			coilTempLogArray[5],
-			coilTempLogArray[6],
-			coilTempLogArray[7],
-			coilTempLogArray[8],
-			coilTempLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE, "              "\
-			"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			AftercoilTempLogArray[0],
-			AftercoilTempLogArray[1],
-			AftercoilTempLogArray[2],
-			AftercoilTempLogArray[3],
-			AftercoilTempLogArray[4],
-			AftercoilTempLogArray[5],
-			AftercoilTempLogArray[6],
-			AftercoilTempLogArray[7],
-			AftercoilTempLogArray[8],
-			AftercoilTempLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE, \
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Seq:%d, log_available=%d, version_id:3.1.%d\n",
+				seq_count_temp, log_available, version_id);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Temperature={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d,\n",
+				coil_temp_log_array[0],
+				coil_temp_log_array[1],
+				coil_temp_log_array[2],
+				coil_temp_log_array[3],
+				coil_temp_log_array[4],
+				coil_temp_log_array[5],
+				coil_temp_log_array[6],
+				coil_temp_log_array[7],
+				coil_temp_log_array[8],
+				coil_temp_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"              %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				after_coil_temp_log_array[0],
+				after_coil_temp_log_array[1],
+				after_coil_temp_log_array[2],
+				after_coil_temp_log_array[3],
+				after_coil_temp_log_array[4],
+				after_coil_temp_log_array[5],
+				after_coil_temp_log_array[6],
+				after_coil_temp_log_array[7],
+				after_coil_temp_log_array[8],
+				after_coil_temp_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
 			"Excursion={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d,\n",
-			exCurLogArray[0],
-			exCurLogArray[1],
-			exCurLogArray[2],
-			exCurLogArray[3],
-			exCurLogArray[4],
-			exCurLogArray[5],
-			exCurLogArray[6],
-			exCurLogArray[7],
-			exCurLogArray[8],
-			exCurLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE, "            "\
-			"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			AfterexCurLogArray[0],
-			AfterexCurLogArray[1],
-			AfterexCurLogArray[2],
-			AfterexCurLogArray[3],
-			AfterexCurLogArray[4],
-			AfterexCurLogArray[5],
-			AfterexCurLogArray[6],
-			AfterexCurLogArray[7],
-			AfterexCurLogArray[8],
-			AfterexCurLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE,\
+				excur_log_array[0],
+				excur_log_array[1],
+				excur_log_array[2],
+				excur_log_array[3],
+				excur_log_array[4],
+				excur_log_array[5],
+				excur_log_array[6],
+				excur_log_array[7],
+				excur_log_array[8],
+				excur_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"             %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				after_excur_log_array[0],
+				after_excur_log_array[1],
+				after_excur_log_array[2],
+				after_excur_log_array[3],
+				after_excur_log_array[4],
+				after_excur_log_array[5],
+				after_excur_log_array[6],
+				after_excur_log_array[7],
+				after_excur_log_array[8],
+				after_excur_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
 			"Rdc={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d,\n",
-			rdcLogArray[0],
-			rdcLogArray[1],
-			rdcLogArray[2],
-			rdcLogArray[3],
-			rdcLogArray[4],
-			rdcLogArray[5],
-			rdcLogArray[6],
-			rdcLogArray[7],
-			rdcLogArray[8],
-			rdcLogArray[9]);
+				rdc_log_array[0],
+				rdc_log_array[1],
+				rdc_log_array[2],
+				rdc_log_array[3],
+				rdc_log_array[4],
+				rdc_log_array[5],
+				rdc_log_array[6],
+				rdc_log_array[7],
+				rdc_log_array[8],
+				rdc_log_array[9]);
 		rc += snprintf(buf+rc, PAGE_SIZE,
 			"      %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			AfterrdcLogArray[0],
-			AfterrdcLogArray[1],
-			AfterrdcLogArray[2],
-			AfterrdcLogArray[3],
-			AfterrdcLogArray[4],
-			AfterrdcLogArray[5],
-			AfterrdcLogArray[6],
-			AfterrdcLogArray[7],
-			AfterrdcLogArray[8],
-			AfterrdcLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE, \
+				after_rdc_log_array[0],
+				after_rdc_log_array[1],
+				after_rdc_log_array[2],
+				after_rdc_log_array[3],
+				after_rdc_log_array[4],
+				after_rdc_log_array[5],
+				after_rdc_log_array[6],
+				after_rdc_log_array[7],
+				after_rdc_log_array[8],
+				after_rdc_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
 			"Frequency={ %d, %d, %d, %d, %d, %d, %d, %d, %d, %d,\n",
-			freqLogArray[0],
-			freqLogArray[1],
-			freqLogArray[2],
-			freqLogArray[3],
-			freqLogArray[4],
-			freqLogArray[5],
-			freqLogArray[6],
-			freqLogArray[7],
-			freqLogArray[8],
-			freqLogArray[9]);
-		rc += snprintf(buf+rc, PAGE_SIZE, "            "\
-			"%d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
-			AfterfreqLogArray[0],
-			AfterfreqLogArray[1],
-			AfterfreqLogArray[2],
-			AfterfreqLogArray[3],
-			AfterfreqLogArray[4],
-			AfterfreqLogArray[5],
-			AfterfreqLogArray[6],
-			AfterfreqLogArray[7],
-			AfterfreqLogArray[8],
-			AfterfreqLogArray[9]);
-	}
-
-	if (param[PARAM_EXCUR_LIMIT] != 0 &&\
-		param[PARAM_THERMAL_LIMIT] != 0)	{
-		rc += snprintf(buf+rc, PAGE_SIZE, \
-			"[Parameter Set] excursionlimit:0x%x, "\
-			"rdcroomtemp:0x%x, coilthermallimit:0x%x, "\
+				freq_log_array[0],
+				freq_log_array[1],
+				freq_log_array[2],
+				freq_log_array[3],
+				freq_log_array[4],
+				freq_log_array[5],
+				freq_log_array[6],
+				freq_log_array[7],
+				freq_log_array[8],
+				freq_log_array[9]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"             %d, %d, %d, %d, %d, %d, %d, %d, %d, %d }\n",
+				after_freq_log_array[0],
+				after_freq_log_array[1],
+				after_freq_log_array[2],
+				after_freq_log_array[3],
+				after_freq_log_array[4],
+				after_freq_log_array[5],
+				after_freq_log_array[6],
+				after_freq_log_array[7],
+				after_freq_log_array[8],
+				after_freq_log_array[9]);
+	}
+
+	if (maxdsm.param[param_excur_limit] != 0 &&
+			maxdsm.param[param_thermal_limit] != 0) {
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"[Parameter Set] excursionlimit:0x%x, ",
+				maxdsm.param[param_excur_limit]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"rdcroomtemp:0x%x, coilthermallimit:0x%x, ",
+				maxdsm.param[param_voice_coil],
+				maxdsm.param[param_thermal_limit]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
 			"releasetime:0x%x\n",
-			param[PARAM_EXCUR_LIMIT],
-			param[PARAM_VOICE_COIL],
-			param[PARAM_THERMAL_LIMIT],
-			param[PARAM_RELEASE_TIME]);
-		rc += snprintf(buf+rc, PAGE_SIZE,  "[Parameter Set] "\
-			"staticgain:0x%x, lfxgain:0x%x, pilotgain:0x%x\n",
-			param[PARAM_STATIC_GAIN],
-			param[PARAM_LFX_GAIN],
-			param[PARAM_PILOT_GAIN]);
+				maxdsm.param[param_release_time]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"[Parameter Set] staticgain:0x%x, ",
+				maxdsm.param[param_static_gain]);
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"lfxgain:0x%x, pilotgain:0x%x\n",
+				maxdsm.param[param_lfx_gain],
+				maxdsm.param[param_pilot_gain]);
 	}
 
 out:
-	maxdsm_log_free((void **)&byteLogArray, (void **)&intLogArray, \
-		(void **)&afterbyteLogArray, (void **)&afterintLogArray);
 
 	return (ssize_t)rc;
 }
-#endif
+EXPORT_SYMBOL_GPL(maxdsm_log_prepare);
+#endif /* USE_DSM_LOG */
 
-int get_dsm_onoff_status(void){
-	return param[PARAM_ONOFF];
+#ifdef USE_DSM_UPDATE_CAL
+ssize_t maxdsm_cal_prepare(char *buf)
+{
+	int rc = 0;
+	int x;
+
+	if (maxdsm.update_cal)	{
+		for (x = 0; x < (maxdsm.param_size >> 1); x++)	{
+			rc += snprintf(buf+rc, PAGE_SIZE,
+					"[%2d] 0x%08x, ",
+					x,
+					(int)(g_pbi[x].val));
+			if ((x%5) == 4)
+				rc += snprintf(buf+rc, PAGE_SIZE,
+						"\n");
+		}
+		rc += snprintf(buf+rc, PAGE_SIZE,
+				"Use Updated Parameters.\n");
+	}	else
+		rc += snprintf(buf+rc, PAGE_SIZE,
+			"Use Default Parameters.\n");
+
+	return (ssize_t)rc;
 }
+EXPORT_SYMBOL_GPL(maxdsm_cal_prepare);
+#endif /* USE_DSM_UPDATE_CAL */
 
-static int maxdsm_open(struct inode *inode, struct file *filep)
+static int maxdsm_set_param(struct param_set_data *data, int size)
 {
-	return 0;
+	int loop, ret = 0;
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		for (loop = 0; loop < size; loop++)
+			maxdsm_regmap_write(data[loop].addr, data[loop].value);
+		break;
+	case PLATFORM_TYPE_B:
+		maxdsm.filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+		ret = maxdsm_dsm_open(&maxdsm);
+		maxdsm.param[PARAM_WRITE_FLAG] = data[0].wflag;
+		for (loop = 0; loop < size; loop++)
+			maxdsm.param[data[loop].name] = data[loop].value;
+		maxdsm.filter_set = DSM_ID_FILTER_SET_AFE_CNTRLS;
+		ret = maxdsm_dsm_open(&maxdsm);
+		break;
+	default:
+		return -ENODATA;
+	}
+
+	return ret < 0 ? ret : 0;
 }
 
-static ssize_t maxdsm_read(struct file *filep, char __user *buf,
-			size_t count, loff_t *ppos)
+static int maxdsm_find_index_of_saved_params(
+		struct param_set_data *params,
+		int size,
+		uint32_t param_name)
+{
+	while (size-- > 0)
+		if (params[size].name == param_name)
+			break;
+
+	return size;
+}
+
+uint32_t maxdsm_get_platform_type(void)
+{
+	dbg_maxdsm("platform_type=%d", maxdsm.platform_type);
+	return maxdsm.platform_type;
+}
+EXPORT_SYMBOL_GPL(maxdsm_get_platform_type);
+
+int maxdsm_update_feature_en_adc(int apply)
+{
+	unsigned int val = 0;
+	unsigned int reg;
+	struct param_set_data data = {
+		.name = PARAM_FEATURE_SET,
+		.addr = 0x2A006A,
+		.value = 0x200,
+		.wflag = FLAG_WRITE_FEATURE_ONLY,
+	};
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		reg = data.addr;
+		break;
+	case PLATFORM_TYPE_B:
+		reg = data.name;
+		data.value <<= 1;
+		break;
+	default:
+		return -ENODATA;
+	}
+
+	maxdsm_read_wrapper(reg, &val);
+
+	if (apply)
+		data.value = val | data.value;
+	else
+		data.value = val & ~data.value;
+	dbg_maxdsm("apply=%d data.value=0x%x val=0x%x reg=%x",
+			apply, data.value, val, reg);
+
+	return maxdsm_set_param(&data, 1);
+}
+EXPORT_SYMBOL_GPL(maxdsm_update_feature_en_adc);
+
+int maxdsm_set_feature_en(int on)
+{
+	int index;
+	struct param_set_data data = {
+		.name = PARAM_FEATURE_SET,
+		.value = 0,
+		.wflag = FLAG_WRITE_FEATURE_ONLY,
+	};
+
+	index = maxdsm_find_index_of_saved_params(
+				maxdsm_saved_params,
+				sizeof(maxdsm_saved_params)
+					/ sizeof(struct param_set_data),
+				PARAM_FEATURE_SET);
+	if (index < 0 || !maxdsm.platform_type)
+		return -ENODATA;
+
+	if (on) {
+		if (maxdsm_saved_params[index].value & 0x40) {
+			pr_err("%s: feature_en has already 0x40\n",
+					__func__);
+			return -EALREADY;
+		}
+		maxdsm.filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+		maxdsm_dsm_open(&maxdsm);
+
+		maxdsm_saved_params[index].value
+			= maxdsm.param[PARAM_FEATURE_SET];
+		data.value =
+			maxdsm_saved_params[index].value | 0x40;
+		dbg_maxdsm("data.value=0x%08x", data.value);
+		dbg_maxdsm("maxdsm_saved_params[%d].value=0x%08x",
+				index, maxdsm_saved_params[index].value);
+	} else {
+		data.value =
+			maxdsm_saved_params[index].value & ~0x40;
+		dbg_maxdsm("data.value=0x%08x", data.value);
+		dbg_maxdsm("maxdsm_saved_params[%d].value=0x%08x",
+				index, maxdsm_saved_params[index].value);
+	}
+
+	return maxdsm_set_param(&data, 1);
+}
+EXPORT_SYMBOL_GPL(maxdsm_set_feature_en);
+
+int maxdsm_set_rdc_temp(uint32_t rdc, uint32_t temp)
+{
+	struct param_set_data data[] = {
+		{
+			.name = PARAM_VOICE_COIL,
+			.value = rdc, /* This was already calculated. */
+			.wflag = FLAG_WRITE_RDC_CAL_ONLY,
+		},
+		{
+			.name = PARAM_AMBIENT_TEMP,
+			.value = temp << 19,
+			.wflag = FLAG_WRITE_RDC_CAL_ONLY,
+		},
+	};
+
+	dbg_maxdsm("rdc=0x%08x(0x%08x) temp=0x%08x(0x%08x)",
+			rdc, data[0].value, temp, data[1].value);
+
+	return maxdsm_set_param(
+			data,
+			sizeof(data) / sizeof(struct param_set_data));
+}
+EXPORT_SYMBOL_GPL(maxdsm_set_rdc_temp);
+
+int maxdsm_set_dsm_onoff_status(int on)
 {
-	int rc;
-	uint32_t filter_set;
+	struct param_set_data data[] = {
+		{
+			.name = PARAM_ONOFF,
+			.value = on,
+			.wflag = FLAG_WRITE_ONOFF_ONLY,
+		},
+	};
+
+	return maxdsm_set_param(
+			data,
+			sizeof(data) / sizeof(struct param_set_data));
+}
+EXPORT_SYMBOL_GPL(maxdsm_set_dsm_onoff_status);
 
-	mutex_lock(&dsm_lock);
+uint32_t maxdsm_get_dcresistance(void)
+{
+	maxdsm.filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+	maxdsm_dsm_open(&maxdsm);
 
-	filter_set = DSM_ID_FILTER_GET_AFE_PARAMS;
+	return maxdsm.param[PARAM_RDC]
+				<< maxdsm.param[PARAM_RDC_SZ];
+}
+EXPORT_SYMBOL_GPL(maxdsm_get_dcresistance);
+
+uint32_t maxdsm_get_dsm_onoff_status(void)
+{
+	return maxdsm.param[PARAM_ONOFF];
+}
 
-	dsm_open(DSM_RX_PORT_ID, &filter_set, (u8 *) param);
+#define V30_SIZE	(PARAM_DSM_3_0_MAX >> 1)
+#define V35_SIZE	((PARAM_DSM_3_5_MAX - PARAM_DSM_3_0_MAX) >> 1)
+#define V40_SIZE	((PARAM_DSM_4_0_MAX - PARAM_DSM_3_5_MAX) >> 1)
+#define A_V35_SIZE	(PARAM_A_DSM_3_5_MAX >> 1)
+#define A_V40_SIZE	((PARAM_A_DSM_4_0_MAX - PARAM_A_DSM_3_5_MAX) >> 1)
+int maxdsm_update_param_info(struct maxim_dsm *maxdsm)
+{
+	uint32_t binfo_v30[V30_SIZE] = {
+		/* dcResistance, coilTemp, qualityFactor */
+		27, 19, 29,
+		/* resonanceFreq, excursionMeasure, rdcroomtemp */
+		9, 0, 27,
+		/* releasetime, coilthermallimit, excursionlimit */
+		30, 19, 27,
+		/* dsmenable */
+		0,
+		/* staticgain, lfxgain, pilotgain */
+		29, 30, 31,
+		/* flagToWrite, featureSetEnable */
+		0, 0,
+		/* smooFacVoltClip, highPassCutOffFactor, leadResistance */
+		30, 30, 27,
+		/* rmsSmooFac, clipLimit, thermalCoeff */
+		31, 27, 20,
+		/* qSpk, excurLoggingThresh, coilTempLoggingThresh */
+		29, 0, 0,
+		/* resFreq, resFreqGuardBand */
+		9, 9
+	}; /* 26 */
+
+	uint32_t binfo_v35[V35_SIZE] = {
+		/* Ambient_Temp, STL_attack_tiem, STL_release_time */
+		19, 19, 19,
+		/* STL_Admittance_a1, STL_Admittance_a2 */
+		30, 30,
+		/* STL_Admittance_b1, STL_Admittance_b1, STL_Admittance_b2 */
+		30, 30, 30,
+		/* Tch1, Rth1, Tch2, Rth2 */
+		24, 24, 24, 24,
+		/* STL_Attenuation_Gain */
+		30,
+		/* SPT_rampDownFrames, SPT_Threshold */
+		0, 19,
+		/* T_horizon */
+		0,
+		/* LFX_Admittance_a1, LFX_Admittance_a2 */
+		28, 28,
+		/* LFX_Admittance_b0, LFX_Admittance_b1, LFX_Admittance_b2 */
+		28, 28, 28,
+	}; /* 21 */
+
+	uint32_t binfo_v40[V40_SIZE] = {
+		/* X_MAX, SPK_FS, Q_GUARD_BAND */
+		0, 0, 0,
+		/* STIMPEDMODEL_CEFS_A1, A2, B0, B1, B2 */
+		0, 0, 0, 0, 0,
+		/* STIMPEDEMODEL_FLAG, Q_NOTCH */
+		0, 0,
+	};
+
+	uint32_t binfo_a_v35[A_V35_SIZE] = {
+		/* temp, excur, rdc, qc_low, qc_hi, fc_low, fc_high */
+		0, 0, 0, 0, 0, 0, 0,
+		/* excur limit, rdc roomt temp, temp limit */
+		1, 1, 1,
+		/* rel time, dsm on/off */
+		2, 2,
+		/* makeup gain, lfx gain, pilot gain */
+		3, 3, 3,
+		/* feature, smoofact, hpfcutoff, lead, rms_smoofact */
+		4, 4, 4, 4, 4,
+		/* volt, thermal coeff, qspk, excursion log, temp log */
+		5, 5, 5, 5, 5,
+		/* res freq, res freq guardband */
+		6, 6,
+		/* ambient temp, stl a1, stl a2, stl b0, stl b1, stl b2 */
+		10, 10, 10, 10, 10, 10,
+		/* rth1 hi, rth2 hi, rth1 lo, rth2 lo */
+		11, 12, 13, 14,
+		/* stl atengain hi, stl atengain lo */
+		15, 16,
+		/* ramp down, spt threshold hi, spt threshold lo */
+		17, 18, 19,
+		/* t horizon, lfx a1, lfx a2 */
+		20, 21, 22,
+		/* lfx b0, lfx b1, lfx b2, algorithm x */
+		23, 24, 25, 26,
+	};
+
+	uint32_t binfo_a_v40[A_V40_SIZE] = {
+		/* TCTH1 hi, TCTH1 lo, TCTH2 hi, TCTH2 lo */
+		1, 2, 3, 4,
+		/* ATTACK hi, ATTACK lo, RELEASE hi, RELEASE lo */
+		5, 6, 7, 8,
+		/* STL_SPK_FS, Q_GUARD_BAND hi, Q_GUARD_BAND lo */
+		9, 10, 11,
+		/* STIMPEDMODEL_CEFS_A1 hi, lo */
+		12, 13,
+		/* STIMPEDMODEL_CEFS_A2 hi, lo */
+		14, 15,
+		/* STIMPEDMODEL_CEFS_B0 hi, lo */
+		16, 17,
+		/* STIMPEDMODEL_CEFS_B1 hi, lo */
+		18, 19,
+		/* STIMPEDMODEL_CEFS_B2 hi, lo */
+		20, 21,
+		/* STIMPEDMODEL_FLAG, Q_NOTCH hi/lo */
+		22, 23, 24,
+	};
+
+	/* Try to get parameter size. */
+	switch (maxdsm->version) {
+	case VERSION_4_0_A:
+		maxdsm->param_size = PARAM_A_DSM_4_0_MAX;
+		break;
+	case VERSION_4_0_B:
+		maxdsm->param_size = PARAM_DSM_4_0_MAX;
+		break;
+	case VERSION_3_5_A:
+		maxdsm->param_size = PARAM_A_DSM_3_5_MAX;
+		break;
+	case VERSION_3_5_B:
+		maxdsm->param_size = PARAM_DSM_3_5_MAX;
+		break;
+	case VERSION_3_0:
+		maxdsm->param_size = PARAM_DSM_3_0_MAX;
+		break;
+	default:
+		pr_err("%s: Unknown version. %d\n", __func__,
+				maxdsm->version);
+		return -EINVAL;
+	}
+
+	kfree(maxdsm->binfo);
+	maxdsm->binfo = kzalloc(
+			sizeof(uint32_t) * maxdsm->param_size, GFP_KERNEL);
+	if (!maxdsm->binfo)
+		return -ENOMEM;
+
+	/* Try to copy parameter size. */
+	switch (maxdsm->version) {
+	case VERSION_4_0_A:
+		memcpy(&maxdsm->binfo[ARRAY_SIZE(binfo_a_v35)],
+				binfo_a_v40, sizeof(binfo_a_v40));
+	case VERSION_3_5_A:
+		memcpy(maxdsm->binfo,
+				binfo_a_v35, sizeof(binfo_a_v35));
+		break;
+	case VERSION_4_0_B:
+		memcpy(&maxdsm->binfo[
+				ARRAY_SIZE(binfo_v30) + ARRAY_SIZE(binfo_v35)],
+				binfo_v40, sizeof(binfo_v40));
+	case VERSION_3_5_B:
+		memcpy(&maxdsm->binfo[ARRAY_SIZE(binfo_v30)],
+				binfo_v35, sizeof(binfo_v35));
+	case VERSION_3_0:
+		memcpy(maxdsm->binfo,
+				binfo_v30, sizeof(binfo_v30));
+		break;
+	}
+
+	kfree(maxdsm->param);
+	maxdsm->param = kzalloc(
+			sizeof(uint32_t) * maxdsm->param_size, GFP_KERNEL);
+	if (!maxdsm->param) {
+		kfree(maxdsm->binfo);
+		return -ENOMEM;
+	}
+
+	dbg_maxdsm("version=%d, platform_type=%d",
+			maxdsm->version, maxdsm->platform_type);
 
-	rc = copy_to_user(buf, param, count);
-	if (rc != 0) {
-		pr_err("%s: copy_to_user failed - %d\n", __func__, rc);
-		mutex_unlock(&dsm_lock);
 		return 0;
+}
+
+int maxdsm_update_info(uint32_t *pinfo)
+{
+	int ret = 0;
+	int32_t *data = pinfo;
+
+	if (pinfo == NULL) {
+		pr_debug("%s: pinfo was not set.\n",
+				__func__);
+		ret = -EINVAL;
+		return ret;
 	}
 
-	mutex_unlock(&dsm_lock);
+	maxdsm.platform_type = data[PARAM_OFFSET_PLATFORM];
+	maxdsm.port_id = data[PARAM_OFFSET_PORT_ID];
+	maxdsm.rx_mod_id = data[PARAM_OFFSET_RX_MOD_ID];
+	maxdsm.tx_mod_id = data[PARAM_OFFSET_TX_MOD_ID];
+	maxdsm.filter_set = data[PARAM_OFFSET_FILTER_SET];
+	maxdsm.version = data[PARAM_OFFSET_VERSION];
 
-	return rc;
+	ret = maxdsm_update_param_info(&maxdsm);
+
+	return ret;
 }
+EXPORT_SYMBOL_GPL(maxdsm_update_info);
 
-static ssize_t maxdsm_write(struct file *filep, const char __user *buf,
-			size_t count, loff_t *ppos)
+int maxdsm_get_port_id(void)
 {
-	int x, rc;
-	uint32_t filter_set;
+	return maxdsm.port_id;
+}
+EXPORT_SYMBOL_GPL(maxdsm_get_port_id);
 
-	mutex_lock(&dsm_lock);
+int maxdsm_get_rx_mod_id(void)
+{
+	return maxdsm.rx_mod_id;
+}
+EXPORT_SYMBOL_GPL(maxdsm_get_rx_mod_id);
 
-	rc = copy_from_user(param, buf, count);
-	if (rc != 0) {
-		pr_err("%s: copy_from_user failed - %d\n", __func__, rc);
-		mutex_unlock(&dsm_lock);
-		return rc;
+int maxdsm_get_tx_mod_id(void)
+{
+	return maxdsm.tx_mod_id;
+}
+EXPORT_SYMBOL_GPL(maxdsm_get_tx_mod_id);
+
+static int maxdsm_validation_check(uint32_t flag)
+{
+	int ret = 0;
+
+	/* Validation check */
+	switch (flag) {
+	case FLAG_WRITE_ALL:
+	case FLAG_WRITE_ONOFF_ONLY:
+	case FLAG_WRITE_RDC_CAL_ONLY:
+	case FLAG_WRITE_FEATURE_ONLY:
+		break;
+	default:
+		pr_err("%s: Wrong information was received.\n", __func__);
+		ret = -EINVAL;
 	}
 
-	if (param[PARAM_WRITE_FLAG] == 0)	{
-		/* validation check */
-		for (x = PARAM_THERMAL_LIMIT;
-			x < PARAM_DSM_MAX; x += 2)	{
-			if ((x != PARAM_ONOFF) && (param[x] != 0)) {
-				param[PARAM_WRITE_FLAG] = FLAG_WRITE_ALL;
+	return ret;
+}
+
+#ifdef USE_DSM_UPDATE_CAL
+int maxdsm_update_caldata(int on)
+{
+	int x;
+	uint32_t val;
+	int ret = 0;
+
+	if (!maxdsm.update_cal || on == 0)	{
+		dbg_maxdsm("Calibration data is not available. Cmd:%d", on);
+		return ret;
+	}
+
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		for (x = 0; x < (maxdsm.param_size >> 1); x++)	{
+			ret = maxdsm_regmap_read(g_pbi[x].addr, &val);
+			if (val != g_pbi[x].val) {
+				maxdsm_regmap_write(g_pbi[x].addr,
+					g_pbi[x].val);
+				dbg_maxdsm("[%d]: 0x%08x / 0x%08x",
+						x, g_pbi[x].addr, g_pbi[x].val);
+			}
+		}
 				break;
+	case PLATFORM_TYPE_B:
+		for (x = 0; x < maxdsm.param_size; x += 2)	{
+			maxdsm.param[x] = g_pbi[x>>1].val;
+			maxdsm.param[x+1] = 1 << maxdsm.binfo[x>>1];
+			dbg_maxdsm("[%d]: 0x%08x / 0x%08x",
+					x, maxdsm.param[x], maxdsm.param[x+1]);
 			}
+		maxdsm.param[PARAM_WRITE_FLAG] = FLAG_WRITE_ALL;
+		maxdsm.filter_set = DSM_ID_FILTER_SET_AFE_CNTRLS;
+		maxdsm_dsm_open(&maxdsm);
+		break;
 		}
+
+	return ret;
+}
+
+int maxdsm_cal_avail(void)
+{
+	return maxdsm.update_cal;
+}
+
+static void maxdsm_store_caldata(void)
+{
+	int x;
+
+	for (x = 0; x < (maxdsm.param_size >> 1); x++) {
+		g_pbi[x].val = maxdsm.param[x<<1];
+		dbg_maxdsm("[%d]: 0x%08x",
+				x, g_pbi[x].val);
+	}
+
+	maxdsm.update_cal = 1;
+}
+#endif /* USE_DSM_UPDATE_CAL */
+
+static int maxdsm_open(struct inode *inode, struct file *filep)
+{
+	return 0;
+}
+
+static long maxdsm_ioctl_handler(struct file *file,
+		unsigned int cmd, unsigned int arg,
+		void __user *argp)
+{
+	unsigned int reg, val;
+	long ret = -EINVAL;
+
+	mutex_lock(&dsm_fs_lock);
+
+	switch (cmd) {
+	case MAXDSM_IOCTL_GET_VERSION:
+		ret = maxdsm.version;
+		if (copy_to_user(argp,
+				&maxdsm.version,
+				sizeof(maxdsm.version)))
+			goto error;
+		break;
+	case MAXDSM_IOCTL_SET_VERSION:
+		if (arg < VERSION_3_0 ||
+				arg > VERSION_4_0_B)
+			goto error;
+		maxdsm.version = arg;
+		ret = maxdsm_update_param_info(&maxdsm);
+		if (!ret)
+			goto error;
+		ret = maxdsm.version;
+		break;
+	case MAXDSM_IOCTL_GET_ALL_PARAMS:
+		maxdsm_read_all();
+		if (copy_to_user(argp, maxdsm.param,
+				sizeof(int) * maxdsm.param_size))
+			goto error;
+		break;
+	case MAXDSM_IOCTL_SET_ALL_PARAMS:
+		if (copy_from_user(maxdsm.param, argp,
+				sizeof(int) * maxdsm.param_size))
+			goto error;
+		maxdsm_write_all();
+		break;
+	case MAXDSM_IOCTL_GET_PARAM:
+		reg = (unsigned int)(arg & 0xFFFFFFFF);
+		val = 0;
+		/*
+		 * protocol rule.
+		 * PLATFORM_TYPE_A:
+		 *	reg : register
+		 *	val : value
+		 * PLATFORM_TYPE_B:
+		 *	reg : parameter index
+		 *	val : value
+		 */
+		maxdsm_read_wrapper(reg, &val);
+		ret = val;
+		if (copy_to_user(argp, &val, sizeof(val)))
+			goto error;
+		break;
+	case MAXDSM_IOCTL_SET_PARAM:
+		if (copy_from_user(maxdsm.param, argp,
+				sizeof(int) * 3/* reg, val, flag */))
+			goto error;
+		ret = maxdsm_write_wrapper(maxdsm.param[0],
+				maxdsm.param[1], maxdsm.param[2]);
+		break;
+#ifdef USE_DSM_UPDATE_CAL
+	case MAXDSM_IOCTL_GET_CAL_DATA:
+		/* todo */
+		break;
+	case MAXDSM_IOCTL_SET_CAL_DATA:
+		if (copy_from_user(maxdsm.param, argp,
+				sizeof(int) * maxdsm.param_size))
+			goto error;
+		maxdsm_store_caldata();
+		break;
+#endif /* USE_DSM_UPDATE_CAL */
+	case MAXDSM_IOCTL_GET_PLATFORM_TYPE:
+		ret = maxdsm.platform_type;
+		if (copy_to_user(argp,
+				&maxdsm.platform_type,
+				sizeof(maxdsm.platform_type)))
+			goto error;
+		break;
+	case MAXDSM_IOCTL_SET_PLATFORM_TYPE:
+		if (arg < PLATFORM_TYPE_A ||
+				arg > PLATFORM_TYPE_B)
+			goto error;
+		maxdsm.platform_type = arg;
+		ret = maxdsm.platform_type;
+		break;
+	default:
+		break;
+	}
+
+error:
+	mutex_unlock(&dsm_fs_lock);
+
+	return ret;
+}
+
+static long maxdsm_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	return maxdsm_ioctl_handler(file, cmd, arg,
+			(void __user *)arg);
+}
+
+#ifdef CONFIG_COMPAT
+static long maxdsm_compat_ioctl(struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	return maxdsm_ioctl_handler(file, cmd, arg,
+			(void __user *)(unsigned long)arg);
+}
+#endif /* CONFIG_COMPAT */
+
+static ssize_t maxdsm_read(struct file *filep, char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	int ret;
+
+	mutex_lock(&dsm_fs_lock);
+
+	maxdsm_read_all();
+
+	/* copy params to user */
+	ret = copy_to_user(buf, maxdsm.param, count);
+	if (ret)
+		pr_err("%s: copy_to_user failed - %d\n", __func__, ret);
+
+	mutex_unlock(&dsm_fs_lock);
+
+	return ret;
+}
+
+static ssize_t maxdsm_write(struct file *filep, const char __user *buf,
+		size_t count, loff_t *ppos)
+{
+	int ret = 0;
+
+	mutex_lock(&dsm_fs_lock);
+
+	if (copy_from_user(maxdsm.param, buf,
+			sizeof(uint32_t) * maxdsm.param_size)) {
+		pr_err("%s: Failed to copy user data.\n", __func__);
+		goto error;
 	}
 
-	if (param[PARAM_WRITE_FLAG] == FLAG_WRITE_ONOFF_ONLY \
-		|| param[PARAM_WRITE_FLAG] == FLAG_WRITE_ALL) {
+	switch (maxdsm.platform_type) {
+	case PLATFORM_TYPE_A:
+		/* We will check validation for parameter.
+		 * If received parameter from user is good,
+		 * it will be applied. */
+		dbg_maxdsm("reg=0x%x val=0x%x flag=%x regmap=%p",
+				maxdsm.param[0],
+				maxdsm.param[1],
+				maxdsm.param[2],
+				maxdsm.regmap);
+		ret = maxdsm_validation_check(maxdsm.param[2]);
+		if (!ret)
+			maxdsm_regmap_write(maxdsm.param[0], maxdsm.param[1]);
+		break;
+	case PLATFORM_TYPE_B:
+		ret = maxdsm_validation_check(maxdsm.param[PARAM_WRITE_FLAG]);
+		if (!ret) {
 		/* set params from the algorithm to application */
-		filter_set = DSM_ID_FILTER_SET_AFE_CNTRLS;
-		dsm_open(DSM_RX_PORT_ID, &filter_set, (u8 *) param);
+			maxdsm.filter_set = DSM_ID_FILTER_SET_AFE_CNTRLS;
+			maxdsm_dsm_open(&maxdsm);
+		}
+		break;
+	default:
+		dbg_maxdsm("Unknown platform type %d",
+				maxdsm.platform_type);
+		ret = -ENODATA;
+		break;
 	}
-	mutex_unlock(&dsm_lock);
 
-	return rc;
+error:
+	mutex_unlock(&dsm_fs_lock);
+
+	return ret;
 }
 
 static const struct file_operations dsm_ctrl_fops = {
 	.owner		= THIS_MODULE,
 	.open		= maxdsm_open,
 	.release	= NULL,
+	.unlocked_ioctl = maxdsm_ioctl,
+#ifdef CONFIG_COMPAT
+	.compat_ioctl	= maxdsm_compat_ioctl,
+#endif /* CONFIG_COMPAT */
 	.read		= maxdsm_read,
 	.write		= maxdsm_write,
 	.mmap		= NULL,
@@ -504,13 +2074,33 @@
 	.fops =     &dsm_ctrl_fops
 };
 
-int maxdsm_init(void)
+int maxdsm_deinit(void)
 {
-	memset(param, 0, sizeof(param));
-	return misc_register(&dsm_ctrl_miscdev);
+	kfree(maxdsm.binfo);
+	kfree(maxdsm.param);
+
+	return misc_deregister(&dsm_ctrl_miscdev);
 }
+EXPORT_SYMBOL_GPL(maxdsm_deinit);
 
-int maxdsm_deinit(void)
+int maxdsm_init(void)
 {
-	return misc_deregister(&dsm_ctrl_miscdev);
+	int ret;
+
+	if (maxdsm.registered) {
+		dbg_maxdsm("%s: Already registered.\n", __func__);
+		return -EALREADY;
+	}
+
+	ret = misc_register(&dsm_ctrl_miscdev);
+	if (!ret) {
+		maxdsm.registered = 1;
+		ret = maxdsm_update_param_info(&maxdsm);
+	}
+
+	return ret;
 }
\ No newline at end of file
+EXPORT_SYMBOL_GPL(maxdsm_init);
+
+MODULE_DESCRIPTION("Module for test Maxim DSM");
+MODULE_LICENSE("GPL");
diff -X dontdiff -Nuarb a/sound/soc/codecs/maxim_dsm_cal.c b/sound/soc/codecs/maxim_dsm_cal.c
--- a/sound/soc/codecs/maxim_dsm_cal.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/codecs/maxim_dsm_cal.c	2015-12-01 05:59:06.000000000 -0500
@@ -0,0 +1,637 @@
+/*
+ * maxim_dsm_cal.c -- Module for Rdc calibration
+ *
+ * Copyright 2014 Maxim Integrated Products
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 as
+ * published by the Free Software Foundation.
+ */
+
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/device.h>
+#include <linux/workqueue.h>
+#include <linux/moduleparam.h>
+#include <linux/slab.h>
+#include <linux/regmap.h>
+#include <linux/delay.h>
+#include <linux/uaccess.h>
+#include <linux/syscalls.h>
+#include <linux/file.h>
+#include <linux/fcntl.h>
+#include <linux/power_supply.h>
+#include <sound/maxim_dsm.h>
+#include <sound/maxim_dsm_cal.h>
+
+#define DEBUG_MAXIM_DSM_CAL
+#ifdef DEBUG_MAXIM_DSM_CAL
+#define dbg_maxdsm(format, args...)	\
+pr_info("[MAXIM_DSM_CAL] %s: " format "\n", __func__, ## args)
+#else
+#define dbg_maxdsm(format, args...)
+#endif /* DEBUG_MAXIM_DSM_CAL */
+
+struct class *g_class;
+
+struct maxim_dsm_cal *g_mdc;
+static int maxdsm_cal_read_file(char *filename, char *data, size_t size)
+{
+	struct file *cal_filp;
+	mm_segment_t old_fs = get_fs();
+	int ret;
+
+	set_fs(KERNEL_DS);
+	cal_filp = filp_open(filename, O_RDONLY, 0660);
+	if (IS_ERR(cal_filp)) {
+		pr_err("%s: there is no dsm_cal file\n", __func__);
+		set_fs(old_fs);
+		ret = 0;
+		return ret;
+	}
+	ret = cal_filp->f_op->read(cal_filp, data, size, &cal_filp->f_pos);
+	if (ret != size) {
+		pr_err("%s: can't read dsm calibration value to file\n",
+				__func__);
+		ret = -EIO;
+	}
+	filp_close(cal_filp, current->files);
+	set_fs(old_fs);
+
+	return ret;
+}
+
+static int maxdsm_cal_write_file(char *filename, char *data, size_t size)
+{
+	struct file *cal_filp;
+	mm_segment_t old_fs = get_fs();
+	int ret;
+
+	set_fs(KERNEL_DS);
+	cal_filp = filp_open(filename,
+			O_CREAT | O_TRUNC | O_WRONLY, 0660);
+	if (IS_ERR(cal_filp)) {
+		pr_err("%s: Can't open calibration file\n", __func__);
+		set_fs(old_fs);
+		ret = PTR_ERR(cal_filp);
+		return ret;
+	}
+	ret = cal_filp->f_op->write(cal_filp, data, size, &cal_filp->f_pos);
+	if (ret != size) {
+		pr_err("%s: can't write dsm calibration value to file\n",
+				__func__);
+		ret = -EIO;
+	}
+	filp_close(cal_filp, current->files);
+	set_fs(old_fs);
+
+	return ret;
+}
+
+struct regmap *maxdsm_cal_set_regmap(
+		struct regmap *regmap)
+{
+	g_mdc->regmap = regmap;
+#if defined(CONFIG_SND_SOC_MAXIM_DSM) && defined(USE_DSM_LOG)
+	maxdsm_set_regmap(g_mdc->regmap);
+#endif /* CONFIG_SND_SOC_MAXIM_DSM && USE_DSM_LOG */
+	return g_mdc->regmap;
+}
+EXPORT_SYMBOL_GPL(maxdsm_cal_set_regmap);
+
+int maxdsm_cal_set_temp(uint32_t value)
+{
+	char data[12];
+	int ret;
+
+	memset(data, 0x00, sizeof(data));
+	sprintf(data, "%x", value);
+	ret = maxdsm_cal_write_file(FILEPATH_TEMP_CAL,
+			data, sizeof(data));
+	g_mdc->values.temp = ret < 0 ? ret : value;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(maxdsm_cal_set_temp);
+
+int maxdsm_cal_get_temp(uint32_t *value)
+{
+	char data[12];
+	int ret;
+
+	memset(data, 0x00, sizeof(data));
+	ret = maxdsm_cal_read_file(FILEPATH_TEMP_CAL,
+			data, sizeof(data));
+	if (ret < 0)
+		g_mdc->values.temp = ret;
+	else
+		ret = kstrtos32(data, 16, value);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(maxdsm_cal_get_temp);
+
+int maxdsm_cal_set_rdc(uint32_t value)
+{
+	char data[12];
+	int ret;
+
+	memset(data, 0x00, sizeof(data));
+	sprintf(data, "%x", value);
+	ret = maxdsm_cal_write_file(FILEPATH_RDC_CAL,
+			data, sizeof(data));
+	g_mdc->values.rdc = ret < 0 ? ret : value;
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(maxdsm_cal_set_rdc);
+
+int maxdsm_cal_get_rdc(uint32_t *value)
+{
+	char data[12];
+	int ret;
+
+	memset(data, 0x00, sizeof(data));
+	ret = maxdsm_cal_read_file(FILEPATH_RDC_CAL,
+			data, sizeof(data));
+	if (ret < 0)
+		g_mdc->values.rdc = ret;
+	else
+		ret = kstrtos32(data, 16, value);
+
+	return ret;
+}
+EXPORT_SYMBOL_GPL(maxdsm_cal_get_rdc);
+
+static int maxdsm_cal_regmap_write(struct regmap *regmap,
+		unsigned int reg,
+		unsigned int val)
+{
+	return regmap ?
+		regmap_write(g_mdc->regmap, reg, val) : -ENXIO;
+}
+
+static int maxdsm_cal_regmap_read(struct regmap *regmap,
+		unsigned int reg,
+		unsigned int *val)
+{
+	return regmap ?
+		regmap_read(g_mdc->regmap, reg, val) : -ENXIO;
+}
+
+static void maxdsm_cal_start_calibration(
+		struct maxim_dsm_cal *mdc)
+{
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+	mdc->platform_type = maxdsm_get_platform_type();
+#else
+	mdc->platform_type = 0;
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+	dbg_maxdsm("platform_type=%d", mdc->platform_type);
+
+	switch (mdc->platform_type) {
+	case PLATFORM_TYPE_A:
+		maxdsm_cal_regmap_read(mdc->regmap,
+				ADDR_FEATURE_ENABLE,
+				&mdc->info.feature_en);
+		maxdsm_cal_regmap_write(mdc->regmap,
+				ADDR_FEATURE_ENABLE,
+				0x3F);
+		break;
+	case PLATFORM_TYPE_B:
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+		maxdsm_set_feature_en(1);
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+		break;
+	default:
+		break;
+	}
+
+	mdc->info.previous_jiffies = jiffies;
+}
+
+static uint32_t maxdsm_cal_read_dcresistance(
+		struct maxim_dsm_cal *mdc)
+{
+	uint32_t dcresistance = 0;
+
+	switch (mdc->platform_type) {
+	case PLATFORM_TYPE_A:
+		maxdsm_cal_regmap_read(mdc->regmap,
+				ADDR_RDC,
+				&dcresistance);
+		break;
+	case PLATFORM_TYPE_B:
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+		dcresistance = maxdsm_get_dcresistance();
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+		break;
+	default:
+		break;
+	}
+
+	return dcresistance;
+}
+
+static void maxdsm_cal_end_calibration(
+		struct maxim_dsm_cal *mdc)
+{
+	switch (mdc->platform_type) {
+	case PLATFORM_TYPE_A:
+		maxdsm_cal_regmap_write(mdc->regmap,
+				ADDR_FEATURE_ENABLE,
+				mdc->info.feature_en);
+		break;
+	case PLATFORM_TYPE_B:
+#ifdef CONFIG_SND_SOC_MAXIM_DSM
+		maxdsm_set_rdc_temp(mdc->values.rdc,
+				(uint32_t)mdc->values.temp / 10);
+		maxdsm_set_feature_en(0);
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
+		break;
+	default:
+		break;
+	}
+}
+
+static int maxdsm_cal_get_temp_from_power_supply(void)
+{
+	union power_supply_propval value = {0,};
+	struct power_supply *psy;
+	int temperature;
+
+	psy = power_supply_get_by_name("battery");
+	if (!psy) {
+		pr_err("%s: Failed to get psy\n", __func__);
+		temperature = 23 * 10;
+	} else {
+		psy->get_property(psy, POWER_SUPPLY_PROP_TEMP, &value);
+		temperature = value.intval;
+	}
+	dbg_maxdsm("temperature=%d", temperature);
+
+	return temperature;
+}
+
+static void maxdsm_cal_completed(struct maxim_dsm_cal *mdc)
+{
+	char rdc[12] = {0,};
+	char temp[12] = {0,};
+	int ret;
+
+	/* We try to get ambient temp by using power supply core */
+	mdc->values.temp = maxdsm_cal_get_temp_from_power_supply();
+
+	sprintf(rdc, "%x", mdc->values.rdc);
+	sprintf(temp, "%x",
+			mdc->values.temp < 0 ? 23 * 10 : mdc->values.temp);
+
+	ret = maxdsm_cal_write_file(
+			FILEPATH_TEMP_CAL, temp, sizeof(temp));
+	if (ret < 0)
+		mdc->values.temp = ret;
+
+	ret = maxdsm_cal_write_file(
+			FILEPATH_RDC_CAL, rdc, sizeof(rdc));
+	if (ret < 0)
+		mdc->values.rdc = ret;
+
+	maxdsm_cal_end_calibration(mdc);
+
+	mdc->values.status = 0;
+
+	dbg_maxdsm("temp=%d rdc=%d", mdc->values.temp, mdc->values.rdc);
+}
+
+static void maxdsm_cal_work(struct work_struct *work)
+{
+	struct maxim_dsm_cal *mdc;
+	unsigned int dcresistance = 0;
+	unsigned long diff;
+
+	mdc = container_of(work, struct maxim_dsm_cal, work.work);
+
+	mutex_lock(&mdc->mutex);
+
+	dcresistance = maxdsm_cal_read_dcresistance(mdc);
+	if (!(mdc->info.min > dcresistance
+				|| mdc->info.max < dcresistance) &&
+			((mdc->info.duration - mdc->info.remaining)
+			> mdc->info.ignored_t)) {
+		mdc->values.avg += dcresistance;
+		mdc->values.count++;
+	}
+
+	diff = jiffies - mdc->info.previous_jiffies;
+	mdc->info.remaining
+		-= jiffies_to_msecs(diff);
+
+	dbg_maxdsm("dcresistance=%d remaining=%d duration=%d",
+			dcresistance,
+			mdc->info.remaining,
+			mdc->info.duration);
+
+	if (mdc->info.remaining > 0
+			&& mdc->values.status) {
+		mdc->info.previous_jiffies = jiffies;
+		queue_delayed_work(mdc->wq,
+				&mdc->work,
+				msecs_to_jiffies(mdc->info.interval));
+	} else {
+		mdc->values.count > 0 ?
+			do_div(mdc->values.avg, mdc->values.count) : 0;
+		mdc->values.rdc = mdc->values.avg;
+		maxdsm_cal_completed(mdc);
+	}
+
+	mutex_unlock(&mdc->mutex);
+}
+
+static void maxdsm_cal_check(
+		struct maxim_dsm_cal *mdc, int action)
+{
+	if (delayed_work_pending(&mdc->work))
+		cancel_delayed_work(&mdc->work);
+
+	if (action) {
+		mdc->info.remaining = mdc->info.duration;
+		mdc->values.count = mdc->values.avg = 0;
+		maxdsm_cal_start_calibration(mdc);
+		queue_delayed_work(mdc->wq,
+				&mdc->work,
+				1);
+	}
+}
+
+static ssize_t maxdsm_cal_min_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", g_mdc->info.min);
+}
+
+static ssize_t maxdsm_cal_min_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (kstrtou32(buf, 0, &g_mdc->info.min))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	return size;
+}
+static DEVICE_ATTR(min, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_min_show, maxdsm_cal_min_store);
+
+static ssize_t maxdsm_cal_max_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", g_mdc->info.max);
+}
+
+static ssize_t maxdsm_cal_max_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (kstrtou32(buf, 0, &g_mdc->info.max))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	return size;
+}
+static DEVICE_ATTR(max, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_max_show, maxdsm_cal_max_store);
+
+static ssize_t maxdsm_cal_duration_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", g_mdc->info.duration);
+}
+
+static ssize_t maxdsm_cal_duration_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (kstrtou32(buf, 0, &g_mdc->info.duration))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	return size;
+}
+static DEVICE_ATTR(duration, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_duration_show, maxdsm_cal_duration_store);
+
+static ssize_t maxdsm_cal_rdc_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	char rdc[12] = {0,};
+	int ret;
+
+	if (g_mdc->values.rdc == 0xFFFFFFFF) {
+		ret = maxdsm_cal_read_file(
+				FILEPATH_RDC_CAL, rdc, sizeof(rdc));
+		if (ret < 0)
+			g_mdc->values.rdc = ret;
+		else
+			ret = kstrtos32(rdc, 16, &g_mdc->values.rdc);
+	}
+
+	return sprintf(buf, "%x", g_mdc->values.rdc);
+}
+
+static ssize_t maxdsm_cal_rdc_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	char rdc[12] = {0,};
+	int ret;
+
+	if (kstrtos32(buf, 0, &g_mdc->values.rdc))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	else {
+		sprintf(rdc, "%x", g_mdc->values.rdc);
+		ret = maxdsm_cal_write_file(
+				FILEPATH_RDC_CAL, rdc, sizeof(rdc));
+		if (ret < 0)
+			g_mdc->values.rdc = ret;
+	}
+
+	return size;
+}
+static DEVICE_ATTR(rdc, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_rdc_show, maxdsm_cal_rdc_store);
+
+static ssize_t maxdsm_cal_temp_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	char temp[12] = {0,};
+	int ret;
+
+	if (g_mdc->values.temp == 0xFFFFFFFF) {
+		ret = maxdsm_cal_read_file(
+				FILEPATH_TEMP_CAL, temp, sizeof(temp));
+		if (ret < 0)
+			g_mdc->values.temp = ret;
+		else
+			ret = kstrtos32(temp, 16, &g_mdc->values.temp);
+	}
+
+	return sprintf(buf, "%x", g_mdc->values.temp);
+}
+
+static ssize_t maxdsm_cal_temp_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	char temp[12] = {0,};
+	int ret;
+
+	if (kstrtos32(buf, 0, &g_mdc->values.temp))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	else {
+		sprintf(temp, "%x", g_mdc->values.temp);
+		ret = maxdsm_cal_write_file(
+				FILEPATH_TEMP_CAL, temp, sizeof(temp));
+		if (ret < 0)
+			g_mdc->values.temp = ret;
+	}
+
+	return size;
+}
+static DEVICE_ATTR(temp, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_temp_show, maxdsm_cal_temp_store);
+
+static ssize_t maxdsm_cal_interval_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", g_mdc->info.interval);
+}
+
+static ssize_t maxdsm_cal_interval_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (kstrtou32(buf, 0, &g_mdc->info.interval))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	return size;
+}
+static DEVICE_ATTR(interval, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_interval_show, maxdsm_cal_interval_store);
+
+static ssize_t maxdsm_cal_ignored_t_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d", g_mdc->info.ignored_t);
+}
+
+static ssize_t maxdsm_cal_ignored_t_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	if (kstrtou32(buf, 0, &g_mdc->info.ignored_t))
+		dev_err(dev,
+			"%s: Failed converting from str to u32.\n", __func__);
+	return size;
+}
+static DEVICE_ATTR(ignored_t, S_IRUGO | S_IWUSR | S_IWGRP,
+		maxdsm_cal_ignored_t_show, maxdsm_cal_ignored_t_store);
+
+static ssize_t maxdsm_cal_status_show(struct device *dev,
+	struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%s\n",
+			g_mdc->values.status ? "Enabled" : "Disabled");
+}
+
+static ssize_t maxdsm_cal_status_store(struct device *dev,
+	struct device_attribute *attr, const char *buf, size_t size)
+{
+	int status = 0;
+
+	if (!kstrtou32(buf, 0, &status)) {
+		if (status == g_mdc->values.status) {
+			dbg_maxdsm("Already run. It will be ignored.");
+		} else {
+			mutex_lock(&g_mdc->mutex);
+			g_mdc->values.status = status;
+			mutex_unlock(&g_mdc->mutex);
+			if (g_mdc->values.status)
+				maxdsm_cal_check(g_mdc, 1);
+			else
+				maxdsm_cal_check(g_mdc, 0);
+		}
+	}
+
+	return size;
+}
+static DEVICE_ATTR(status, S_IRUGO | S_IWUSR | S_IWGRP,
+	maxdsm_cal_status_show, maxdsm_cal_status_store);
+
+static struct attribute *maxdsm_cal_attr[] = {
+	&dev_attr_min.attr,
+	&dev_attr_max.attr,
+	&dev_attr_duration.attr,
+	&dev_attr_rdc.attr,
+	&dev_attr_temp.attr,
+	&dev_attr_interval.attr,
+	&dev_attr_ignored_t.attr,
+	&dev_attr_status.attr,
+	NULL,
+};
+
+static struct attribute_group maxdsm_cal_attr_grp = {
+	.attrs = maxdsm_cal_attr,
+};
+
+static int __init maxdsm_cal_init(void)
+{
+	struct maxim_dsm_cal *mdc;
+	int ret = 0;
+
+	g_mdc = kzalloc(sizeof(struct maxim_dsm_cal), GFP_KERNEL);
+	if (g_mdc == NULL)
+		return -ENOMEM;
+	mdc = g_mdc;
+
+	mdc->wq = create_singlethread_workqueue(WQ_NAME);
+	if (mdc->wq == NULL) {
+		kfree(g_mdc);
+		return -ENOMEM;
+	}
+
+	INIT_DELAYED_WORK(&g_mdc->work, maxdsm_cal_work);
+	mutex_init(&g_mdc->mutex);
+
+	mdc->info.min = 0;
+	mdc->info.max = 0xFFFFFFFF;
+	mdc->info.duration = 2000; /* 2 secs */
+	mdc->info.remaining = mdc->info.duration;
+	mdc->info.interval = 100;
+	mdc->info.ignored_t = 1000;
+	mdc->values.rdc = 0xFFFFFFFF;
+	mdc->values.temp = 0xFFFFFFFF;
+	mdc->platform_type = 0xFFFFFFFF;
+
+	if (!g_class)
+		g_class = class_create(THIS_MODULE, DSM_NAME);
+	mdc->class = g_class;
+	if (mdc->class) {
+		mdc->dev = device_create(mdc->class, NULL, 1, NULL, CLASS_NAME);
+		if (!IS_ERR(mdc->dev)) {
+			if (sysfs_create_group(&mdc->dev->kobj,
+						&maxdsm_cal_attr_grp))
+				dbg_maxdsm(
+						"Failed to create sysfs group. ret=%d",
+						ret);
+		}
+	}
+	dbg_maxdsm("g_class=%p %p", g_class, mdc->class);
+
+	dbg_maxdsm("Completed initialization");
+
+	return ret;
+}
+module_init(maxdsm_cal_init);
+
+static void __exit maxdsm_cal_exit(void)
+{
+	kfree(g_mdc);
+}
+module_exit(maxdsm_cal_exit);
+
+MODULE_DESCRIPTION(DRIVER_DESC);
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_SUPPORTED_DEVICE(DRIVER_SUPPORTED);
+MODULE_LICENSE("GPL");
diff -X dontdiff -Nuarb a/sound/soc/codecs/maxim_dsm.h b/sound/soc/codecs/maxim_dsm.h
--- a/sound/soc/codecs/maxim_dsm.h	2016-01-06 15:00:44.614590653 -0500
+++ b/sound/soc/codecs/maxim_dsm.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,21 +0,0 @@
-#ifndef _MAXIM_DSM_H
-#define _MAXIM_DSM_H
-
-#define DSM_RX_PORT_ID	0x1004
-
-extern int dsm_misc_device_init(void);
-extern int dsm_misc_device_deinit(void);
-
-extern int maxim_dsm_status_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol);
-extern int maxim_dsm_status_set(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol);
-extern int maxim_dsm_dump_get(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol);
-
-extern int maxim_dsm_dump_set(struct snd_kcontrol *kcontrol,
-				struct snd_ctl_elem_value *ucontrol);
-
-extern struct attribute_group maxim_attribute_group;
-
-#endif
diff -X dontdiff -Nuarb a/sound/soc/codecs/msm8x10-wcd.c b/sound/soc/codecs/msm8x10-wcd.c
--- a/sound/soc/codecs/msm8x10-wcd.c	2016-01-06 15:00:44.615590653 -0500
+++ b/sound/soc/codecs/msm8x10-wcd.c	2015-12-01 05:58:58.000000000 -0500
@@ -35,10 +35,10 @@
 #include <sound/tlv.h>
 #include <mach/qdsp6v2/apr.h>
 #include <mach/subsystem_notif.h>
+#include <sound/q6core.h>
 #include "msm8x10-wcd.h"
 #include "wcd9xxx-resmgr.h"
 #include "msm8x10_wcd_registers.h"
-#include "../msm/qdsp6v2/q6core.h"
 #include "wcd9xxx-common.h"
 
 #define MSM8X10_WCD_RATES (SNDRV_PCM_RATE_8000 | SNDRV_PCM_RATE_16000 |\
@@ -1691,20 +1691,22 @@
 	char *internal1_text = "Internal1";
 	char *internal2_text = "Internal2";
 	char *internal3_text = "Internal3";
+	char *external_text = "External";
 	enum wcd9xxx_notify_event e_post_off, e_pre_on, e_post_on;
 
 	dev_dbg(codec->dev, "%s %d\n", __func__, event);
-	switch (w->reg) {
-	case MSM8X10_WCD_A_MICB_1_CTL:
+
+	if ((strnstr(w->name, internal1_text, 30)) ||
+	    (strnstr(w->name, internal2_text, 30)) ||
+	    (strnstr(w->name, internal3_text, 30)) ||
+	    (strnstr(w->name, external_text, 30))) {
 		micb_int_reg = MSM8X10_WCD_A_MICB_1_INT_RBIAS;
 		e_pre_on = WCD9XXX_EVENT_PRE_MICBIAS_1_ON;
 		e_post_on = WCD9XXX_EVENT_POST_MICBIAS_1_ON;
 		e_post_off = WCD9XXX_EVENT_POST_MICBIAS_1_OFF;
-		break;
-	default:
+	} else {
 		dev_err(codec->dev,
-			"%s: Error, invalid micbias register 0x%x\n",
-			__func__, w->reg);
+			"%s: Error, invalid micbias %s\n", __func__, w->name);
 		return -EINVAL;
 	}
 
@@ -1722,9 +1724,9 @@
 
 		/* Always pull up TxFe for TX2 to Micbias */
 		snd_soc_update_bits(codec, micb_int_reg, 0x04, 0x04);
+		if (++msm8x10_wcd->micb_en_count == 1)
 		snd_soc_update_bits(codec, MSM8X10_WCD_A_MICB_1_CTL,
 					0x80, 0x80);
-		msm8x10_wcd->micb_en_count++;
 		pr_debug("%s micb_en_count : %d", __func__,
 				msm8x10_wcd->micb_en_count);
 		break;
@@ -1734,12 +1736,11 @@
 		wcd9xxx_resmgr_notifier_call(&msm8x10_wcd->resmgr, e_post_on);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
-		if (msm8x10_wcd->micb_en_count > 0)
-			msm8x10_wcd->micb_en_count--;
-		pr_debug("%s micb_en_count : %d", __func__,
-				msm8x10_wcd->micb_en_count);
+		if (--msm8x10_wcd->micb_en_count == 0)
 		snd_soc_update_bits(codec, MSM8X10_WCD_A_MICB_1_CTL,
 					0x80, 0x00);
+		pr_debug("%s micb_en_count : %d", __func__,
+				msm8x10_wcd->micb_en_count);
 		/* Let MBHC module know so micbias switch to be off */
 		wcd9xxx_resmgr_notifier_call(&msm8x10_wcd->resmgr, e_post_off);
 
@@ -2553,7 +2554,7 @@
 
 	SND_SOC_DAPM_INPUT("AMIC1"),
 	SND_SOC_DAPM_MICBIAS_E("MIC BIAS Internal1",
-		MSM8X10_WCD_A_MICB_1_CTL, 7, 0,
+		SND_SOC_NOPM, 7, 0,
 		msm8x10_wcd_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
 		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 #if defined(CONFIG_SEC_HEAT_PROJECT) /*Remove Intenal mic bias2*/
@@ -2563,20 +2564,20 @@
 		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 #else
 	SND_SOC_DAPM_MICBIAS_E("MIC BIAS Internal2",
-		MSM8X10_WCD_A_MICB_1_CTL, 7, 0,
+		SND_SOC_NOPM, 7, 0,
 		msm8x10_wcd_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
 		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 #endif
 	SND_SOC_DAPM_MICBIAS_E("MIC BIAS Internal3",
-		MSM8X10_WCD_A_MICB_1_CTL, 7, 0,
+		SND_SOC_NOPM, 7, 0,
 		msm8x10_wcd_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
 		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 	SND_SOC_DAPM_MICBIAS_E("MIC BIAS External",
-		MSM8X10_WCD_A_MICB_1_CTL, 7, 0,
+		SND_SOC_NOPM, 7, 0,
 		msm8x10_wcd_codec_enable_micbias, SND_SOC_DAPM_PRE_PMU |
 		SND_SOC_DAPM_POST_PMU | SND_SOC_DAPM_POST_PMD),
 	SND_SOC_DAPM_MICBIAS_E(DAPM_MICBIAS_EXTERNAL_STANDALONE,
-		MSM8X10_WCD_A_MICB_1_CTL,
+		SND_SOC_NOPM,
 		7, 0, msm8x10_wcd_codec_enable_micbias,
 		SND_SOC_DAPM_PRE_PMU | SND_SOC_DAPM_POST_PMU |
 		SND_SOC_DAPM_POST_PMD),
@@ -2864,7 +2865,6 @@
 					   enum wcd9xxx_micbias_num micb_num)
 {
 	int rc;
-	struct msm8x10_wcd_priv *msm8x10_wcd = snd_soc_codec_get_drvdata(codec);
 
 	if (micb_num != MBHC_MICBIAS1) {
 		rc = -EINVAL;
@@ -2875,12 +2875,6 @@
 		rc = snd_soc_dapm_force_enable_pin(&codec->dapm,
 			DAPM_MICBIAS_EXTERNAL_STANDALONE);
 	else {
-		if (msm8x10_wcd->micb_en_count > 1) {
-			msm8x10_wcd->micb_en_count--;
-			pr_debug("%s micb_en_count : %d", __func__,
-					msm8x10_wcd->micb_en_count);
-			return 0;
-		}
 		rc = snd_soc_dapm_disable_pin(&codec->dapm,
 			DAPM_MICBIAS_EXTERNAL_STANDALONE);
 	}
diff -X dontdiff -Nuarb a/sound/soc/codecs/wcd9306.c b/sound/soc/codecs/wcd9306.c
--- a/sound/soc/codecs/wcd9306.c	2016-01-06 15:00:44.621590653 -0500
+++ b/sound/soc/codecs/wcd9306.c	2015-12-01 05:58:58.000000000 -0500
@@ -1960,7 +1960,7 @@
 				1 << init_bit_shift);
 		break;
 	case SND_SOC_DAPM_POST_PMU:
-
+		usleep_range(2000, 2010);
 		snd_soc_update_bits(codec, adc_reg, 1 << init_bit_shift, 0x00);
 
 		break;
@@ -2035,15 +2035,20 @@
 						 WCD9XXX_CLSH_STATE_LO,
 						 WCD9XXX_CLSH_REQ_ENABLE,
 						 WCD9XXX_CLSH_EVENT_POST_PA);
-		dev_dbg(codec->dev, "%s: sleeping 3 ms after %s PA turn on\n",
+		dev_dbg(codec->dev, "%s: sleeping 5 ms after %s PA turn on\n",
 				__func__, w->name);
-		usleep_range(3000, 3010);
+		/* Wait for CnP time after PA enable */
+		usleep_range(5000, 5100);
 		break;
 	case SND_SOC_DAPM_POST_PMD:
 		wcd9xxx_clsh_fsm(codec, &tapan->clsh_d,
 						 WCD9XXX_CLSH_STATE_LO,
 						 WCD9XXX_CLSH_REQ_DISABLE,
 						 WCD9XXX_CLSH_EVENT_POST_PA);
+		dev_dbg(codec->dev, "%s: sleeping 5 ms after %s PA turn off\n",
+				__func__, w->name);
+		/* Wait for CnP time after PA enable */
+		usleep_range(5000, 5100);
 		break;
 	}
 	return 0;
@@ -2411,6 +2416,7 @@
 	dev_dbg(codec->dev, "%s(): decimator %u hpf_cut_of_freq 0x%x\n",
 		 __func__, hpf_work->decimator, (unsigned int)hpf_cut_of_freq);
 
+	snd_soc_update_bits(codec, TAPAN_A_TX_1_2_TXFE_CLKDIV, 0x55, 0x55);
 	snd_soc_update_bits(codec, tx_mux_ctl_reg, 0x30, hpf_cut_of_freq << 4);
 }
 
@@ -2503,7 +2509,8 @@
 
 		/* enable HPF */
 		snd_soc_update_bits(codec, tx_mux_ctl_reg , 0x08, 0x00);
-
+		snd_soc_update_bits(codec, TAPAN_A_TX_1_2_TXFE_CLKDIV,
+				0x55, 0x44);
 		break;
 
 	case SND_SOC_DAPM_POST_PMU:
diff -X dontdiff -Nuarb a/sound/soc/codecs/wcd9320.c b/sound/soc/codecs/wcd9320.c
--- a/sound/soc/codecs/wcd9320.c	2016-01-06 15:00:44.625590654 -0500
+++ b/sound/soc/codecs/wcd9320.c	2015-12-01 05:58:59.000000000 -0500
@@ -19,7 +19,6 @@
 #include <linux/ratelimit.h>
 #include <linux/debugfs.h>
 #include <linux/wait.h>
-#include <linux/bitops.h>
 #include <linux/mfd/wcd9xxx/core.h>
 #include <linux/mfd/wcd9xxx/wcd9xxx_registers.h>
 #include <linux/mfd/wcd9xxx/wcd9320_registers.h>
@@ -41,6 +40,7 @@
 #include "wcd9320.h"
 #include "wcd9xxx-resmgr.h"
 #include "wcd9xxx-common.h"
+#include "wcdcal-hwdep.h"
 
 #if defined(CONFIG_SND_SOC_ES705)
 #include "audience/es705-export.h"
@@ -477,6 +477,8 @@
 	 */
 	struct list_head reg_save_restore;
 	struct pm_qos_request pm_qos_req;
+	/* cal info for codec */
+	struct fw_info *fw_data;
 };
 
 static const u32 comp_shift[] = {
@@ -2177,6 +2179,8 @@
 static const struct snd_kcontrol_new aif4_mad_switch =
 	SOC_DAPM_SINGLE("Switch", TAIKO_A_CDC_CLK_OTHR_CTL, 4, 1, 0);
 
+static const struct snd_kcontrol_new aif4_vi_switch =
+	SOC_DAPM_SINGLE("Switch", TAIKO_A_SPKR_PROT_EN, 3, 1, 0);
 /* virtual port entries */
 static int slim_tx_mixer_get(struct snd_kcontrol *kcontrol,
 			     struct snd_ctl_elem_value *ucontrol)
@@ -2702,8 +2706,11 @@
 	int ret;
 	const struct firmware *fw;
 	struct mad_audio_cal *mad_cal;
+	struct firmware_cal *hwdep_cal = NULL;
+	const void *data;
 	const char *filename = TAIKO_MAD_AUDIO_FIRMWARE_PATH;
 	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
+	size_t cal_size;
 
 	pr_debug("%s: enter\n", __func__);
 	/* wakeup for codec calibration access */
@@ -2712,24 +2719,46 @@
 			   PM_QOS_DEFAULT_VALUE);
 	pm_qos_update_request(&taiko->pm_qos_req,
 			      msm_cpuidle_get_deep_idle_latency());
+	if (!taiko->fw_data) {
+		dev_err(codec->dev, "%s: invalid cal data\n",
+				 __func__);
+		return -ENODEV;
+	}
+	hwdep_cal = wcdcal_get_fw_cal(taiko->fw_data, WCD9XXX_MAD_CAL);
+	if (hwdep_cal) {
+		data = hwdep_cal->data;
+		cal_size = hwdep_cal->size;
+		dev_dbg(codec->dev, "%s: using hwdep calibration\n",
+				__func__);
+	} else {
 	ret = request_firmware(&fw, filename, codec->dev);
 	if (ret != 0) {
-		pr_err("Failed to acquire MAD firwmare data %s: %d\n", filename,
-		       ret);
+			pr_err("Failed to acquire MAD firwmare data %s: %d\n",
+				filename, ret);
 		return -ENODEV;
 	}
-
-	if (fw->size < sizeof(struct mad_audio_cal)) {
-		pr_err("%s: incorrect firmware size %u\n", __func__, fw->size);
-		release_firmware(fw);
-		return -ENOMEM;
+		if (!fw) {
+			dev_err(codec->dev, "failed to get mad fw");
+			return -ENODEV;
+		}
+		data = fw->data;
+		cal_size = fw->size;
+		dev_dbg(codec->dev, "%s: using request_firmware calibration\n",
+				__func__);
+	}
+	if (cal_size < sizeof(struct mad_audio_cal)) {
+		pr_err("%s: incorrect hwdep cal size %zu\n",
+			__func__, cal_size);
+		ret = -ENOMEM;
+		goto err;
 	}
 
-	mad_cal = (struct mad_audio_cal *)(fw->data);
+	mad_cal = (struct mad_audio_cal *)(data);
 	if (!mad_cal) {
-		pr_err("%s: Invalid calibration data\n", __func__);
-		release_firmware(fw);
-		return -EINVAL;
+		dev_err(codec->dev, "%s: Invalid calibration data\n",
+				__func__);
+		ret =  -EINVAL;
+		goto err;
 	}
 
 	snd_soc_write(codec, TAIKO_A_CDC_MAD_MAIN_CTL_2,
@@ -2779,11 +2808,13 @@
 	snd_soc_write(codec, TAIKO_A_CDC_MAD_ULTR_CTL_6,
 		      mad_cal->ultrasound_info.rms_threshold_msb);
 
-	release_firmware(fw);
 	pr_debug("%s: leave ret %d\n", __func__, ret);
 	pm_qos_update_request(&taiko->pm_qos_req,
 			      PM_QOS_DEFAULT_VALUE);
 	pm_qos_remove_request(&taiko->pm_qos_req);
+err:
+	if (!hwdep_cal)
+		release_firmware(fw);
 	return ret;
 }
 
@@ -3340,15 +3371,18 @@
 	const char *filename;
 	const struct firmware *fw;
 	int i;
-	int ret;
+	int ret =0;
 	int num_anc_slots;
 	struct wcd9xxx_anc_header *anc_head;
 	struct taiko_priv *taiko = snd_soc_codec_get_drvdata(codec);
+	struct firmware_cal *hwdep_cal = NULL;
 	u32 anc_writes_size = 0;
 	int anc_size_remaining;
 	u32 *anc_ptr;
 	u16 reg;
 	u8 mask, val, old_val;
+	size_t cal_size;
+	const void *data;
 
 
 	if (taiko->anc_func == 0)
@@ -3357,38 +3391,53 @@
 	switch (event) {
 	case SND_SOC_DAPM_PRE_PMU:
 		filename = "wcd9320/wcd9320_anc.bin";
-
+		hwdep_cal = wcdcal_get_fw_cal(taiko->fw_data, WCD9XXX_ANC_CAL);
+		if (hwdep_cal) {
+			data = hwdep_cal->data;
+			cal_size = hwdep_cal->size;
+			dev_dbg(codec->dev, "%s: using hwdep calibration\n",
+				__func__);
+		} else {
 		ret = request_firmware(&fw, filename, codec->dev);
 		if (ret != 0) {
 			dev_err(codec->dev, "Failed to acquire ANC data: %d\n",
 				ret);
 			return -ENODEV;
 		}
+			if (!fw) {
+				dev_err(codec->dev, "failed to get anc fw");
+				return -ENODEV;
+			}
+			data = fw->data;
+			cal_size = fw->size;
+			dev_dbg(codec->dev, "%s: using request_firmware calibration\n",
+					 __func__);
 
-		if (fw->size < sizeof(struct wcd9xxx_anc_header)) {
+		}
+
+		if (cal_size < sizeof(struct wcd9xxx_anc_header)) {
 			dev_err(codec->dev, "Not enough data\n");
-			release_firmware(fw);
-			return -ENOMEM;
+			goto err;
 		}
 
 		/* First number is the number of register writes */
-		anc_head = (struct wcd9xxx_anc_header *)(fw->data);
-		anc_ptr = (u32 *)((u32)fw->data +
+		anc_head = (struct wcd9xxx_anc_header *)(data);
+		anc_ptr = (u32 *)(data +
 				  sizeof(struct wcd9xxx_anc_header));
-		anc_size_remaining = fw->size -
+		anc_size_remaining = cal_size -
 				     sizeof(struct wcd9xxx_anc_header);
 		num_anc_slots = anc_head->num_anc_slots;
 
 		if (taiko->anc_slot >= num_anc_slots) {
 			dev_err(codec->dev, "Invalid ANC slot selected\n");
-			release_firmware(fw);
-			return -EINVAL;
+			ret = -EINVAL;
+			goto err;
 		}
 		for (i = 0; i < num_anc_slots; i++) {
 			if (anc_size_remaining < TAIKO_PACKED_REG_SIZE) {
 				dev_err(codec->dev, "Invalid register format\n");
-				release_firmware(fw);
-				return -EINVAL;
+				ret = -EINVAL;
+				goto err;
 			}
 			anc_writes_size = (u32)(*anc_ptr);
 			anc_size_remaining -= sizeof(u32);
@@ -3397,8 +3446,8 @@
 			if (anc_writes_size * TAIKO_PACKED_REG_SIZE
 				> anc_size_remaining) {
 				dev_err(codec->dev, "Invalid register format\n");
-				release_firmware(fw);
-				return -ENOMEM;
+				ret = -EINVAL;
+				goto err;
 			}
 
 			if (taiko->anc_slot == i)
@@ -3410,8 +3459,8 @@
 		}
 		if (i == num_anc_slots) {
 			dev_err(codec->dev, "Selected ANC slot not present\n");
-			release_firmware(fw);
-			return -ENOMEM;
+			ret = -EINVAL;
+			goto err;
 		}
 		for (i = 0; i < anc_writes_size; i++) {
 			TAIKO_CODEC_UNPACK_ENTRY(anc_ptr[i], reg,
@@ -3420,6 +3469,7 @@
 			snd_soc_write(codec, reg, (old_val & ~mask) |
 				(val & mask));
 		}
+		if (!hwdep_cal)
 		release_firmware(fw);
 		break;
 	case SND_SOC_DAPM_PRE_PMD:
@@ -3433,6 +3483,11 @@
 		break;
 	}
 	return 0;
+err:
+	if (!hwdep_cal)
+		release_firmware(fw);
+	return ret;
+
 }
 
 static int taiko_hph_pa_event(struct snd_soc_dapm_widget *w,
@@ -3598,7 +3653,9 @@
 	{"AIF1 CAP", NULL, "AIF1_CAP Mixer"},
 	{"AIF2 CAP", NULL, "AIF2_CAP Mixer"},
 	{"AIF3 CAP", NULL, "AIF3_CAP Mixer"},
-	{"AIF4 VI", NULL, "SPK_OUT"},
+	/* VI Feedback */
+	{"AIF4 VI", NULL, "VIONOFF"},
+	{"VIONOFF", "Switch", "VIINPUT"},
 
 	/* MAD */
 	{"AIF4 MAD", NULL, "CDC_CONN"},
@@ -5525,6 +5582,15 @@
 		if (ret)
 			pr_err("%s error in close_slim_sch_tx %d\n",
 				__func__, ret);
+		ret = taiko_codec_enable_slim_chmask(dai, false);
+		if (ret < 0) {
+			ret = wcd9xxx_disconnect_port(core,
+						      &dai->wcd9xxx_ch_list,
+						      dai->grph);
+			pr_debug("%s: Disconnect RX port, ret = %d\n",
+				 __func__, ret);
+		}
+
 		snd_soc_update_bits(codec, TAIKO_A_CDC_CLK_TX_CLK_EN_B2_CTL,
 				0xC, 0x0);
 		/*Disable V&I sensing*/
@@ -5705,6 +5771,25 @@
 	}
 	return ret;
 }
+#if 0
+static int taiko_codec_set_iir_gain(struct snd_soc_dapm_widget *w,
+	struct snd_kcontrol *kcontrol, int event)
+{
+	struct snd_soc_codec *codec = w->codec;
+	int value = 0;
+
+	switch (event) {
+	case SND_SOC_DAPM_POST_PMU:
+		value = snd_soc_read(codec, TAIKO_A_CDC_IIR1_GAIN_B1_CTL);
+		snd_soc_write(codec, TAIKO_A_CDC_IIR1_GAIN_B1_CTL, value);
+		break;
+	default:
+		pr_info("%s: event = %d not expected\n", __func__, event);
+		break;
+	}
+	return 0;
+}
+#endif
 
 /* Todo: Have seperate dapm widgets for I2S and Slimbus.
  * Might Need to have callbacks registered only for slimbus
@@ -6194,6 +6279,10 @@
 
 	SND_SOC_DAPM_MIXER("LINEOUT4_PA_MIXER", SND_SOC_NOPM, 0, 0,
 		lineout4_pa_mix, ARRAY_SIZE(lineout4_pa_mix)),
+	SND_SOC_DAPM_SWITCH("VIONOFF", SND_SOC_NOPM, 0, 0,
+			    &aif4_vi_switch),
+	SND_SOC_DAPM_INPUT("VIINPUT"),
+
 };
 
 static irqreturn_t taiko_slimbus_irq(int irq, void *data)
@@ -6833,6 +6922,27 @@
 
 	wcd9xxx_free_irq(core_res, WCD9XXX_IRQ_SLIMBUS, taiko);
 }
+static
+struct firmware_cal *taiko_get_hwdep_fw_cal(struct snd_soc_codec *codec,
+			enum wcd_cal_type type)
+{
+	struct taiko_priv *taiko;
+	struct firmware_cal *hwdep_cal;
+
+	if (!codec) {
+		pr_err("%s: NULL codec pointer\n", __func__);
+		return NULL;
+	}
+	taiko = snd_soc_codec_get_drvdata(codec);
+	hwdep_cal = wcdcal_get_fw_cal(taiko->fw_data, type);
+	if (!hwdep_cal) {
+		dev_err(codec->dev, "%s: cal not sent by %d\n",
+				 __func__, type);
+		return NULL;
+	}
+
+	return hwdep_cal;
+}
 
 int taiko_hs_detect(struct snd_soc_codec *codec,
 		    struct wcd9xxx_mbhc_config *mbhc_cfg)
@@ -7087,6 +7197,7 @@
 	.get_cdc_type = taiko_get_cdc_type,
 	.setup_zdet = taiko_setup_zdet,
 	.compute_impedance = taiko_compute_impedance,
+	.get_hwdep_fw_cal = taiko_get_hwdep_fw_cal,
 };
 
 static const struct wcd9xxx_mbhc_intr cdc_intr_ids = {
@@ -7116,6 +7227,18 @@
 
 	mutex_lock(&codec->mutex);
 
+        if (codec->reg_def_copy) {
+            pr_debug("%s: Update ASOC cache", __func__);
+            kfree(codec->reg_cache);
+            codec->reg_cache = kmemdup(codec->reg_def_copy,
+                                            codec->reg_size, GFP_KERNEL);
+            if (!codec->reg_cache) {
+                pr_err("%s: Cache update failed!\n", __func__);
+                mutex_unlock(&codec->mutex);
+                return -ENOMEM;
+            }
+        }
+
 	taiko_update_reg_defaults(codec);
 	if (wcd9xxx->mclk_rate == TAIKO_MCLK_CLK_12P288MHZ)
 		snd_soc_update_bits(codec, TAIKO_A_CHIP_CTL, 0x06, 0x0);
@@ -7331,7 +7454,7 @@
 				  WCD9XXX_CDC_TYPE_TAIKO);
 	if (ret) {
 		pr_err("%s: wcd9xxx init failed %d\n", __func__, ret);
-		goto err_init;
+		goto err_nomem_slimch;
 	}
 
 	taiko->clsh_d.buck_mv = taiko_codec_get_buck_mv(codec);
@@ -7343,6 +7466,20 @@
 		rco_clk_rate = TAIKO_MCLK_CLK_12P288MHZ;
 	else
 		rco_clk_rate = TAIKO_MCLK_CLK_9P6MHZ;
+	taiko->fw_data = kzalloc(sizeof(*(taiko->fw_data)), GFP_KERNEL);
+	if (!taiko->fw_data) {
+		dev_err(codec->dev, "Failed to allocate fw_data\n");
+		goto err_nomem_slimch;
+	}
+	set_bit(WCD9XXX_ANC_CAL, taiko->fw_data->cal_bit);
+	set_bit(WCD9XXX_MAD_CAL, taiko->fw_data->cal_bit);
+	set_bit(WCD9XXX_MBHC_CAL, taiko->fw_data->cal_bit);
+	ret = wcd_cal_create_hwdep(taiko->fw_data,
+					WCD9XXX_CODEC_HWDEP_NODE, codec);
+	if (ret < 0) {
+		dev_err(codec->dev, "%s hwdep failed %d\n", __func__, ret);
+		goto err_hwdep;
+	}
 
 #if defined(CONFIG_MACH_KLTE_KOR)
 	if (system_rev >= 13) {
@@ -7353,7 +7490,7 @@
 					rco_clk_rate, false);
 		if (ret) {
 			pr_err("%s: mbhc init failed %d\n", __func__, ret);
-			goto err_init;
+			goto err_hwdep;
 		}
 	}
 #elif defined(CONFIG_MACH_KLTE_JPN)
@@ -7365,7 +7502,7 @@
 					rco_clk_rate, false);
 		if (ret) {
 			pr_err("%s: mbhc init failed %d\n", __func__, ret);
-			goto err_init;
+			goto err_hwdep;
 		}
 	}
 #else
@@ -7377,7 +7514,7 @@
 				rco_clk_rate, false);
 	if (ret) {
 		pr_err("%s: mbhc init failed %d\n", __func__, ret);
-		goto err_init;
+		goto err_hwdep;
 	}
 #elif defined(CONFIG_SEC_JACTIVE_PROJECT)
 /* init and start mbhc */
@@ -7390,7 +7527,7 @@
                     rco_clk_rate, false);
         if (ret) {
             pr_err("%s: mbhc init failed %d\n", __func__, ret);
-            goto err_init;
+            goto err_hwdep;
         }
 	}
 #endif
@@ -7417,7 +7554,7 @@
 	ret = taiko_handle_pdata(taiko);
 	if (IS_ERR_VALUE(ret)) {
 		pr_err("%s: bad pdata\n", __func__);
-		goto err_pdata;
+		goto err_hwdep;
 	}
 
 	taiko->spkdrv_reg = taiko_codec_find_regulator(codec,
@@ -7441,7 +7578,7 @@
 	if (!ptr) {
 		pr_err("%s: no mem for slim chan ctl data\n", __func__);
 		ret = -ENOMEM;
-		goto err_nomem_slimch;
+		goto err_hwdep;
 	}
 
 	if (taiko->intf_type == WCD9XXX_INTERFACE_TYPE_I2C) {
@@ -7519,11 +7656,11 @@
 
 err_irq:
 	taiko_cleanup_irqs(taiko);
-err_pdata:
 	kfree(ptr);
+err_hwdep:
+	kfree(taiko->fw_data);
 err_nomem_slimch:
 	kfree(taiko);
-err_init:
 	return ret;
 }
 static int taiko_codec_remove(struct snd_soc_codec *codec)
@@ -7569,6 +7706,7 @@
 
 	taiko->spkdrv_reg = NULL;
 
+	kfree(taiko->fw_data);
 	kfree(taiko);
 	return 0;
 }
diff -X dontdiff -Nuarb a/sound/soc/codecs/wcd9xxx-mbhc.c b/sound/soc/codecs/wcd9xxx-mbhc.c
--- a/sound/soc/codecs/wcd9xxx-mbhc.c	2016-01-06 15:00:44.626590654 -0500
+++ b/sound/soc/codecs/wcd9xxx-mbhc.c	2015-12-01 05:59:07.000000000 -0500
@@ -36,6 +36,7 @@
 #include <linux/kernel.h>
 #include <linux/gpio.h>
 #include <linux/input.h>
+#include "wcdcal-hwdep.h"
 #include "wcd9320.h"
 #include "wcd9306.h"
 #include "wcd9xxx-mbhc.h"
@@ -75,7 +76,7 @@
 #define OCP_ATTEMPT 1
 
 #define FW_READ_ATTEMPTS 15
-#define FW_READ_TIMEOUT 2000000
+#define FW_READ_TIMEOUT 4000000
 
 #define BUTTON_POLLING_SUPPORTED true
 
@@ -189,6 +190,10 @@
 
 static void wcd9xxx_mbhc_calc_thres(struct wcd9xxx_mbhc *mbhc);
 
+static u16 wcd9xxx_codec_v_sta_dce(struct wcd9xxx_mbhc *mbhc,
+				   enum meas_type dce, s16 vin_mv,
+				   bool cs_enable);
+
 static bool wcd9xxx_mbhc_polling(struct wcd9xxx_mbhc *mbhc)
 {
 	return (snd_soc_read(mbhc->codec, WCD9XXX_A_CDC_MBHC_EN_CTL) & 0x1);
@@ -1148,10 +1153,6 @@
 	struct snd_soc_codec *codec = mbhc->codec;
 	short bias_value;
 	u8 cfilt_mode;
-	s16 reg;
-	int change;
-	struct wcd9xxx_mbhc_btn_detect_cfg *btn_det;
-	s16 sta_z = 0, dce_z = 0;
 
 	WCD9XXX_BCL_ASSERT_LOCKED(mbhc->resmgr);
 
@@ -1161,7 +1162,6 @@
 		return -ENODEV;
 	}
 
-	btn_det = WCD9XXX_MBHC_CAL_BTN_DET_PTR(mbhc->mbhc_cfg->calibration);
 	/* Enable external voltage source to micbias if present */
 	if (mbhc->mbhc_cb && mbhc->mbhc_cb->enable_mb_source)
 		mbhc->mbhc_cb->enable_mb_source(codec, true, true);
@@ -1221,6 +1221,21 @@
 	snd_soc_write(codec, mbhc_micb_regs->cfilt_ctl, cfilt_mode);
 	snd_soc_update_bits(codec, WCD9XXX_A_MBHC_HPH, 0x13, 0x00);
 
+	return bias_value;
+}
+
+static void wcd9xxx_recalibrate(struct wcd9xxx_mbhc *mbhc,
+				struct mbhc_micbias_regs *mbhc_micb_regs,
+				bool is_cs_enable)
+{
+	struct snd_soc_codec *codec = mbhc->codec;
+	s16 reg;
+	int change;
+	struct wcd9xxx_mbhc_btn_detect_cfg *btn_det;
+	s16 sta_z = 0, dce_z = 0;
+
+	btn_det = WCD9XXX_MBHC_CAL_BTN_DET_PTR(mbhc->mbhc_cfg->calibration);
+
 	if (mbhc->mbhc_cfg->do_recalibration) {
 		/* recalibrate dce_z and sta_z */
 		reg = snd_soc_read(codec, WCD9XXX_A_CDC_MBHC_B1_CTL);
@@ -1255,17 +1270,24 @@
 			snd_soc_write(mbhc->codec, WCD9XXX_A_CDC_MBHC_B1_CTL,
 				      reg);
 			if (dce_z) {
-				pr_debug("%s: dce_nsc_cs_z 0x%x -> 0x%x\n",
-					 __func__, mbhc->mbhc_data.dce_nsc_cs_z,
-					 dce_z & 0xffff);
 				mbhc->mbhc_data.dce_nsc_cs_z = dce_z;
+				/* update v_cs_ins_h with new dce_nsc_cs_z */
+				mbhc->mbhc_data.v_cs_ins_h =
+						wcd9xxx_codec_v_sta_dce(
+							mbhc, DCE,
+							WCD9XXX_V_CS_HS_MAX,
+							is_cs_enable);
+				pr_debug("%s: dce_nsc_cs_z 0x%x -> 0x%x, v_cs_ins_h 0x%x\n",
+					  __func__,
+					  mbhc->mbhc_data.dce_nsc_cs_z,
+					  dce_z & 0xffff,
+					  mbhc->mbhc_data.v_cs_ins_h);
 			} else {
 				pr_debug("%s: failed get new dce_nsc_cs_z\n",
 					 __func__);
 			}
 		}
 	}
-	return bias_value;
 }
 
 static void wcd9xxx_shutdown_hs_removal_detect(struct wcd9xxx_mbhc *mbhc)
@@ -1822,6 +1844,9 @@
 			wcd9xxx_codec_hphr_gnd_switch(codec, false);
 	}
 
+	/* recalibrate DCE/STA GND voltages */
+	wcd9xxx_recalibrate(mbhc, &mbhc->mbhc_bias_regs, true);
+
 	type = wcd9xxx_cs_find_plug_type(mbhc, rt, ARRAY_SIZE(rt), highhph,
 					 mbhc->event_state);
 
@@ -1902,6 +1927,8 @@
 		if (rt[i].swap_gnd)
 			wcd9xxx_codec_hphr_gnd_switch(codec, false);
 	}
+	/* recalibrate DCE/STA GND voltages */
+	wcd9xxx_recalibrate(mbhc, &mbhc->mbhc_bias_regs, false);
 
 	if (vddioon)
 		__wcd9xxx_switch_micbias(mbhc, 1, false, false);
@@ -2812,35 +2839,39 @@
 	wcd9xxx_unlock_sleep(core_res);
 }
 
-static bool wcd9xxx_mbhc_fw_validate(const struct firmware *fw)
+static bool wcd9xxx_mbhc_fw_validate(const void *data, size_t size)
 {
 	u32 cfg_offset;
 	struct wcd9xxx_mbhc_imped_detect_cfg *imped_cfg;
 	struct wcd9xxx_mbhc_btn_detect_cfg *btn_cfg;
+	struct firmware_cal fw;
+
+	fw.data = (void *)data;
+	fw.size = size;
 
-	if (fw->size < WCD9XXX_MBHC_CAL_MIN_SIZE)
+	if (fw.size < WCD9XXX_MBHC_CAL_MIN_SIZE)
 		return false;
 
 	/*
 	 * Previous check guarantees that there is enough fw data up
 	 * to num_btn
 	 */
-	btn_cfg = WCD9XXX_MBHC_CAL_BTN_DET_PTR(fw->data);
-	cfg_offset = (u32) ((void *) btn_cfg - (void *) fw->data);
-	if (fw->size < (cfg_offset + WCD9XXX_MBHC_CAL_BTN_SZ(btn_cfg)))
+        btn_cfg = WCD9XXX_MBHC_CAL_BTN_DET_PTR(fw.data);
+        cfg_offset = (u32) ((void *) btn_cfg - (void *) fw.data);
+        if (fw.size < (cfg_offset + WCD9XXX_MBHC_CAL_BTN_SZ(btn_cfg)))
 		return false;
 
 	/*
 	 * Previous check guarantees that there is enough fw data up
 	 * to start of impedance detection configuration
 	 */
-	imped_cfg = WCD9XXX_MBHC_CAL_IMPED_DET_PTR(fw->data);
-	cfg_offset = (u32) ((void *) imped_cfg - (void *) fw->data);
+        imped_cfg = WCD9XXX_MBHC_CAL_IMPED_DET_PTR(fw.data);
+        cfg_offset = (u32) ((void *) imped_cfg - (void *) fw.data);
 
-	if (fw->size < (cfg_offset + WCD9XXX_MBHC_CAL_IMPED_MIN_SZ))
+	if (fw.size < (cfg_offset + WCD9XXX_MBHC_CAL_IMPED_MIN_SZ))
 		return false;
 
-	if (fw->size < (cfg_offset + WCD9XXX_MBHC_CAL_IMPED_SZ(imped_cfg)))
+	if (fw.size < (cfg_offset + WCD9XXX_MBHC_CAL_IMPED_SZ(imped_cfg)))
 		return false;
 
 	return true;
@@ -4178,7 +4209,9 @@
 	struct wcd9xxx_mbhc *mbhc;
 	struct snd_soc_codec *codec;
 	const struct firmware *fw;
+        struct firmware_cal *fw_data = NULL;
 	int ret = -1, retry = 0;
+	bool use_default_cal = false;
 
 	dwork = to_delayed_work(work);
 	mbhc = container_of(dwork, struct wcd9xxx_mbhc, mbhc_firmware_dwork);
@@ -4186,30 +4219,63 @@
 
 	while (retry < FW_READ_ATTEMPTS) {
 		retry++;
-		pr_info("%s:Attempt %d to request MBHC firmware\n",
+		pr_debug("%s:Attempt %d to request MBHC firmware\n",
 			__func__, retry);
+		if (mbhc->mbhc_cb->get_hwdep_fw_cal)
+			fw_data = mbhc->mbhc_cb->get_hwdep_fw_cal(codec,
+					WCD9XXX_MBHC_CAL);
+		if (!fw_data)
 		ret = request_firmware(&fw, "wcd9320/wcd9320_mbhc.bin",
 				       codec->dev);
-
-		if (ret != 0) {
+		/*
+		* if request_firmware and hwdep cal both fail then
+		* retry for few times before bailing out
+		*/
+		if ((ret != 0) && !fw_data) {
 			usleep_range(FW_READ_TIMEOUT, FW_READ_TIMEOUT);
 		} else {
 			pr_info("%s: MBHC Firmware read succesful\n", __func__);
 			break;
 		}
 	}
-
-	if (ret != 0) {
+	if (!fw_data)
+		pr_debug("%s: using request_firmware\n", __func__);
+	else
+		pr_debug("%s: using hwdep cal\n", __func__);
+	if (ret != 0 && !fw_data) {
 		pr_err("%s: Cannot load MBHC firmware use default cal\n",
 		       __func__);
-	} else if (wcd9xxx_mbhc_fw_validate(fw) == false) {
+		use_default_cal = true;
+	}
+	if (!use_default_cal) {
+		const void *data;
+		size_t size;
+
+		if (fw_data) {
+			data = fw_data->data;
+			size = fw_data->size;
+		} else {
+			data = fw->data;
+			size = fw->size;
+		}
+		if (wcd9xxx_mbhc_fw_validate(data, size) == false) {
 		pr_err("%s: Invalid MBHC cal data size use default cal\n",
 		       __func__);
+			if (!fw_data)
 		release_firmware(fw);
 	} else {
-		mbhc->mbhc_cfg->calibration = (void *)fw->data;
+			if (fw_data) {
+				mbhc->mbhc_cfg->calibration =
+						(void *)fw_data->data;
+				mbhc->mbhc_cal = fw_data;
+			} else {
+				mbhc->mbhc_cfg->calibration =
+						(void *)fw->data;
 		mbhc->mbhc_fw = fw;
 	}
+		}
+
+	}
 
 	(void) wcd9xxx_init_and_calibrate(mbhc);
 }
@@ -4398,15 +4464,16 @@
 		mbhc->mbhc_cb->enable_clock_gate(mbhc->codec, true);
 
 	if (!mbhc->mbhc_cfg->read_fw_bin ||
-	    (mbhc->mbhc_cfg->read_fw_bin && mbhc->mbhc_fw)) {
+		(mbhc->mbhc_cfg->read_fw_bin && mbhc->mbhc_fw) ||
+		(mbhc->mbhc_cfg->read_fw_bin && mbhc->mbhc_cal)) {
 		rc = wcd9xxx_init_and_calibrate(mbhc);
 	} else {
-		if (!mbhc->mbhc_fw)
+		if (!mbhc->mbhc_fw || !mbhc->mbhc_cal)
 			schedule_delayed_work(&mbhc->mbhc_firmware_dwork,
 					     usecs_to_jiffies(FW_READ_TIMEOUT));
 		else
-			pr_debug("%s: Skipping to read mbhc fw, 0x%p\n",
-				 __func__, mbhc->mbhc_fw);
+			pr_debug("%s: Skipping to read mbhc fw, 0x%p 0x%p\n",
+				 __func__, mbhc->mbhc_fw, mbhc->mbhc_cal);
 	}
 
 	pr_debug("%s: leave %d\n", __func__, rc);
@@ -4416,10 +4483,12 @@
 
 void wcd9xxx_mbhc_stop(struct wcd9xxx_mbhc *mbhc)
 {
-	if (mbhc->mbhc_fw) {
+	if (mbhc->mbhc_fw || mbhc->mbhc_cal) {
 		cancel_delayed_work_sync(&mbhc->mbhc_firmware_dwork);
+		if (!mbhc->mbhc_cal)
 		release_firmware(mbhc->mbhc_fw);
 		mbhc->mbhc_fw = NULL;
+		mbhc->mbhc_cal = NULL;
 	}
 }
 EXPORT_SYMBOL(wcd9xxx_mbhc_stop);
diff -X dontdiff -Nuarb a/sound/soc/codecs/wcd9xxx-mbhc.h b/sound/soc/codecs/wcd9xxx-mbhc.h
--- a/sound/soc/codecs/wcd9xxx-mbhc.h	2016-01-06 15:00:44.626590654 -0500
+++ b/sound/soc/codecs/wcd9xxx-mbhc.h	2015-12-01 05:58:59.000000000 -0500
@@ -13,6 +13,7 @@
 #define __WCD9XXX_MBHC_H__
 
 #include "wcd9xxx-resmgr.h"
+#include "wcdcal-hwdep.h"
 
 #define WCD9XXX_CFILT_FAST_MODE 0x00
 #define WCD9XXX_CFILT_SLOW_MODE 0x40
@@ -285,6 +286,9 @@
 	int (*enable_mb_source) (struct snd_soc_codec *, bool, bool);
 	void (*setup_int_rbias) (struct snd_soc_codec *, bool);
 	void (*pull_mb_to_vddio) (struct snd_soc_codec *, bool);
+	struct firmware_cal * (*get_hwdep_fw_cal) (struct snd_soc_codec *,
+				enum wcd_cal_type);
+
 };
 
 struct wcd9xxx_mbhc {
@@ -312,6 +316,7 @@
 	const struct firmware *mbhc_fw;
 
 	struct delayed_work mbhc_insert_dwork;
+	struct firmware_cal *mbhc_cal;
 
 	u8 current_plug;
 	struct work_struct correct_plug_swch;
diff -X dontdiff -Nuarb a/sound/soc/codecs/wcdcal-hwdep.c b/sound/soc/codecs/wcdcal-hwdep.c
--- a/sound/soc/codecs/wcdcal-hwdep.c	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/codecs/wcdcal-hwdep.c	2015-12-01 05:58:59.000000000 -0500
@@ -0,0 +1,221 @@
+/*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ */
+#include <linux/slab.h>
+#include <linux/module.h>
+#include <linux/ioctl.h>
+#include <linux/bitops.h>
+#include <sound/hwdep.h>
+#include <sound/msmcal-hwdep.h>
+#include <sound/soc.h>
+#include "wcdcal-hwdep.h"
+
+const int cal_size_info[WCD9XXX_MAX_CAL] = {
+	[WCD9XXX_ANC_CAL] = 4096,
+	[WCD9XXX_MBHC_CAL] = 4096,
+	[WCD9XXX_MAD_CAL] = 4096,
+};
+
+const char *cal_name_info[WCD9XXX_MAX_CAL] = {
+	[WCD9XXX_ANC_CAL] = "anc",
+	[WCD9XXX_MBHC_CAL] = "mbhc",
+	[WCD9XXX_MAD_CAL] = "mad",
+};
+
+struct firmware_cal *wcdcal_get_fw_cal(struct fw_info *fw_data,
+					enum wcd_cal_type type)
+{
+	if (!fw_data) {
+		pr_err("%s: fw_data is NULL\n", __func__);
+		return NULL;
+	}
+	if (type >= WCD9XXX_MAX_CAL ||
+		type < WCD9XXX_MIN_CAL) {
+		pr_err("%s: wrong cal type sent %d\n", __func__, type);
+		return NULL;
+	}
+	mutex_lock(&fw_data->lock);
+	if (!test_bit(WCDCAL_RECIEVED,
+		&fw_data->wcdcal_state[type])) {
+		pr_err("%s: cal not sent by userspace %d\n",
+			__func__, type);
+		mutex_unlock(&fw_data->lock);
+		return NULL;
+	}
+	mutex_unlock(&fw_data->lock);
+	return fw_data->fw[type];
+}
+EXPORT_SYMBOL(wcdcal_get_fw_cal);
+
+static int wcdcal_hwdep_ioctl_shared(struct snd_hwdep *hw,
+			struct wcdcal_ioctl_buffer fw_user)
+{
+	struct fw_info *fw_data = hw->private_data;
+	struct firmware_cal **fw = fw_data->fw;
+	void *data;
+
+	if (!test_bit(fw_user.cal_type, fw_data->cal_bit)) {
+		pr_err("%s: codec didn't set this %d!!\n",
+				__func__, fw_user.cal_type);
+		return -EFAULT;
+	}
+	if (fw_user.cal_type >= WCD9XXX_MAX_CAL ||
+		fw_user.cal_type < WCD9XXX_MIN_CAL) {
+		pr_err("%s: wrong cal type sent %d\n",
+				__func__, fw_user.cal_type);
+		return -EFAULT;
+	}
+	if (fw_user.size > cal_size_info[fw_user.cal_type] ||
+		fw_user.size <= 0) {
+		pr_err("%s: incorrect firmware size %d for %s\n",
+			__func__, fw_user.size,
+			cal_name_info[fw_user.cal_type]);
+		return -EFAULT;
+	}
+	data = fw[fw_user.cal_type]->data;
+	memcpy(data, fw_user.buffer, fw_user.size);
+	fw[fw_user.cal_type]->size = fw_user.size;
+	mutex_lock(&fw_data->lock);
+	set_bit(WCDCAL_RECIEVED, &fw_data->wcdcal_state[fw_user.cal_type]);
+	mutex_unlock(&fw_data->lock);
+	return 0;
+}
+
+#ifdef CONFIG_COMPAT
+struct wcdcal_ioctl_buffer32 {
+	u32 size;
+	compat_uptr_t buffer;
+	enum wcd_cal_type cal_type;
+};
+
+enum {
+	SNDRV_CTL_IOCTL_HWDEP_CAL_TYPE32 =
+		_IOW('U', 0x1, struct wcdcal_ioctl_buffer32),
+};
+
+static int wcdcal_hwdep_ioctl_compat(struct snd_hwdep *hw, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct wcdcal_ioctl_buffer __user *argp = (void __user *)arg;
+	struct wcdcal_ioctl_buffer32 fw_user32;
+	struct wcdcal_ioctl_buffer fw_user_compat;
+
+	if (cmd != SNDRV_CTL_IOCTL_HWDEP_CAL_TYPE32) {
+		pr_err("%s: wrong ioctl command sent %u!\n", __func__, cmd);
+		return -ENOIOCTLCMD;
+	}
+	if (copy_from_user(&fw_user32, argp, sizeof(fw_user32))) {
+		pr_err("%s: failed to copy\n", __func__);
+		return -EFAULT;
+	}
+	fw_user_compat.size = fw_user32.size;
+	fw_user_compat.buffer = compat_ptr(fw_user32.buffer);
+	fw_user_compat.cal_type = fw_user32.cal_type;
+	return wcdcal_hwdep_ioctl_shared(hw, fw_user_compat);
+}
+#else
+#define wcdcal_hwdep_ioctl_compat NULL
+#endif
+
+static int wcdcal_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
+		unsigned int cmd, unsigned long arg)
+{
+	struct wcdcal_ioctl_buffer __user *argp = (void __user *)arg;
+	struct wcdcal_ioctl_buffer fw_user;
+
+	if (cmd != SNDRV_CTL_IOCTL_HWDEP_CAL_TYPE) {
+		pr_err("%s: wrong ioctl command sent %d!\n", __func__, cmd);
+		return -ENOIOCTLCMD;
+	}
+	if (copy_from_user(&fw_user, argp, sizeof(fw_user))) {
+		pr_err("%s: failed to copy\n", __func__);
+		return -EFAULT;
+	}
+	return wcdcal_hwdep_ioctl_shared(hw, fw_user);
+}
+
+static int wcdcal_hwdep_release(struct snd_hwdep *hw, struct file *file)
+{
+	struct fw_info *fw_data = hw->private_data;
+	mutex_lock(&fw_data->lock);
+	/* clear all the calibrations */
+	memset(fw_data->wcdcal_state, 0,
+		sizeof(fw_data->wcdcal_state));
+	mutex_unlock(&fw_data->lock);
+	return 0;
+}
+
+int wcd_cal_create_hwdep(void *data, int node, struct snd_soc_codec *codec)
+{
+	char hwname[40];
+	struct snd_hwdep *hwdep;
+	struct firmware_cal **fw;
+	struct fw_info *fw_data = data;
+	int err, cal_bit;
+
+	if (!fw_data || !codec) {
+		pr_err("%s: wrong arguments passed\n", __func__);
+		return -EINVAL;
+	}
+
+	fw = fw_data->fw;
+	snprintf(hwname, strlen("Codec %s"), "Codec %s", codec->name);
+	err = snd_hwdep_new(codec->card->snd_card, hwname, node, &hwdep);
+	if (err < 0) {
+		dev_err(codec->dev, "%s: new hwdep failed %d\n",
+				__func__, err);
+		return err;
+	}
+	snprintf(hwdep->name, strlen("Codec %s"), "Codec %s", codec->name);
+	hwdep->iface = SNDRV_HWDEP_IFACE_AUDIO_CODEC;
+	hwdep->private_data = fw_data;
+	hwdep->ops.ioctl_compat = wcdcal_hwdep_ioctl_compat;
+	hwdep->ops.ioctl = wcdcal_hwdep_ioctl;
+	hwdep->ops.release = wcdcal_hwdep_release;
+	mutex_init(&fw_data->lock);
+
+	for_each_set_bit(cal_bit, fw_data->cal_bit, WCD9XXX_MAX_CAL) {
+		set_bit(WCDCAL_UNINITIALISED,
+				&fw_data->wcdcal_state[cal_bit]);
+		fw[cal_bit] = kzalloc(sizeof *(fw[cal_bit]), GFP_KERNEL);
+		if (!fw[cal_bit]) {
+			dev_err(codec->dev, "%s: no memory for %s cal\n",
+				__func__, cal_name_info[cal_bit]);
+			goto end;
+		}
+	}
+	for_each_set_bit(cal_bit, fw_data->cal_bit, WCD9XXX_MAX_CAL) {
+		fw[cal_bit]->data = kzalloc(cal_size_info[cal_bit],
+						GFP_KERNEL);
+		if (!fw[cal_bit]->data) {
+			dev_err(codec->dev, "%s: no memory for %s cal data\n",
+				__func__, cal_name_info[cal_bit]);
+			goto exit;
+		}
+		set_bit(WCDCAL_INITIALISED,
+			&fw_data->wcdcal_state[cal_bit]);
+	}
+	return 0;
+exit:
+	for_each_set_bit(cal_bit, fw_data->cal_bit, WCD9XXX_MAX_CAL) {
+		kfree(fw[cal_bit]->data);
+		fw[cal_bit]->data = NULL;
+	}
+end:
+	for_each_set_bit(cal_bit, fw_data->cal_bit, WCD9XXX_MAX_CAL) {
+		kfree(fw[cal_bit]);
+		fw[cal_bit] = NULL;
+	}
+	return -ENOMEM;
+}
+EXPORT_SYMBOL(wcd_cal_create_hwdep);
diff -X dontdiff -Nuarb a/sound/soc/codecs/wcdcal-hwdep.h b/sound/soc/codecs/wcdcal-hwdep.h
--- a/sound/soc/codecs/wcdcal-hwdep.h	1969-12-31 19:00:00.000000000 -0500
+++ b/sound/soc/codecs/wcdcal-hwdep.h	2015-12-01 05:58:59.000000000 -0500
@@ -0,0 +1,40 @@
+/*
+ * Copyright (c) 2014, The Linux Foundation. All rights reserved.
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License version 2 and
+ * only version 2 as published by the Free Software Foundation.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ */
+#ifndef __WCD9XXX_HWDEP_H__
+#define __WCD9XXX_HWDEP_H__
+#include <sound/msmcal-hwdep.h>
+
+enum wcd_cal_states {
+	WCDCAL_UNINITIALISED,
+	WCDCAL_INITIALISED,
+	WCDCAL_RECIEVED
+};
+
+struct fw_info {
+	struct firmware_cal *fw[WCD9XXX_MAX_CAL];
+	DECLARE_BITMAP(cal_bit, WCD9XXX_MAX_CAL);
+	/* for calibration tracking */
+	unsigned long wcdcal_state[WCD9XXX_MAX_CAL];
+	struct mutex lock;
+};
+
+struct firmware_cal {
+	u8 *data;
+	size_t size;
+};
+
+struct snd_soc_codec;
+int wcd_cal_create_hwdep(void *fw, int node, struct snd_soc_codec *codec);
+struct firmware_cal *wcdcal_get_fw_cal(struct fw_info *fw_data,
+					enum wcd_cal_type type);
+#endif /* __WCD9XXX_HWDEP_H__ */
diff -X dontdiff -Nuarb a/sound/soc/msm/apq8074.c b/sound/soc/msm/apq8074.c
--- a/sound/soc/msm/apq8074.c	2016-01-06 15:00:44.649590655 -0500
+++ b/sound/soc/msm/apq8074.c	2015-12-01 05:59:01.000000000 -0500
@@ -26,13 +26,13 @@
 #include <sound/pcm.h>
 #include <sound/jack.h>
 #include <sound/q6afe-v2.h>
+#include <sound/q6core.h>
 #include <sound/pcm_params.h>
 #include <asm/mach-types.h>
 #include <mach/subsystem_notif.h>
 #include <mach/socinfo.h>
 
 #include "qdsp6v2/msm-pcm-routing-v2.h"
-#include "qdsp6v2/q6core.h"
 #include "../codecs/wcd9xxx-common.h"
 #include "../codecs/wcd9320.h"
 
diff -X dontdiff -Nuarb a/sound/soc/msm/Kconfig b/sound/soc/msm/Kconfig
--- a/sound/soc/msm/Kconfig	2016-01-06 15:00:44.648590655 -0500
+++ b/sound/soc/msm/Kconfig	2015-12-01 05:59:01.000000000 -0500
@@ -183,6 +183,7 @@
 	select SND_DYNAMIC_MINORS
 	select AUDIO_OCMEM
 	select DOLBY_DAP
+	select SND_HWDEP
 	help
 	 To add support for SoC audio on MSM8974.
 	 This will enable sound soc drivers which
diff -X dontdiff -Nuarb a/sound/soc/msm/msm8226.c b/sound/soc/msm/msm8226.c
--- a/sound/soc/msm/msm8226.c	2016-01-06 15:00:44.654590655 -0500
+++ b/sound/soc/msm/msm8226.c	2015-12-01 05:59:02.000000000 -0500
@@ -27,8 +27,9 @@
 #include <asm/mach-types.h>
 #include <mach/socinfo.h>
 #include <mach/subsystem_notif.h>
+#include <sound/q6core.h>
+
 #include <qdsp6v2/msm-pcm-routing-v2.h>
-#include "qdsp6v2/q6core.h"
 #include "../codecs/wcd9xxx-common.h"
 #include "../codecs/wcd9306.h"
 
@@ -68,7 +69,7 @@
 #define LO_1_SPK_AMP   0x1
 #define LO_2_SPK_AMP   0x2
 
-#define ADSP_STATE_READY_TIMEOUT_MS 3000
+#define ADSP_STATE_READY_TIMEOUT_MS 50
 
 static void *adsp_state_notifier;
 
@@ -494,7 +495,7 @@
 	SOC_ENUM_SINGLE_EXT(4, slim0_tx_ch_text),
 };
 
-static const char *const btsco_rate_text[] = {"8000", "16000"};
+static const char *const btsco_rate_text[] = {"BTSCO_RATE_8KHZ", "BTSCO_RATE_16KHZ"};
 static const struct soc_enum msm_btsco_enum[] = {
 	SOC_ENUM_SINGLE_EXT(2, btsco_rate_text),
 };
diff -X dontdiff -Nuarb a/sound/soc/msm/msm8974.c b/sound/soc/msm/msm8974.c
--- a/sound/soc/msm/msm8974.c	2016-01-06 15:00:44.655590655 -0500
+++ b/sound/soc/msm/msm8974.c	2015-12-01 05:59:02.000000000 -0500
@@ -26,11 +26,11 @@
 #include <sound/pcm.h>
 #include <sound/jack.h>
 #include <sound/q6afe-v2.h>
+#include <sound/q6core.h>
 #include <sound/pcm_params.h>
 #include <asm/mach-types.h>
 #include <mach/subsystem_notif.h>
 #include "qdsp6v2/msm-pcm-routing-v2.h"
-#include "qdsp6v2/q6core.h"
 #include "../codecs/wcd9xxx-common.h"
 #include "../codecs/wcd9320.h"
 
@@ -81,17 +81,24 @@
 #define EXT_CLASS_AB_DIS_DELAY 1000
 #define EXT_CLASS_AB_DELAY_DELTA 1000
 
-#if defined (CONFIG_SND_SOC_MAX98504)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98506)
+#if defined (CONFIG_TERT_MI2S_ENABLE)
+#define GPIO_TERT_MI2S_SCK    74
+#define GPIO_TERT_MI2S_WS     75
+#define GPIO_TERT_MI2S_DATA0  76
+#define GPIO_TERT_MI2S_DATA1  77
+#else
 #define GPIO_SECOND_MI2S_SCK    79
 #define GPIO_SECOND_MI2S_WS     80
 #define GPIO_SECOND_MI2S_DATA0  81
 #define GPIO_SECOND_MI2S_DATA1  82
 #endif
+#endif
 #define NUM_OF_AUXPCM_GPIOS 4
 
 static void *adsp_state_notifier;
 
-#define ADSP_STATE_READY_TIMEOUT_MS 3000
+#define ADSP_STATE_READY_TIMEOUT_MS 50
 
 static inline int param_is_mask(int p)
 {
@@ -257,17 +264,36 @@
 int speaker_status = 0;
 EXPORT_SYMBOL(speaker_status);
 #endif
-#if defined(CONFIG_MACH_KLTE_KOR) || defined(CONFIG_MACH_KLTE_JPN) || defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_CHAGALL_KDI) || defined(CONFIG_MACH_KLIMT_LTE_DCM)
+#if defined(CONFIG_MACH_KLTE_KOR) || defined(CONFIG_MACH_KLTE_JPN) || defined(CONFIG_MACH_KACTIVELTE_DCM) \
+|| defined(CONFIG_MACH_CHAGALL_KDI) || defined(CONFIG_MACH_KLIMT_LTE_DCM) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 static int fsa_en_gpio;
 #endif
 
-#if defined (CONFIG_SND_SOC_MAX98504)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98506)
 struct request_gpio {
 	unsigned gpio_no;
 	char *gpio_name;
 };
 
 static struct request_gpio pri_mi2s_gpio[] = {
+#if defined (CONFIG_TERT_MI2S_ENABLE)
+	{
+		.gpio_no = GPIO_TERT_MI2S_SCK,
+		.gpio_name = "TERT_MI2S_SCK",
+	},
+	{
+		.gpio_no = GPIO_TERT_MI2S_WS,
+		.gpio_name = "TERT_MI2S_WS",
+	},
+	{
+		.gpio_no = GPIO_TERT_MI2S_DATA0,
+		.gpio_name = "TERT_MI2S_DATA0",
+	},
+	{
+		.gpio_no = GPIO_TERT_MI2S_DATA1,
+		.gpio_name = "TERT_MI2S_DATA1",
+	},
+#else
 	{
 		.gpio_no = GPIO_SECOND_MI2S_SCK,
 		.gpio_name = "SECOND_MI2S_SCK",
@@ -284,6 +310,7 @@
 		.gpio_no = GPIO_SECOND_MI2S_DATA1,
 		.gpio_name = "SECOND_MI2S_DATA1",
 	},
+#endif
 };
 /* MI2S clock */
 struct mi2s_clk {
@@ -1110,10 +1137,10 @@
 				struct snd_ctl_elem_value *ucontrol)
 {
 	switch (ucontrol->value.integer.value[0]) {
-	case 8000:
+	case 0:
 		msm_btsco_rate = BTSCO_RATE_8KHZ;
 		break;
-	case 16000:
+	case 1:
 		msm_btsco_rate = BTSCO_RATE_16KHZ;
 		break;
 	default:
@@ -1690,24 +1717,23 @@
 	return 0;
 }
 
-#if defined(CONFIG_SND_SOC_MAX98504) || defined(CONFIG_SND_SOC_MAX98505)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined(CONFIG_SND_SOC_MAX98505) \
+ || defined (CONFIG_SND_SOC_MAX98506)
 static int msm8974_mi2s_be_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 				struct snd_pcm_hw_params *params)
 {
-	struct snd_interval *rate = hw_param_interval(params,
-					SNDRV_PCM_HW_PARAM_RATE);
-	struct snd_interval *channels = hw_param_interval(params,
-						SNDRV_PCM_HW_PARAM_CHANNELS);
+	struct snd_interval *rate =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
+	struct snd_interval *channels =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
+
 	pr_debug("%s: enter\n", __func__);
 
 	rate->min = rate->max = 48000;
-
-
+	channels->min = channels->max = 2;
     param_set_mask(params, SNDRV_PCM_HW_PARAM_FORMAT,
     		SNDRV_PCM_FORMAT_S16_LE);
 
-    channels->min = channels->max = 2;
-
 	return 0;
 }
 #endif
@@ -1716,13 +1742,13 @@
 static int msm_be_fm_hw_params_fixup(struct snd_soc_pcm_runtime *rtd,
 				struct snd_pcm_hw_params *params)
 {
-	struct snd_interval *rate = hw_param_interval(params,
-					SNDRV_PCM_HW_PARAM_RATE);
-
+	struct snd_interval *rate =
+			hw_param_interval(params, SNDRV_PCM_HW_PARAM_RATE);
 	struct snd_interval *channels =
 	    hw_param_interval(params, SNDRV_PCM_HW_PARAM_CHANNELS);
 
 	pr_debug("%s()\n", __func__);
+
 	rate->min = rate->max = 48000;
 	channels->min = channels->max = 2;
 
@@ -2228,7 +2254,7 @@
 
 }
 
-#if defined (CONFIG_SND_SOC_MAX98504)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98506)
 static int msm8974_pri_mi2s_free_gpios(void)
 {
 	int	i;
@@ -2259,19 +2285,23 @@
 
 static void msm8974_mi2s_shutdown(struct snd_pcm_substream *substream)
 {
-	
-
 	if (atomic_dec_return(&pri_mi2s_clk.mi2s_rsc_ref) == 0) {
-		int ret =0;
-		pr_debug("[MAX98504_DEBUG] %s: free mi2s resources\n", __func__);
-			if(substream->stream==0)
-				ret = afe_set_lpass_clock(AFE_PORT_ID_SECONDARY_MI2S_RX, &lpass_mi2s_disable);	
-			else if(substream->stream==1)
-				ret = afe_set_lpass_clock(AFE_PORT_ID_SECONDARY_MI2S_TX, &lpass_mi2s_disable);		
+		int ret = 0;
+		u16 port_id = 0;
+		pr_debug("[MAX9850x_DEBUG] %s: free mi2s resources\n", __func__);
+
+#if defined (CONFIG_TERT_MI2S_ENABLE)
+		port_id = AFE_PORT_ID_TERTIARY_MI2S_RX;
+#else
+		port_id = AFE_PORT_ID_SECONDARY_MI2S_RX;
+#endif
+		if(substream->stream == 0)
+			ret = afe_set_lpass_clock(port_id, &lpass_mi2s_disable);
+		else if(substream->stream == 1)
+			ret = afe_set_lpass_clock(port_id, &lpass_mi2s_disable);
        		
        		if (ret < 0) {	
       			pr_err("%s: afe_set_lpass_clock failed\n", __func__);	
-       	
       		}	
 		msm8974_pri_mi2s_free_gpios();
 	}
@@ -2302,9 +2332,11 @@
 
 	return rtn;
 }
+
 static int msm8974_mi2s_startup(struct snd_pcm_substream *substream)
 {
 	int ret = 0;
+	u16 port_id = 0;
 	struct snd_soc_pcm_runtime *rtd = substream->private_data;
 	struct snd_soc_dai *cpu_dai = rtd->cpu_dai;
 	struct snd_soc_dai *codec_dai = rtd->codec_dai;
@@ -2314,20 +2346,29 @@
 	if (atomic_inc_return(&pri_mi2s_clk.mi2s_rsc_ref) == 1) {
 		pr_info("%s: acquire mi2s resources\n", __func__);
 		msm8974_configure_pri_mi2s_gpio();	
-			if(substream->stream==0)
-				ret = afe_set_lpass_clock(AFE_PORT_ID_SECONDARY_MI2S_RX, &lpass_mi2s_enable);	
-			else if(substream->stream==1)
-				ret = afe_set_lpass_clock(AFE_PORT_ID_SECONDARY_MI2S_TX, &lpass_mi2s_enable); 
+
+#if defined (CONFIG_TERT_MI2S_ENABLE)
+		port_id = AFE_PORT_ID_TERTIARY_MI2S_RX;
+#else
+		port_id = AFE_PORT_ID_SECONDARY_MI2S_RX;
+#endif
+		if(substream->stream == 0)
+			ret = afe_set_lpass_clock(port_id, &lpass_mi2s_enable);
+		else if(substream->stream == 1)
+			ret = afe_set_lpass_clock(port_id, &lpass_mi2s_enable);
        		if (ret < 0) {	
       			pr_err("%s: afe_set_lpass_clock failed\n", __func__);	
        		return ret;	
       		}	
+
 		ret = snd_soc_dai_set_fmt(cpu_dai, SND_SOC_DAIFMT_CBS_CFS);
 		if (ret < 0)
 			dev_err(cpu_dai->dev, "set format for CPU dai"
 				" failed\n");
 
-		ret = snd_soc_dai_set_fmt(codec_dai, SND_SOC_DAIFMT_I2S | SND_SOC_DAIFMT_NB_NF |
+		ret = snd_soc_dai_set_fmt(codec_dai,
+				SND_SOC_DAIFMT_I2S |
+				SND_SOC_DAIFMT_NB_NF |
                 		SND_SOC_DAIFMT_CBS_CFS);
 		if (ret < 0)
 			dev_err(codec_dai->dev, "set format for codec dai"
@@ -2338,8 +2379,6 @@
 	return ret;
 }
 
-
-
 static struct snd_soc_ops msm8974_mi2s_be_ops = {
 	.startup = msm8974_mi2s_startup,
 	.shutdown = msm8974_mi2s_shutdown
@@ -2352,8 +2391,6 @@
 	.shutdown = msm8974_snd_shudown,
 };
 
-
-
 static int msm8974_slimbus_2_hw_params(struct snd_pcm_substream *substream,
 				struct snd_pcm_hw_params *params)
 {
@@ -3329,20 +3366,46 @@
 		.be_hw_params_fixup = msm_be_hw_params_fixup,
 		.ignore_suspend = 1,
 	},
-#ifdef CONFIG_SND_SOC_MAX98504	
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98506)
+#if defined (CONFIG_TERT_MI2S_ENABLE)
+	{
+		.name = LPASS_BE_TERT_MI2S_TX,
+		.stream_name = "Tertiary MI2S Capture",
+		.cpu_dai_name = "msm-dai-q6-mi2s.2",
+		.platform_name = "msm-pcm-routing",
+#if defined (CONFIG_SND_SOC_MAX98504)
+		.codec_name 	= "max98504.18-0031",//"msm-stub-codec.1",
+		.codec_dai_name = "max98504-aif1",//"msm-stub-tx",
+#elif defined (CONFIG_SND_SOC_MAX98506)
+		.codec_name 	= "max98506.18-0031",
+		.codec_dai_name = "max98506-aif1",
+#endif
+		.no_pcm = 1,
+		.be_id = MSM_BACKEND_DAI_TERTIARY_MI2S_TX,
+		.be_hw_params_fixup = msm8974_mi2s_be_hw_params_fixup,
+		.ops = &msm8974_mi2s_be_ops,
+		.ignore_suspend = 1,
+	},
+#else
 	{
 		.name = LPASS_BE_SEC_MI2S_TX,
 		.stream_name = "Secondary MI2S Capture",
 		.cpu_dai_name = "msm-dai-q6-mi2s.1",
 		.platform_name = "msm-pcm-routing",
+#if defined (CONFIG_SND_SOC_MAX98504)
 		.codec_name 	= "max98504.18-0031",//"msm-stub-codec.1",
 		.codec_dai_name = "max98504-aif1",//"msm-stub-tx",
+#elif defined (CONFIG_SND_SOC_MAX98506)
+		.codec_name 	= "max98506.18-0031",
+		.codec_dai_name = "max98506-aif1",
+#endif
 		.no_pcm = 1,
 		.be_id = MSM_BACKEND_DAI_SECONDARY_MI2S_TX,
 		.be_hw_params_fixup = msm8974_mi2s_be_hw_params_fixup,
 		.ops = &msm8974_mi2s_be_ops,
 	},
 #endif	
+#endif
 };
 
 static struct snd_soc_dai_link msm8974_hdmi_dai_link[] = {
@@ -3824,7 +3887,8 @@
 #endif
 
 
-#if defined(CONFIG_MACH_KLTE_KOR) || defined(CONFIG_MACH_KLTE_JPN) || defined(CONFIG_MACH_KACTIVELTE_DCM) || defined(CONFIG_MACH_CHAGALL_KDI) || defined(CONFIG_MACH_KLIMT_LTE_DCM)
+#if defined(CONFIG_MACH_KLTE_KOR) || defined(CONFIG_MACH_KLTE_JPN) || defined(CONFIG_MACH_KACTIVELTE_DCM) \
+|| defined(CONFIG_MACH_CHAGALL_KDI) || defined(CONFIG_MACH_KLIMT_LTE_DCM) || defined(CONFIG_MACH_KACTIVELTE_KOR)
 	/* enable FSA8039 for jack detection */
 	pr_info("%s: Check to enable FSA8039\n", __func__);
 	fsa_en_gpio = of_get_named_gpio(pdev->dev.of_node,
@@ -3949,7 +4013,7 @@
 		ret = -EINVAL;
 		goto err2;
 	}
-#if defined (CONFIG_SND_SOC_MAX98504)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98506)
 	atomic_set(&pri_mi2s_clk.mi2s_rsc_ref, 0);
 #endif
 
diff -X dontdiff -Nuarb a/sound/soc/msm/msm8x10.c b/sound/soc/msm/msm8x10.c
--- a/sound/soc/msm/msm8x10.c	2016-01-06 15:00:44.655590655 -0500
+++ b/sound/soc/msm/msm8x10.c	2015-12-01 05:59:02.000000000 -0500
@@ -385,7 +385,7 @@
 }
 
 
-static const char *const btsco_rate_text[] = {"8000", "16000"};
+static const char *const btsco_rate_text[] = {"BTSCO_RATE_8KHZ", "BTSCO_RATE_16KHZ"};
 static const struct soc_enum msm_btsco_enum[] = {
 	SOC_ENUM_SINGLE_EXT(2, btsco_rate_text),
 };
@@ -405,10 +405,10 @@
 			      struct snd_ctl_elem_value *ucontrol)
 {
 	switch (ucontrol->value.integer.value[0]) {
-	case 8000:
+	case 0:
 		msm_btsco_rate = BTSCO_RATE_8KHZ;
 		break;
-	case 16000:
+	case 1:
 		msm_btsco_rate = BTSCO_RATE_16KHZ;
 		break;
 	default:
diff -X dontdiff -Nuarb a/sound/soc/msm/msm-pcm-loopback.c b/sound/soc/msm/msm-pcm-loopback.c
--- a/sound/soc/msm/msm-pcm-loopback.c	2016-01-06 15:00:44.652590655 -0500
+++ b/sound/soc/msm/msm-pcm-loopback.c	2015-12-01 05:59:02.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2014, The Linux Foundation. All rights reserved.
 
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 and
@@ -200,19 +200,23 @@
 
 static void stop_pcm(struct msm_pcm_loopback *pcm)
 {
-	struct snd_soc_pcm_runtime *soc_pcm_rx =
-		pcm->playback_substream->private_data;
-	struct snd_soc_pcm_runtime *soc_pcm_tx =
-		pcm->capture_substream->private_data;
+	struct snd_soc_pcm_runtime *soc_pcm_rx;
+	struct snd_soc_pcm_runtime *soc_pcm_tx;
 
 	if (pcm->audio_client == NULL)
 		return;
 	q6asm_cmd(pcm->audio_client, CMD_CLOSE);
 
+	if (pcm->playback_substream != NULL) {
+		soc_pcm_rx = pcm->playback_substream->private_data;
 	msm_pcm_routing_dereg_phy_stream(soc_pcm_rx->dai_link->be_id,
 			SNDRV_PCM_STREAM_PLAYBACK);
+	}
+	if (pcm->capture_substream != NULL) {
+		soc_pcm_tx = pcm->capture_substream->private_data;
 	msm_pcm_routing_dereg_phy_stream(soc_pcm_tx->dai_link->be_id,
 			SNDRV_PCM_STREAM_CAPTURE);
+	}
 	q6asm_audio_client_free(pcm->audio_client);
 	pcm->audio_client = NULL;
 }
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6/q6asm.c b/sound/soc/msm/qdsp6/q6asm.c
--- a/sound/soc/msm/qdsp6/q6asm.c	2016-01-06 15:00:44.656590655 -0500
+++ b/sound/soc/msm/qdsp6/q6asm.c	2015-12-01 05:59:02.000000000 -0500
@@ -57,6 +57,7 @@
 #define OUT_BUFFER_SIZE 56
 #define IN_BUFFER_SIZE 24
 #endif
+#define FRAME_NUM   (8)
 static DEFINE_MUTEX(session_lock);
 
 /* session id: 0 reserved */
@@ -509,6 +510,9 @@
 			pr_debug("%s: buffer already allocated\n", __func__);
 			return 0;
 		}
+
+		if (bufcnt != FRAME_NUM)
+			goto fail;
 		mutex_lock(&ac->cmd_lock);
 		buf = kzalloc(((sizeof(struct audio_buffer))*bufcnt),
 				GFP_KERNEL);
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/audio_ocmem.c b/sound/soc/msm/qdsp6v2/audio_ocmem.c
--- a/sound/soc/msm/qdsp6v2/audio_ocmem.c	2016-01-06 15:00:44.657590655 -0500
+++ b/sound/soc/msm/qdsp6v2/audio_ocmem.c	2015-12-01 05:59:09.000000000 -0500
@@ -31,7 +31,7 @@
 #include <mach/subsystem_restart.h>
 #include <mach/msm_memtypes.h>
 #include <mach/ramdump.h>
-#include "q6core.h"
+#include <sound/q6core.h>
 #include "audio_ocmem.h"
 
 
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c	2016-01-06 15:00:44.657590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-audio-effects-q6-v2.c	2015-12-01 05:59:02.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2013-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -621,6 +621,11 @@
 			}
 			for (j = 0; j < eq->config.num_bands; j++) {
 				idx = *values++;
+				if (idx >= MAX_EQ_BANDS) {
+					pr_err("EQ_CONFIG:invalid band index\n");
+					rc = -EINVAL;
+					goto invalid_config;
+				}
 				eq->per_band_cfg[idx].band_idx = idx;
 				eq->per_band_cfg[idx].filter_type = *values++;
 				eq->per_band_cfg[idx].freq_millihertz =
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c	2016-01-06 15:00:44.658590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-compress-q6-v2.c	2015-12-01 05:59:02.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -304,6 +304,7 @@
 	uint32_t sample_rate = 0;
 	int bytes_available, stream_id;
 	uint32_t stream_index;
+	unsigned long flags;
 
 	pr_debug("%s opcode =%08x\n", __func__, opcode);
 	switch (opcode) {
@@ -476,11 +477,17 @@
 	case RESET_EVENTS:
 		pr_err("%s: Received reset events CB, move to error state",
 			__func__);
-		spin_lock(&prtd->lock);
+		spin_lock_irqsave(&prtd->lock, flags);
 		snd_compr_fragment_elapsed(cstream);
 		prtd->copied_total = prtd->bytes_received;
 		atomic_set(&prtd->error, 1);
-		spin_unlock(&prtd->lock);
+		wake_up(&prtd->drain_wait);
+		if (atomic_read(&prtd->eos)) {
+			pr_debug("%s:unblock eos wait queues", __func__);
+			wake_up(&prtd->eos_wait);
+			atomic_set(&prtd->eos, 0);
+		}
+		spin_unlock_irqrestore(&prtd->lock, flags);
 		break;
 	default:
 		pr_debug("%s: Not Supported Event opcode[0x%x]\n",
@@ -624,6 +631,11 @@
 		pr_err("%s: Send SoftVolume Param failed ret=%d\n",
 			__func__, ret);
 
+	ret = q6asm_set_softpause(ac, &softpause);
+	if (ret < 0)
+		pr_err("%s: Send SoftPause Param failed ret=%d\n",
+				__func__, ret);
+
 	ret = q6asm_set_io_mode(ac, (COMPRESSED_STREAM_IO | ASYNC_IO_MODE));
 	if (ret < 0) {
 		pr_err("%s: Set IO mode failed\n", __func__);
@@ -941,14 +953,19 @@
 	rc = wait_event_interruptible(prtd->drain_wait,
 					prtd->drain_ready ||
 					prtd->cmd_interrupt ||
-					atomic_read(&prtd->xrun));
-	pr_debug("%s: out of buffer drain wait\n", __func__);
+					atomic_read(&prtd->xrun) ||
+					atomic_read(&prtd->error));
+	pr_debug("%s: out of buffer drain wait with ret %d\n", __func__, rc);
 	spin_lock_irqsave(&prtd->lock, *flags);
 	if (prtd->cmd_interrupt) {
 		pr_debug("%s: buffer drain interrupted by flush)\n", __func__);
 		rc = -EINTR;
 		prtd->cmd_interrupt = 0;
 	}
+	if (atomic_read(&prtd->error)) {
+		pr_err("%s: Got RESET EVENTS notification, return\n", __func__);
+		rc = -ENETRESET;
+	}
 	return rc;
 }
 
@@ -1253,7 +1270,9 @@
 
 		/* Wait indefinitely for  DRAIN. Flush can also signal this*/
 		rc = wait_event_interruptible(prtd->eos_wait,
-					      (prtd->cmd_ack || prtd->cmd_interrupt));
+						(prtd->cmd_ack ||
+						prtd->cmd_interrupt ||
+						atomic_read(&prtd->error)));
 
 		if (rc < 0)
 			pr_err("%s: EOS wait failed\n", __func__);
@@ -1264,6 +1283,11 @@
 		if (prtd->cmd_interrupt)
 			rc = -EINTR;
 
+		if (atomic_read(&prtd->error)) {
+			pr_err("%s: Got RESET EVENTS notification, return\n", __func__);
+			rc = -ENETRESET;
+		}
+
 		/*FIXME : what if a flush comes while PC is here */
 		if (rc == 0) {
 			/*
@@ -1414,13 +1438,12 @@
 	tstamp.byte_offset = prtd->byte_offset;
 	tstamp.copied_total = prtd->copied_total;
 	first_buffer = prtd->first_buffer;
-
 	if (atomic_read(&prtd->error)) {
 		pr_err("%s Got RESET EVENTS notification, return error", __func__);
 		tstamp.pcm_io_frames = 0;
 		memcpy(arg, &tstamp, sizeof(struct snd_compr_tstamp));
 		spin_unlock_irqrestore(&prtd->lock, flags);
-		return -EINVAL;
+		return -ENETRESET;
 	}
 
 	spin_unlock_irqrestore(&prtd->lock, flags);
@@ -1434,6 +1457,9 @@
 		if (rc < 0) {
 			pr_err("%s: Get Session Time return value =%lld\n",
 				__func__, timestamp);
+			if (atomic_read(&prtd->error))
+				return -ENETRESET;
+			else
 			return -EAGAIN;
 		}
 	} else {
@@ -1517,7 +1543,7 @@
 	if (atomic_read(&prtd->error)) {
 		pr_err("%s Got RESET EVENTS notification", __func__);
 		spin_unlock_irqrestore(&prtd->lock, flags);
-		return -EINVAL;
+		return -ENETRESET;
 	}
 	spin_unlock_irqrestore(&prtd->lock, flags);
 
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-multi-ch-pcm-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-multi-ch-pcm-q6-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-multi-ch-pcm-q6-v2.c	2016-01-06 15:00:44.659590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-multi-ch-pcm-q6-v2.c	2015-12-01 05:59:03.000000000 -0500
@@ -28,6 +28,7 @@
 #include <sound/pcm.h>
 #include <sound/initval.h>
 #include <sound/control.h>
+#include <sound/timer.h>
 
 #include "msm-pcm-q6-v2.h"
 #include "msm-pcm-routing-v2.h"
@@ -200,6 +201,18 @@
 		}
 	}
 	break;
+	case RESET_EVENTS:
+		pr_debug("%s RESET_EVENTS\n", __func__);
+		atomic_inc(&prtd->out_count);
+		prtd->reset_event = true;
+		if (atomic_read(&prtd->start))
+			snd_pcm_period_elapsed(substream);
+		else if (substream->timer_running)
+			snd_timer_interrupt(substream->timer, 1);
+		wake_up(&the_locks.eos_wait);
+		wake_up(&the_locks.write_wait);
+		wake_up(&the_locks.read_wait);
+		break;
 	default:
 		pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
 		break;
@@ -454,12 +467,22 @@
 	fbytes = frames_to_bytes(runtime, frames);
 	pr_debug("%s: prtd->out_count = %d\n",
 				__func__, atomic_read(&prtd->out_count));
+	if (prtd->reset_event == true) {
+		pr_err("%s: In SSR return ENETRESET before wait\n", __func__);
+		return -ENETRESET;
+	}
+
 	ret = wait_event_timeout(the_locks.write_wait,
 			(atomic_read(&prtd->out_count)), 5 * HZ);
 	if (!ret) {
 		pr_err("%s: wait_event_timeout failed\n", __func__);
 		goto fail;
 	}
+	if (prtd->reset_event == true) {
+		pr_err("%s: In SSR return ENETRESET after wait\n", __func__);
+		return -ENETRESET;
+	}
+
 
 	if (!atomic_read(&prtd->out_count)) {
 		pr_err("%s: pcm stopped out_count 0\n", __func__);
@@ -548,12 +571,22 @@
 	pr_debug("hw_ptr %d\n", (int)runtime->status->hw_ptr);
 	pr_debug("avail_min %d\n", (int)runtime->control->avail_min);
 
+	if (prtd->reset_event == true) {
+		pr_err("%s: In SSR return ENETRESET before wait\n", __func__);
+		return -ENETRESET;
+	}
+
 	ret = wait_event_timeout(the_locks.read_wait,
 			(atomic_read(&prtd->in_count)), 5 * HZ);
 	if (!ret) {
 		pr_debug("%s: wait_event_timeout failed\n", __func__);
 		goto fail;
 	}
+	if (prtd->reset_event == true) {
+		pr_err("%s: In SSR return ENETRESET after wait\n", __func__);
+		return -ENETRESET;
+	}
+
 	if (!atomic_read(&prtd->in_count)) {
 		pr_debug("%s: pcm stopped in_count 0\n", __func__);
 		return 0;
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c	2016-01-06 15:00:44.659590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-afe-v2.c	2015-12-01 05:59:03.000000000 -0500
@@ -35,12 +35,12 @@
 
 #define MIN_PLAYBACK_PERIOD_SIZE (128 * 2)
 #define MAX_PLAYBACK_PERIOD_SIZE (128 * 2 * 2 * 6)
-#define MIN_PLAYBACK_NUM_PERIODS (64)
+#define MIN_PLAYBACK_NUM_PERIODS (4)
 #define MAX_PLAYBACK_NUM_PERIODS (768)
 
 #define MIN_CAPTURE_PERIOD_SIZE (128 * 2 * 4)
 #define MAX_CAPTURE_PERIOD_SIZE (128 * 2 * 2 * 6 * 4)
-#define MIN_CAPTURE_NUM_PERIODS (32)
+#define MIN_CAPTURE_NUM_PERIODS (4)
 #define MAX_CAPTURE_NUM_PERIODS (384)
 
 static struct snd_pcm_hardware msm_afe_hardware_playback = {
@@ -58,7 +58,7 @@
 	.channels_min =         1,
 	.channels_max =         6,
 	.buffer_bytes_max =     MAX_PLAYBACK_PERIOD_SIZE *
-				MIN_PLAYBACK_NUM_PERIODS,
+				MAX_PLAYBACK_NUM_PERIODS,
 	.period_bytes_min =     MIN_PLAYBACK_PERIOD_SIZE,
 	.period_bytes_max =     MAX_PLAYBACK_PERIOD_SIZE,
 	.periods_min =          MIN_PLAYBACK_NUM_PERIODS,
@@ -81,7 +81,7 @@
 	.channels_min =         1,
 	.channels_max =         6,
 	.buffer_bytes_max =     MAX_CAPTURE_PERIOD_SIZE *
-				MIN_CAPTURE_NUM_PERIODS,
+				MAX_CAPTURE_NUM_PERIODS,
 	.period_bytes_min =     MIN_CAPTURE_PERIOD_SIZE,
 	.period_bytes_max =     MAX_CAPTURE_PERIOD_SIZE,
 	.periods_min =          MIN_CAPTURE_NUM_PERIODS,
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c	2016-01-06 15:00:44.659590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.c	2015-12-01 05:59:03.000000000 -0500
@@ -26,6 +26,7 @@
 #include <sound/initval.h>
 #include <sound/control.h>
 #include <sound/q6audio-v2.h>
+#include <sound/timer.h>
 #include <asm/dma.h>
 #include <linux/dma-mapping.h>
 #include <linux/msm_audio_ion.h>
@@ -37,7 +38,6 @@
 #include "msm-pcm-q6-v2.h"
 #include "msm-pcm-routing-v2.h"
 
-#define DUALWAVE_ENABLE
 #ifdef DUALWAVE_ENABLE 
 #include <linux/syscalls.h>
 #include <asm/uaccess.h>
@@ -280,6 +280,18 @@
 		}
 	}
 	break;
+	case RESET_EVENTS:
+		pr_err("%s RESET_EVENTS\n", __func__);
+		prtd->pcm_irq_pos += prtd->pcm_count;
+		atomic_inc(&prtd->out_count);
+		atomic_inc(&prtd->in_count);
+		prtd->reset_event = true;
+		if (atomic_read(&prtd->start))
+			snd_pcm_period_elapsed(substream);
+		wake_up(&the_locks.eos_wait);
+		wake_up(&the_locks.write_wait);
+		wake_up(&the_locks.read_wait);
+		break;
 	default:
 		pr_debug("Not Supported Event opcode[0x%x]\n", opcode);
 		break;
@@ -588,6 +600,7 @@
 
 	prtd->dsp_cnt = 0;
 	prtd->set_channel_map = false;
+	prtd->reset_event = false;
 	runtime->private_data = prtd;
 
 	return 0;
@@ -610,6 +623,12 @@
 	fbytes = frames_to_bytes(runtime, frames);
 	pr_debug("%s: prtd->out_count = %d\n",
 				__func__, atomic_read(&prtd->out_count));
+
+	if (prtd->reset_event) {
+		pr_err("%s: In SSR return ENETRESET before wait\n", __func__);
+		return -ENETRESET;
+	}
+
 	ret = wait_event_timeout(the_locks.write_wait,
 			(atomic_read(&prtd->out_count)), 5 * HZ);
 	if (!ret) {
@@ -617,6 +636,11 @@
 		goto fail;
 	}
 
+	if (prtd->reset_event) {
+		pr_err("%s: In SSR return ENETRESET after wait\n", __func__);
+		return -ENETRESET;
+	}
+
 	if (!atomic_read(&prtd->out_count)) {
 		pr_err("%s: pcm stopped out_count 0\n", __func__);
 		return 0;
@@ -707,12 +731,20 @@
 	pr_debug("hw_ptr %d\n", (int)runtime->status->hw_ptr);
 	pr_debug("avail_min %d\n", (int)runtime->control->avail_min);
 
+	if (prtd->reset_event) {
+		pr_err("%s: In SSR return ENETRESET before wait\n", __func__);
+		return -ENETRESET;
+	}
 	ret = wait_event_timeout(the_locks.read_wait,
 			(atomic_read(&prtd->in_count)), 5 * HZ);
 	if (!ret) {
 		pr_debug("%s: wait_event_timeout failed\n", __func__);
 		goto fail;
 	}
+	if (prtd->reset_event) {
+		pr_err("%s: In SSR return ENETRESET after wait\n", __func__);
+		return -ENETRESET;
+	}
 	if (!atomic_read(&prtd->in_count)) {
 		pr_debug("%s: pcm stopped in_count 0\n", __func__);
 		return 0;
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h
--- a/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h	2016-01-06 15:00:44.659590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-q6-v2.h	2015-12-01 05:59:03.000000000 -0500
@@ -69,6 +69,7 @@
 
 	int abort; /* set when error, like sample rate mismatch */
 
+        bool reset_event;
 	int enabled;
 	int close_ack;
 	int cmd_ack;
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c	2016-01-06 15:00:44.660590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.c	2015-12-01 05:59:03.000000000 -0500
@@ -30,12 +30,12 @@
 #include <sound/tlv.h>
 #include <sound/asound.h>
 #include <sound/pcm_params.h>
+#include <sound/q6core.h>
 #include <linux/slab.h>
 
 #include "msm-pcm-routing-v2.h"
 #include "msm-dolby-dap-config.h"
 #include "q6voice.h"
-#include "q6core.h"
 
 extern u32 score;
 struct msm_pcm_routing_bdai_data {
@@ -256,12 +256,12 @@
 	{ SLIMBUS_EXTPROC_RX, 0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_QUATERNARY_MI2S_RX, 0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_QUATERNARY_MI2S_TX, 0, 0, 0, 0, 0},
+	{ AFE_PORT_ID_TERTIARY_MI2S_RX,   0, 0, 0, 0, 0},
+	{ AFE_PORT_ID_TERTIARY_MI2S_TX,   0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_SECONDARY_MI2S_RX,  0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_SECONDARY_MI2S_TX,  0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_PRIMARY_MI2S_RX,    0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_PRIMARY_MI2S_TX,    0, 0, 0, 0, 0},
-	{ AFE_PORT_ID_TERTIARY_MI2S_RX,   0, 0, 0, 0, 0},
-	{ AFE_PORT_ID_TERTIARY_MI2S_TX,   0, 0, 0, 0, 0},
 	{ AUDIO_PORT_ID_I2S_RX,           0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_SECONDARY_PCM_RX,	  0, 0, 0, 0, 0},
 	{ AFE_PORT_ID_SECONDARY_PCM_TX,   0, 0, 0, 0, 0},
@@ -2216,11 +2216,11 @@
 	SOC_SINGLE_EXT("MI2S_TX", MSM_BACKEND_DAI_MI2S_TX,
 	MSM_FRONTEND_DAI_MULTIMEDIA2, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
-#ifdef CONFIG_SND_SOC_MAX98505
+#ifdef CONFIG_TERT_MI2S_ENABLE
 	SOC_SINGLE_EXT("TERT_MI2S_TX", MSM_BACKEND_DAI_TERTIARY_MI2S_TX,
 	MSM_FRONTEND_DAI_MULTIMEDIA2, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
-#elif defined(CONFIG_SND_SOC_MAX98504)	
+#elif defined(CONFIG_SND_SOC_MAX98504) || defined(CONFIG_SND_SOC_MAX98506)
 	SOC_SINGLE_EXT("SEC_MI2S_TX", MSM_BACKEND_DAI_SECONDARY_MI2S_TX,
 	MSM_FRONTEND_DAI_MULTIMEDIA2, 1, 0, msm_routing_get_audio_mixer,
 	msm_routing_put_audio_mixer),
@@ -3971,9 +3971,9 @@
 	{"MultiMedia1 Mixer", "SEC_MI2S_TX", "SEC_MI2S_TX"},
 	{"MultiMedia1 Mixer", "PRI_MI2S_TX", "PRI_MI2S_TX"},
 	{"MultiMedia6 Mixer", "SLIM_0_TX", "SLIMBUS_0_TX"},
-#ifdef CONFIG_SND_SOC_MAX98505
+#ifdef CONFIG_TERT_MI2S_ENABLE
 	{"MultiMedia2 Mixer", "TERT_MI2S_TX", "TERT_MI2S_TX"},
-#elif defined(CONFIG_SND_SOC_MAX98504)		
+#elif defined(CONFIG_SND_SOC_MAX98504) || defined(CONFIG_SND_SOC_MAX98506)
 	{"MultiMedia2 Mixer", "SEC_MI2S_TX", "SEC_MI2S_TX"},
 #endif
 
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h
--- a/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h	2016-01-06 15:00:44.660590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-routing-v2.h	2015-12-01 05:59:03.000000000 -0500
@@ -42,7 +42,8 @@
 #define LPASS_BE_SEC_MI2S_TX "SEC_MI2S_TX"
 #define LPASS_BE_PRI_MI2S_RX "PRI_MI2S_RX"
 #define LPASS_BE_PRI_MI2S_TX "PRI_MI2S_TX"
-#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98505)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98505) \
+ || defined (CONFIG_SND_SOC_MAX98506)
 #define LPASS_BE_TERT_MI2S_RX "TERT_MI2S_RX"
 #define LPASS_BE_TERT_MI2S_TX "TERT_MI2S_TX"
 #else
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c	2016-01-06 15:00:44.660590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-voice-v2.c	2015-12-01 05:59:03.000000000 -0500
@@ -602,7 +602,7 @@
 	|| defined(CONFIG_MACH_KLTE_CMCCDUOS) || defined(CONFIG_MACH_KLTE_CUDUOS) \
 	|| defined(CONFIG_MACH_MEGA23GEUR_OPEN)  || defined(CONFIG_MACH_MS01_EUR_3G) \
 	|| defined(CONFIG_MACH_MEGA2LTE_KTT) || defined(CONFIG_MACH_ATLANTIC3GEUR_OPEN) \
-	|| defined(CONFIG_MACH_MS01_EUR_LTE) || defined(CONFIG_MACH_MS01_KOR_LTE) || defined(CONFIG_DSDA_VIA_UART)
+	|| defined(CONFIG_MACH_MS01_EUR_LTE) || defined(CONFIG_MACH_MS01_KOR_LTE) || defined(CONFIG_DSDA_VIA_UART) || defined(CONFIG_MACH_KLTE_LTNDUOS)
 	uint32_t session_id = ucontrol->value.integer.value[14];
 #endif
 	short dha_param[12] = {0,};
@@ -615,7 +615,7 @@
 	|| defined(CONFIG_MACH_KLTE_CMCCDUOS) || defined(CONFIG_MACH_KLTE_CUDUOS) \
 	|| defined(CONFIG_MACH_MEGA23GEUR_OPEN) || defined(CONFIG_MACH_MS01_EUR_3G) \
 	|| defined(CONFIG_MACH_MEGA2LTE_KTT) || defined(CONFIG_MACH_ATLANTIC3GEUR_OPEN) \
-	|| defined(CONFIG_MACH_MS01_EUR_LTE) || defined(CONFIG_MACH_MS01_KOR_LTE) || defined(CONFIG_DSDA_VIA_UART)
+	|| defined(CONFIG_MACH_MS01_EUR_LTE) || defined(CONFIG_MACH_MS01_KOR_LTE) || defined(CONFIG_DSDA_VIA_UART) || defined(CONFIG_MACH_KLTE_LTNDUOS)
 	pr_info("%s: session_id=%#x\n", __func__, session_id);
 	return voice_sec_set_dha_data(session_id,
 		dha_mode, dha_select, dha_param);
@@ -653,7 +653,7 @@
 	|| defined(CONFIG_MACH_KLTE_CMCCDUOS) || defined(CONFIG_MACH_KLTE_CUDUOS) \
 	|| defined(CONFIG_MACH_MEGA23GEUR_OPEN) || defined(CONFIG_MACH_MS01_EUR_3G) \
 	|| defined(CONFIG_MACH_MEGA2LTE_KTT) || defined(CONFIG_MACH_ATLANTIC3GEUR_OPEN) \
-	|| defined(CONFIG_MACH_MS01_EUR_LTE) || defined(CONFIG_MACH_MS01_KOR_LTE) || defined(CONFIG_DSDA_VIA_UART)
+	|| defined(CONFIG_MACH_MS01_EUR_LTE) || defined(CONFIG_MACH_MS01_KOR_LTE) || defined(CONFIG_DSDA_VIA_UART) || defined(CONFIG_MACH_KLTE_LTNDUOS)
 	SOC_SINGLE_MULTI_EXT("Sec Set DHA data", SND_SOC_NOPM, 0, VSID_MAX, 0, 15,
 				msm_sec_dha_get, msm_sec_dha_put),
 #else
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c b/sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c
--- a/sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c	2016-01-06 15:00:44.660590655 -0500
+++ b/sound/soc/msm/qdsp6v2/msm-pcm-voip-v2.c	2015-12-01 05:59:09.000000000 -0500
@@ -145,6 +145,7 @@
 	spinlock_t dsp_lock;
 	spinlock_t dsp_ul_lock;
 
+	bool voip_reset;
 	uint32_t mode;
 	uint32_t rate_type;
 	uint32_t rate;
@@ -318,6 +319,34 @@
 /* sample rate supported */
 static unsigned int supported_sample_rates[] = {8000, 16000};
 
+static void voip_ssr_cb_fn(uint32_t opcode, void *private_data)
+{
+
+	/* Notify ASoC to send next playback/Capture to unblock write/read */
+	struct voip_drv_info *prtd = private_data;
+
+	if (opcode == 0xFFFFFFFF) {
+
+		prtd->voip_reset = true;
+		pr_debug("%s: Notify ASoC to send next playback/Capture\n",
+			__func__);
+
+		prtd->pcm_playback_irq_pos += prtd->pcm_count;
+		if (prtd->state == VOIP_STARTED)
+			snd_pcm_period_elapsed(prtd->playback_substream);
+		wake_up(&prtd->out_wait);
+
+		prtd->pcm_capture_irq_pos += prtd->pcm_capture_count;
+		if (prtd->state == VOIP_STARTED)
+			snd_pcm_period_elapsed(prtd->capture_substream);
+		wake_up(&prtd->in_wait);
+
+	} else {
+		pr_err("%s: Invalid opcode during reset : %d\n",
+			__func__, opcode);
+	}
+}
+
 /* capture path */
 static void voip_process_ul_pkt(uint8_t *voc_pkt,
 				uint32_t pkt_len,
@@ -755,10 +784,20 @@
 	int count = frames_to_bytes(runtime, frames);
 	pr_debug("%s: count = %d, frames=%d\n", __func__, count, (int)frames);
 
+	if (prtd->voip_reset) {
+		pr_debug("%s: RESET event happened during VoIP\n", __func__);
+		return -ENETRESET;
+	}
+
 	ret = wait_event_interruptible_timeout(prtd->in_wait,
 				(!list_empty(&prtd->free_in_queue) ||
 				prtd->state == VOIP_STOPPED),
 				1 * HZ);
+	if (prtd->voip_reset) {
+		pr_debug("%s: RESET event happened during VoIP\n", __func__);
+		return -ENETRESET;
+	}
+
 	if (ret > 0) {
 		if (count <= VOIP_MAX_VOC_PKT_SIZE) {
 			spin_lock_irqsave(&prtd->dsp_lock, dsp_flags);
@@ -808,11 +847,21 @@
 
 	pr_debug("%s: count = %d\n", __func__, count);
 
+	if (prtd->voip_reset) {
+		pr_debug("%s: RESET event happened during VoIP\n", __func__);
+		return -ENETRESET;
+	}
+
 	ret = wait_event_interruptible_timeout(prtd->out_wait,
 				(!list_empty(&prtd->out_queue) ||
 				prtd->state == VOIP_STOPPED),
 				1 * HZ);
 
+	if (prtd->voip_reset) {
+		pr_debug("%s: RESET event happened during VoIP\n", __func__);
+		return -ENETRESET;
+	}
+
 	if (ret > 0) {
 
 		if (count <= VOIP_MAX_VOC_PKT_SIZE) {
@@ -843,7 +892,6 @@
 			list_add_tail(&buf_node->list,
 						&prtd->free_out_queue);
 			spin_unlock_irqrestore(&prtd->dsp_ul_lock, dsp_flags);
-
 		} else {
 			pr_err("%s: Read count %d > VOIP_MAX_VOC_PKT_SIZE\n",
 				__func__, count);
@@ -903,10 +951,11 @@
 
 	if (!prtd->playback_instance && !prtd->capture_instance) {
 		if (prtd->state == VOIP_STARTED) {
+			prtd->voip_reset = false;
 			prtd->state = VOIP_STOPPED;
 			voc_end_voice_call(
 					voc_get_session_id(VOIP_SESSION_NAME));
-			voc_register_mvs_cb(NULL, NULL, prtd);
+			voc_register_mvs_cb(NULL, NULL, NULL, prtd);
 		}
 		/* release all buffer */
 		/* release in_queue and free_in_queue */
@@ -1136,8 +1185,10 @@
 			goto done;
 		}
 
+		/* Initialaizing cb variables */
 		voc_register_mvs_cb(voip_process_ul_pkt,
-				    voip_process_dl_pkt, prtd);
+				    voip_process_dl_pkt,
+				    voip_ssr_cb_fn, prtd);
 
 		ret = voc_start_voice_call(
 				voc_get_session_id(VOIP_SESSION_NAME));
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6adm.c b/sound/soc/msm/qdsp6v2/q6adm.c
--- a/sound/soc/msm/qdsp6v2/q6adm.c	2016-01-06 15:00:44.661590655 -0500
+++ b/sound/soc/msm/qdsp6v2/q6adm.c	2015-12-01 05:59:03.000000000 -0500
@@ -437,10 +437,18 @@
 		rc = -EINVAL;
 		goto adm_get_param_return;
 	}
-	if ((params_data) && (adm_get_parameters[0] <
-		ARRAY_SIZE(adm_get_parameters))) {
+	if ((params_data) && (ARRAY_SIZE(adm_get_parameters) >=
+		(1+adm_get_parameters[0])) &&
+		(params_length/sizeof(uint32_t) >=
+		adm_get_parameters[0])) {
 		for (i = 0; i < adm_get_parameters[0]; i++)
 			params_data[i] = adm_get_parameters[1+i];
+	} else {
+		pr_err("%s: Get param data not copied! get_param array size %zd, index %d, params array size %zd, index %d\n",
+		__func__, ARRAY_SIZE(adm_get_parameters),
+		(1+adm_get_parameters[0]),
+		params_length/sizeof(int),
+		adm_get_parameters[0]);
 	}
 	rc = 0;
 adm_get_param_return:
@@ -640,16 +648,29 @@
 
 			/* payload[3] is the param size, check if payload */
 			/* is big enough and has a valid param size */
-			if ((data->payload_size > (4 * sizeof(uint32_t))) &&
-				(payload[3] <= ADM_GET_PARAMETER_LENGTH) &&
-				(adm_get_parameters[0] <
-				ARRAY_SIZE(adm_get_parameters))) {
-				adm_get_parameters[0] = payload[3];
-				pr_debug("GET_PP PARAM:received parameter length: %x\n",
-						adm_get_parameters[0]);
+			if ((payload[0] == 0) && (data->payload_size >
+				(4 * sizeof(*payload))) &&
+				(data->payload_size - 4 >=
+				payload[3]) &&
+				(ARRAY_SIZE(adm_get_parameters)-1 >=
+				payload[3])) {
+				adm_get_parameters[0] = payload[3] /
+							sizeof(uint32_t);
+				/*
+				 * payload[3] is param_size which is
+				 * expressed in number of bytes
+				 */
+				pr_debug("%s: GET_PP PARAM:received parameter length: 0x%x\n",
+					__func__, adm_get_parameters[0]);
 				/* storing param size then params */
-				for (i = 0; i < payload[3]; i++)
-					adm_get_parameters[1+i] = payload[4+i];
+				for (i = 0; i < payload[3] /
+						sizeof(uint32_t); i++)
+					adm_get_parameters[1+i] =
+							payload[4+i];
+			} else {
+				adm_get_parameters[0] = -1;
+				pr_err("%s: GET_PP_PARAMS failed, setting size to %d\n",
+					__func__, adm_get_parameters[0]);
 			}
 			atomic_set(&this_adm.copp_stat[index], 1);
 			wake_up(&this_adm.wait[index]);
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6afe.c b/sound/soc/msm/qdsp6v2/q6afe.c
--- a/sound/soc/msm/qdsp6v2/q6afe.c	2016-01-06 15:00:44.661590655 -0500
+++ b/sound/soc/msm/qdsp6v2/q6afe.c	2015-12-01 05:59:09.000000000 -0500
@@ -29,8 +29,8 @@
 #ifdef USE_DSM_LOG
 #include <linux/file.h>
 #include <linux/fs.h>
-#endif
-#endif
+#endif /* USE_DSM_LOG */
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 
 enum {
 	AFE_RX_CAL,
@@ -62,8 +62,9 @@
 	struct afe_dsm_spkr_prot_calib_get_resp calib_data;
 #else
 	struct afe_spkr_prot_calib_get_resp calib_data;
-#endif
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 	int vi_tx_port;
+	int vi_rx_port;
 	uint32_t afe_sample_rates[AFE_MAX_PORTS];
 	struct aanc_data aanc_info;
 };
@@ -149,7 +150,7 @@
 			pr_err("%s rest %d state %x\n" , __func__
 			, this_afe.calib_data.res_cfg.r0_cali_q24,
 			this_afe.calib_data.res_cfg.th_vi_ca_state);
-#endif	
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 		} else
 			atomic_set(&this_afe.state, -1);
 		wake_up(&this_afe.wait[data->token]);
@@ -513,7 +514,7 @@
 	return result;
 }
 
-static int afe_spk_prot_prepare(int port, int param_id,
+static int afe_spk_prot_prepare(int src_port, int dst_port, int param_id,
 		union afe_spkr_prot_config *prot_config)
 {
 	int ret = -EINVAL;
@@ -525,17 +526,28 @@
 		pr_err("%s Invalid params\n", __func__);
 		goto fail_cmd;
 	}
-	if ((q6audio_validate_port(port) < 0)) {
-		pr_err("%s invalid port %d", __func__, port);
+	ret = q6audio_validate_port(src_port);
+	if (ret < 0) {
+		pr_err("%s: Invalid src port 0x%x ret %d",
+				__func__, src_port, ret);
+		ret = -EINVAL;
 		goto fail_cmd;
 	}
-	index = q6audio_get_port_index(port);
+	ret = q6audio_validate_port(dst_port);
+	if (ret < 0) {
+		pr_err("%s: Invalid dst port 0x%x ret %d", __func__,
+				dst_port, ret);
+		ret = -EINVAL;
+		goto fail_cmd;
+	}
+	index = q6audio_get_port_index(src_port);
 	switch (param_id) {
 	case AFE_PARAM_ID_FBSP_MODE_RX_CFG:
 		config.pdata.module_id = AFE_MODULE_FB_SPKR_PROT_RX;
 		break;
 	case AFE_PARAM_ID_FEEDBACK_PATH_CFG:
-		this_afe.vi_tx_port = port;
+		this_afe.vi_tx_port = src_port;
+		this_afe.vi_rx_port = dst_port;
 	case AFE_PARAM_ID_SPKR_CALIB_VI_PROC_CFG:
 	case AFE_PARAM_ID_MODE_VI_PROC_CFG:
 		config.pdata.module_id = AFE_MODULE_FB_SPKR_PROT_VI_PROC;
@@ -553,7 +565,7 @@
 	config.hdr.token = index;
 
 	config.hdr.opcode = AFE_PORT_CMD_SET_PARAM_V2;
-	config.param.port_id = q6audio_get_port_id(port);
+	config.param.port_id = q6audio_get_port_id(src_port);
 	config.param.payload_size = sizeof(config) - sizeof(config.hdr)
 		- sizeof(config.param);
 	config.pdata.param_id = param_id;
@@ -562,8 +574,8 @@
 	atomic_set(&this_afe.state, 1);
 	ret = apr_send_pkt(this_afe.apr, (uint32_t *) &config);
 	if (ret < 0) {
-		pr_err("%s: Setting param for port %d param[0x%x]failed\n",
-		 __func__, port, param_id);
+		pr_err("%s: port = 0x%x param = 0x%x failed %d\n",
+		__func__, src_port, param_id, ret);
 		goto fail_cmd;
 	}
 	ret = wait_event_timeout(this_afe.wait[index],
@@ -581,8 +593,8 @@
 	}
 	ret = 0;
 fail_cmd:
-	pr_debug("%s config.pdata.param_id %x status %d\n",
-	__func__, config.pdata.param_id, ret);
+	pr_debug("%s: config.pdata.param_id 0x%x status %d 0x%x\n",
+	__func__, config.pdata.param_id, ret, src_port);
 	return ret;
 }
 
@@ -607,10 +619,10 @@
 	index = q6audio_get_port_index(port);
 	switch (param_id) {
 	case AFE_PARAM_ID_FBSP_MODE_RX_CFG:
-		if(port==DSM_RX_PORT_ID)
-		config.pdata.module_id = AFE_PARAM_ID_ENABLE_DSM_RX;
+		if(port == maxdsm_get_port_id())
+			config.pdata.module_id = maxdsm_get_rx_mod_id();
 		else
-		config.pdata.module_id = AFE_PARAM_ID_ENABLE_DSM_TX;			
+			config.pdata.module_id = maxdsm_get_tx_mod_id();
 		break;
 	case AFE_PARAM_ID_FEEDBACK_PATH_CFG:
 		this_afe.vi_tx_port = port;
@@ -663,8 +675,7 @@
 	__func__, config.pdata.param_id, ret);
 	return ret;
 }
-
-#endif
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 
 static void afe_send_cal_spkr_prot_tx(int port_id)
 {
@@ -683,7 +694,7 @@
 		else
 			afe_spk_config.mode_rx_cfg.mode =
 			Q6AFE_MSM_SPKR_PROCESSING;
-		if (afe_spk_prot_prepare(port_id,
+		if (afe_spk_prot_prepare(port_id, 0,
 			AFE_PARAM_ID_MODE_VI_PROC_CFG,
 			&afe_spk_config))
 			pr_err("%s TX VI_PROC_CFG failed\n", __func__);
@@ -693,7 +704,7 @@
 			(uint32_t) prot_cfg.r0;
 			afe_spk_config.vi_proc_cfg.t0_cali_q6 =
 			(uint32_t) prot_cfg.t0;
-			if (afe_spk_prot_prepare(port_id,
+			if (afe_spk_prot_prepare(port_id, 0,
 				AFE_PARAM_ID_SPKR_CALIB_VI_PROC_CFG,
 				&afe_spk_config))
 				pr_err("%s SPKR_CALIB_VI_PROC_CFG failed\n",
@@ -710,7 +721,8 @@
 	/*Get spkr protection cfg data*/
 	get_spk_protection_cfg(&prot_cfg);
 
-	if (prot_cfg.mode != MSM_SPKR_PROT_DISABLED) {
+	if ((prot_cfg.mode != MSM_SPKR_PROT_DISABLED) &&
+		(this_afe.vi_rx_port == port_id)) {
 		if (prot_cfg.mode == MSM_SPKR_PROT_CALIBRATION_IN_PROGRESS)
 			afe_spk_config.mode_rx_cfg.mode =
 			Q6AFE_MSM_SPKR_CALIBRATION;
@@ -718,7 +730,7 @@
 			afe_spk_config.mode_rx_cfg.mode =
 			Q6AFE_MSM_SPKR_PROCESSING;
 		afe_spk_config.mode_rx_cfg.minor_version = 1;
-		if (afe_spk_prot_prepare(port_id,
+		if (afe_spk_prot_prepare(port_id, 0,
 			AFE_PARAM_ID_FBSP_MODE_RX_CFG,
 			&afe_spk_config))
 			pr_err("%s RX MODE_VI_PROC_CFG failed\n",
@@ -794,7 +806,7 @@
 
 void afe_send_cal(u16 port_id)
 {
-	pr_debug("%s\n", __func__);
+	pr_debug("%s: port_id=0x%x\n", __func__, port_id);
 
 	if (afe_get_port_type(port_id) == MSM_AFE_PORT_TYPE_TX) {
 		afe_send_cal_spkr_prot_tx(port_id);
@@ -1581,6 +1593,7 @@
 	case SLIMBUS_2_RX: return IDX_SLIMBUS_2_RX;
 	case SLIMBUS_2_TX: return IDX_SLIMBUS_2_TX;
 	case SLIMBUS_3_RX: return IDX_SLIMBUS_3_RX;
+	case SLIMBUS_3_TX: return IDX_SLIMBUS_3_TX;
 	case INT_BT_SCO_RX: return IDX_INT_BT_SCO_RX;
 	case INT_BT_SCO_TX: return IDX_INT_BT_SCO_TX;
 	case INT_BT_A2DP_RX: return IDX_INT_BT_A2DP_RX;
@@ -3087,8 +3100,10 @@
 		return -EINVAL;
 
 	ret = afe_q6_interface_prepare();
-	if (ret != 0)
+	if (ret != 0) {
+		pr_err("%s: Interface prepare failed \n", __func__);
 		return ret;
+	}
 
 	clk_cfg.hdr.hdr_field = APR_HDR_FIELD(APR_MSG_TYPE_SEQ_CMD,
 				APR_HDR_LEN(APR_HDR_SIZE), APR_PKT_VER);
@@ -3109,7 +3124,7 @@
 	clk_cfg.pdata.param_size =  sizeof(clk_cfg.clk_cfg);
 	clk_cfg.clk_cfg = *cfg;
 
-	pr_debug("%s: Minor version =%x clk val1 = %d\n"
+	pr_info("%s: Minor version =%x clk val1 = %d\n"
 		 "clk val2 = %d, clk src = %x\n"
 		 "clk root = %x clk mode = %x resrv = %x\n"
 		 "port id = %x\n",
@@ -3307,7 +3322,10 @@
 int afe_dsm_spk_prot_get_calib_data(struct afe_dsm_spkr_prot_get_vi_calib *calib_resp)
 {
 	int ret = -EINVAL;
-	int index = 0, port = DSM_RX_PORT_ID;
+	int index = 0, port = maxdsm_get_port_id();
+
+	pr_info("%s: port_id = 0x%x, module_id = 0x%x\n",
+		__func__, q6audio_get_port_id(port), maxdsm_get_rx_mod_id());
 
 	if (!calib_resp) {
 		pr_err("%s Invalid params\n", __func__);
@@ -3327,17 +3345,18 @@
 	calib_resp->get_param.hdr.token = index;
 	calib_resp->get_param.hdr.opcode =  AFE_PORT_CMD_GET_PARAM_V2;
 	calib_resp->get_param.mem_map_handle = 0;
-	calib_resp->get_param.module_id = AFE_PARAM_ID_ENABLE_DSM_RX;//AFE_MODULE_FB_SPKR_PROT_VI_PROC;
+	calib_resp->get_param.module_id = maxdsm_get_rx_mod_id();
 	calib_resp->get_param.param_id = AFE_PARAM_ID_CALIB_RES_CFG;
 	calib_resp->get_param.payload_address_lsw = 0;
 	calib_resp->get_param.payload_address_msw = 0;
 	calib_resp->get_param.payload_size = sizeof(*calib_resp)
 		- sizeof(calib_resp->get_param);
 	calib_resp->get_param.port_id = q6audio_get_port_id(port);
-	calib_resp->pdata.module_id = AFE_PARAM_ID_ENABLE_DSM_RX;//AFE_MODULE_FB_SPKR_PROT_VI_PROC;
+	calib_resp->pdata.module_id = maxdsm_get_rx_mod_id();
 	calib_resp->pdata.param_id = AFE_PARAM_ID_CALIB_RES_CFG;
 	calib_resp->pdata.param_size = sizeof(calib_resp->res_cfg);
 	atomic_set(&this_afe.state, 1);
+
 	ret = apr_send_pkt(this_afe.apr, (uint32_t *)calib_resp);
 	if (ret < 0) {
 		pr_err("%s: get param port %d param id[0x%x]failed\n",
@@ -3363,8 +3382,7 @@
 fail_cmd:
 	return ret;
 }
-
-#endif
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 
 int afe_spk_prot_feed_back_cfg(int src_port, int dst_port,
 	int l_ch, int r_ch, u32 enable)
@@ -3376,6 +3394,7 @@
 	if (!enable) {
 		pr_debug("%s Disable Feedback tx path", __func__);
 		this_afe.vi_tx_port = -1;
+		this_afe.vi_rx_port = -1;
 		return 0;
 	}
 
@@ -3404,197 +3423,153 @@
 	}
 	prot_config.feedback_path_cfg.num_channels = index;
 	prot_config.feedback_path_cfg.minor_version = 1;
-	ret = afe_spk_prot_prepare(src_port,
+	ret = afe_spk_prot_prepare(src_port, dst_port,
 			AFE_PARAM_ID_FEEDBACK_PATH_CFG, &prot_config);
 fail_cmd:
 	return ret;
 }
 
 #ifdef CONFIG_SND_SOC_MAXIM_DSM
-int afe_dsm_spk_prot_feed_back_cfg(int src_port, struct afe_dsm_filter_set_params_t *dsm_set_config)
+int afe_dsm_spk_prot_feed_back_cfg(int src_port,
+		struct afe_dsm_filter_set_params_t *dsm_set_config)
 {
 	return afe_dsm_spk_prot_prepare(src_port,
-			AFE_PARAM_ID_FBSP_MODE_RX_CFG, (union afe_dsm_spkr_prot_config *)dsm_set_config);
+			AFE_PARAM_ID_FBSP_MODE_RX_CFG,
+			(union afe_dsm_spkr_prot_config *)dsm_set_config);
 }
 
-int32_t dsm_open(int32_t port_id, uint32_t* dsm_params, u8 *user_params)
-{
-  int32_t  ret = 0;
-  uint32_t *user_data = (uint32_t *) user_params;
+static int dsm_get_afe_params(
+		void *param,
+		int param_size,
+		void *data,
+		int index)
+{
+	struct maxim_dsm *maxdsm = (struct maxim_dsm*)data;
+	unsigned int *p = (unsigned int*)param;
+	int idx = index;
+	int binfo_idx = 0;
+	int i;
 
-  switch(*dsm_params) {
-    case DSM_ID_FILTER_GET_AFE_PARAMS:
-    {
-		struct afe_dsm_spkr_prot_get_vi_calib	calib_resp;
+	for (i=0;i<param_size;i++) {
+		maxdsm->param[idx++] = *(p+i);
+		binfo_idx = (idx - 1) >> 1;
+		maxdsm->param[idx++] = 1 << maxdsm->binfo[binfo_idx];
+#ifdef USE_DSM_DEBUG
+		pr_info("%s: [%d,%d]: 0x%08x, 0x%08x\n",
+				__func__,
+				idx - 2, idx -1,
+				maxdsm->param[idx - 2], maxdsm->param[idx - 1]);
+#endif /* USE_DSM_DEBUG */
+	}
 
-		if (!afe_dsm_spk_prot_get_calib_data(&calib_resp)) {
-			if(user_data) {
-				int idx = 0;
-				user_data[idx++] = calib_resp.res_cfg.coilTemp;
-				user_data[idx++] = (1 << 19);
-				user_data[idx++] = calib_resp.res_cfg.excursionMeasure;
-				user_data[idx++] = 1;
-				user_data[idx++] = calib_resp.res_cfg.dcResistance;
-				user_data[idx++] = (1 << 27);
-				user_data[idx++] = calib_resp.res_cfg.qualityfactor;
-				user_data[idx++] = (1 << 29);
-				user_data[idx++] = calib_resp.res_cfg.resonanceFreq;
-				user_data[idx++] = (1 << 9);
-				user_data[idx++] = calib_resp.res_cfg.excursionlimit;
-				user_data[idx++] = (1 << 27);
-				user_data[idx++] = calib_resp.res_cfg.rdcroomtemp;
-				user_data[idx++] = (1 << 27);
-				user_data[idx++] = calib_resp.res_cfg.coilthermallimit;
-				user_data[idx++] = (1 << 19);
-				user_data[idx++] = calib_resp.res_cfg.releasetime;
-				user_data[idx++] = (1 << 30);
-				user_data[idx++] = calib_resp.res_cfg.dsmenabled;
-				user_data[idx++] = 1;
-				user_data[idx++] = calib_resp.res_cfg.staticgain;
-				user_data[idx++] = (1 << 29);
-				user_data[idx++] = calib_resp.res_cfg.lfxgain;
-				user_data[idx++] = (1 << 30);
-				user_data[idx++] = calib_resp.res_cfg.pilotgain;
-				user_data[idx++] = (1 << 31);
-				user_data[idx++] = calib_resp.res_cfg.flagToWrite;
-				user_data[idx++] = 1;
-				user_data[idx++] = calib_resp.res_cfg.featureSetEnable;
-				user_data[idx++] = 1;
-				user_data[idx++] = calib_resp.res_cfg.smooFacVoltClip;
-				user_data[idx++] = (1 << 30);
-				user_data[idx++] = calib_resp.res_cfg.highPassCutOffFactor;
-				user_data[idx++] = (1 << 30);
-				user_data[idx++] = calib_resp.res_cfg.leadResistance;
-				user_data[idx++] = (1 << 27);
-				user_data[idx++] = calib_resp.res_cfg.rmsSmooFac;
-				user_data[idx++] = (1 << 31);
-				user_data[idx++] = calib_resp.res_cfg.clipLimit;
-				user_data[idx++] = (1 << 27);
-				user_data[idx++] = calib_resp.res_cfg.thermalCoeff;
-				user_data[idx++] = (1 << 20);
-				user_data[idx++] = calib_resp.res_cfg.qSpk;
-				user_data[idx++] = (1 << 29);
-				user_data[idx++] = calib_resp.res_cfg.excurLoggingThresh;
-				user_data[idx++] = 1;
-				user_data[idx++] = calib_resp.res_cfg.coilTempLoggingThresh;
-				user_data[idx++] = 1;
-				user_data[idx++] = calib_resp.res_cfg.resFreq;
-				user_data[idx++] = (1 << 9);
-				user_data[idx++] = calib_resp.res_cfg.resFreqGuardBand;
-				user_data[idx++] = (1 << 9);
+	return idx;
+}
 
-				#ifdef USE_DSM_LOG
-				if (likely(calib_resp.res_cfg.byteLogArray[0] & 0x3)) {
-					maxdsm_log_update(calib_resp.res_cfg.byteLogArray, calib_resp.res_cfg.intLogArray, calib_resp.res_cfg.afterProbByteLogArray, calib_resp.res_cfg.afterProbIntLogArray);
-				}
-				#endif /* USE_DSM_LOG */
+static int dsm_set_afe_params(
+		void *param,
+		int param_size,
+		void *data,
+		int index)
+{
+	struct maxim_dsm *maxdsm = (struct maxim_dsm*)data;
+	unsigned int *p = (unsigned int*)param;
+	int idx = index;
+	int i;
+
+	for (i=0;i<param_size;i++) {
+		*(p+i) = maxdsm->param[idx];
+		idx += 2;
+#ifdef USE_DSM_DEBUG
+		pr_info("%s: [%d,%d]: 0x%08x / 0x%08x -> 0x%08x\n",
+				__func__,
+				idx - 2, idx - 1,
+				maxdsm->param[idx - 2], maxdsm->param[idx - 1],
+				*(p+i));
+#endif /* USE_DSM_DEBUG */
 			}
-#ifdef DEBUG_DSM
-      pr_info("DSM(0) - GET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-              __func__, calib_resp.res_cfg.coilTemp,
-                        calib_resp.res_cfg.excursionMeasure,
-                        calib_resp.res_cfg.dcResistance,
-                        calib_resp.res_cfg.qualityfactor,
-                        calib_resp.res_cfg.resonanceFreq);
-      pr_info("DSM(1) - GET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-              __func__, calib_resp.res_cfg.excursionlimit,
-                        calib_resp.res_cfg.rdcroomtemp,
-                        calib_resp.res_cfg.coilthermallimit,
-                        calib_resp.res_cfg.releasetime,
-                        calib_resp.res_cfg.dsmenabled);
-      pr_info("DSM(2) - GET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-              __func__, calib_resp.res_cfg.staticgain,
-                        calib_resp.res_cfg.lfxgain,
-                        calib_resp.res_cfg.pilotgain,
-                        calib_resp.res_cfg.flagToWrite,
-                        calib_resp.res_cfg.featureSetEnable);
-      pr_info("DSM(3) - GET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-              __func__, calib_resp.res_cfg.smooFacVoltClip,
-                        calib_resp.res_cfg.highPassCutOffFactor,
-                        calib_resp.res_cfg.leadResistance,
-                        calib_resp.res_cfg.rmsSmooFac,
-                        calib_resp.res_cfg.clipLimit);
-      pr_info("DSM(4) - GET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-              __func__, calib_resp.res_cfg.thermalCoeff,
-                        calib_resp.res_cfg.qSpk,
-                        calib_resp.res_cfg.excurLoggingThresh,
-                        calib_resp.res_cfg.coilTempLoggingThresh,
-                        calib_resp.res_cfg.resFreq);
-      pr_info("DSM(5) - GET_PARAMS parameters %s: %8x\n",
-              __func__, calib_resp.res_cfg.resFreqGuardBand);
-#endif
+
+	return idx;
+}
+
+static int dsm_get_param_size(int version)
+{
+	int param_size = 0;
+
+	switch (version) {
+	case VERSION_3_0:
+		param_size = PARAM_DSM_3_0_MAX;
+		break;
+	case VERSION_3_5_B:
+		param_size = PARAM_DSM_3_5_MAX;
+		break;
+	case VERSION_4_0_B:
+		param_size = PARAM_DSM_4_0_MAX;
+		break;
+	default:
+		param_size = -EINVAL;
 	      break;
 		}
-		goto fail_cmd;
-    }
-    case DSM_ID_FILTER_SET_AFE_CNTRLS:
-    {
+
+#ifdef USE_DSM_DEBUG
+	pr_info("%s: param_size: %d, version: %d\n",
+			__func__, param_size, version);
+#endif /* USE_DSM_DEBUG */
+
+	return param_size;
+}
+
+int32_t dsm_open(void *data)
+{
+	struct afe_dsm_spkr_prot_get_vi_calib calib_resp;
       struct afe_dsm_filter_set_params_t filter_params;
 
-      if(user_data) {
-		filter_params.excursionlimit = user_data[10];
-		filter_params.rdcroomtemp = user_data[12];
-		filter_params.coilthermallimit = user_data[14];
-		filter_params.releasetime = user_data[16];
-		filter_params.dsmenabled = user_data[18];
-		filter_params.staticgain = user_data[20];
-		filter_params.lfxgain = user_data[22];
-		filter_params.pilotgain = user_data[24];
-		filter_params.flagToWrite = user_data[26];
-		filter_params.featureSetEnable = user_data[28];
-		filter_params.smooFacVoltClip = user_data[30];
-		filter_params.highPassCutOffFactor = user_data[32];
-		filter_params.leadResistance = user_data[34];
-		filter_params.rmsSmooFac = user_data[36];
-		filter_params.clipLimit = user_data[38];
-		filter_params.thermalCoeff = user_data[40];
-		filter_params.qSpk = user_data[42];
-		filter_params.excurLoggingThresh = user_data[44];
-		filter_params.coilTempLoggingThresh = user_data[46];
-		filter_params.resFreq = user_data[48];
-		filter_params.resFreqGuardBand = user_data[50];
-
-#ifdef DEBUG_DSM
-		pr_info("DSM(0) - SET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-				__func__, filter_params.excursionlimit,
-						filter_params.rdcroomtemp,
-						filter_params.coilthermallimit,
-						filter_params.releasetime,
-						filter_params.dsmenabled);
-		pr_info("DSM(1) - SET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-			  __func__, filter_params.staticgain,
-						filter_params.lfxgain,
-						filter_params.pilotgain,
-						filter_params.flagToWrite,
-						filter_params.featureSetEnable);
-		pr_info("DSM(2) - SET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-			  __func__, filter_params.smooFacVoltClip,
-						filter_params.highPassCutOffFactor,
-						filter_params.leadResistance,
-						filter_params.rmsSmooFac,
-						filter_params.clipLimit);
-		pr_info("DSM(3) - SET_PARAMS parameters %s: %8x, %8x, %8x, %8x, %8x\n",
-			  __func__, filter_params.thermalCoeff,
-						filter_params.qSpk,
-                        filter_params.excurLoggingThresh,
-                        filter_params.coilTempLoggingThresh,
-                        filter_params.resFreq);
-		pr_info("DSM(4) - SET_PARAMS parameters %s: %8x\n",
-			  __func__, filter_params.resFreqGuardBand);
+	struct maxim_dsm *maxdsm = (struct maxim_dsm*)data;
+	uint32_t dsm_params = maxdsm->filter_set;
+	uint32_t version = maxdsm->version;
+	int32_t ret = 0;
 
-#endif
-		ret = afe_dsm_spk_prot_feed_back_cfg(DSM_RX_PORT_ID, &filter_params);
+	pr_info("%s: dsm_params: %d\n", __func__, dsm_params);
+	switch (dsm_params) {
+	case DSM_ID_FILTER_GET_AFE_PARAMS:
+		if (afe_dsm_spk_prot_get_calib_data(&calib_resp)) {
+			ret = -EINVAL;
+			break;
      }
+		if (maxdsm->param && maxdsm->binfo) {
+			dsm_get_afe_params(
+					&calib_resp.res_cfg.dcResistance,
+					(int)(dsm_get_param_size(version) >> 1),
+					maxdsm,
+					0);
+#ifdef USE_DSM_LOG
+			if (likely(calib_resp.res_cfg.byteLogArray[0] & 0x3)) {
+				maxdsm_log_update(calib_resp.res_cfg.byteLogArray,
+						calib_resp.res_cfg.intLogArray,
+						calib_resp.res_cfg.afterProbByteLogArray,
+						calib_resp.res_cfg.afterProbIntLogArray);
+			}
+#endif /* USE_DSM_LOG */
+		}
+		break;
+	case DSM_ID_FILTER_SET_AFE_CNTRLS:
+		if (!maxdsm->param || !maxdsm->binfo) {
+			ret = -EINVAL;
        break;
     }
-    default:
-      goto fail_cmd;
+		dsm_set_afe_params(
+				&filter_params.dcResistance,
+				(int)(dsm_get_param_size(version) >> 1),
+				maxdsm,
+				0);
+		ret = afe_dsm_spk_prot_feed_back_cfg(maxdsm_get_port_id(),
+				&filter_params);
+		break;
   }
-fail_cmd:
-  return ret;
+	pr_info("%s: ret=%d\n", __func__, ret);
 
-} // dsm_open()  
-#endif
+	return ret;
+}
+#endif /* CONFIG_SND_SOC_MAXIM_DSM */
 
 static int __init afe_init(void)
 {
@@ -3606,6 +3581,7 @@
 	this_afe.dtmf_gen_rx_portid = -1;
 	this_afe.mmap_handle = 0;
 	this_afe.vi_tx_port = -1;
+	this_afe.vi_rx_port = -1;
 	for (i = 0; i < AFE_MAX_PORTS; i++)
 		init_waitqueue_head(&this_afe.wait[i]);
 
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6asm.c b/sound/soc/msm/qdsp6v2/q6asm.c
--- a/sound/soc/msm/qdsp6v2/q6asm.c	2016-01-06 15:00:44.662590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6asm.c	2015-12-01 05:59:03.000000000 -0500
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2012-2015, The Linux Foundation. All rights reserved.
+ * Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
  * Author: Brian Swetland <swetland@google.com>
  *
  * This software is licensed under the terms of the GNU General Public
@@ -385,14 +385,6 @@
 	return;
 }
 
-static uint32_t q6asm_get_next_buf(uint32_t curr_buf, uint32_t max_buf_cnt)
-{
-	pr_debug("%s: curr_buf = %d, max_buf_cnt = %d\n",
-		 __func__, curr_buf, max_buf_cnt);
-	curr_buf += 1;
-	return (curr_buf >= max_buf_cnt) ? 0 : curr_buf;
-}
-
 void send_asm_custom_topology(struct audio_client *ac)
 {
 	struct acdb_cal_block		cal_block;
@@ -684,7 +676,7 @@
 
 		while (cnt >= 0) {
 			if (port->buf[cnt].data) {
-				if (!rc)
+				if (!rc || atomic_read(&ac->reset))
 					msm_audio_ion_free(
 						port->buf[cnt].client,
 						port->buf[cnt].handle);
@@ -734,7 +726,7 @@
 			(void *)&port->buf[0].phys,
 			(void *)port->buf[0].client,
 			(void *)port->buf[0].handle);
-		if (!rc)
+		if (!rc || atomic_read(&ac->reset))
 			msm_audio_ion_free(port->buf[0].client,
 					   port->buf[0].handle);
 		port->buf[0].client = NULL;
@@ -894,6 +886,7 @@
 	init_waitqueue_head(&ac->time_wait);
 	init_waitqueue_head(&ac->mem_wait);
 	atomic_set(&ac->time_flag, 1);
+	atomic_set(&ac->reset, 0);
 	INIT_LIST_HEAD(&ac->port[0].mem_map_handle);
 	INIT_LIST_HEAD(&ac->port[1].mem_map_handle);
 	pr_debug("%s: mem_map_handle list init'ed\n", __func__);
@@ -1132,11 +1125,7 @@
 	payload = data->payload;
 
 	if (data->opcode == RESET_EVENTS) {
-		struct audio_client *ac_mmap = (struct audio_client *)priv;
-		if (ac_mmap == NULL) {
-			pr_err("%s ac or priv NULL\n", __func__);
-			return -EINVAL;
-		}
+
 		pr_debug("%s: Reset event is received: %d %d apr[%p]\n",
 				__func__,
 				data->reset_event,
@@ -1145,7 +1134,6 @@
 		atomic_set(&this_mmap.ref_cnt, 0);
 		apr_reset(this_mmap.apr);
 		this_mmap.apr = NULL;
-		ac_mmap->mmap_apr = NULL;
 		for (; i <= OUT; i++) {
 			list_for_each_safe(ptr, next,
 				&common_client.port[i].mem_map_handle) {
@@ -1295,9 +1283,9 @@
 	}
 
 	if (data->opcode == RESET_EVENTS) {
-		if(ac->apr == NULL) {
+		atomic_set(&ac->reset, 1);
+		if (ac->apr == NULL)
 		    ac->apr = ac->apr2;
-		}
 		pr_debug("q6asm_callback: Reset event is received: %d %d apr[%p]\n",
 				data->reset_event, data->reset_proc, ac->apr);
 			if (ac->cb)
@@ -1305,6 +1293,10 @@
 					(uint32_t *)data->payload, ac->priv);
 		apr_reset(ac->apr);
 		ac->apr = NULL;
+		atomic_set(&ac->time_flag, 0);
+		atomic_set(&ac->cmd_state, 0);
+		wake_up(&ac->time_wait);
+		wake_up(&ac->cmd_wait);
 		return 0;
 	}
 
@@ -1556,8 +1548,7 @@
 		user accesses this function,increase cpu
 		buf(to avoid another api)*/
 		port->buf[idx].used = dir;
-		port->cpu_buf = q6asm_get_next_buf(port->cpu_buf,
-						   port->max_buf_cnt);
+		port->cpu_buf = ((port->cpu_buf + 1) & (port->max_buf_cnt - 1));
 		mutex_unlock(&port->lock);
 		return data;
 	}
@@ -1606,8 +1597,7 @@
 	 * buf(to avoid another api)
 	 */
 	port->buf[idx].used = dir;
-	port->cpu_buf = q6asm_get_next_buf(port->cpu_buf,
-					   port->max_buf_cnt);
+	port->cpu_buf = ((port->cpu_buf + 1) & (port->max_buf_cnt - 1));
 	return data;
 }
 
@@ -3725,7 +3715,7 @@
 	}
 
 	sz = sizeof(struct asm_stream_cmd_set_pp_params_sa);
-	q6asm_add_hdr_async(ac, &cmd.hdr, sz, false);
+	q6asm_add_hdr_async(ac, &cmd.hdr, sz, TRUE);
 
 	cmd.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
 	cmd.param.data_payload_addr_lsw = 0;
@@ -3781,7 +3771,7 @@
 	}
 
 	sz = sizeof(struct asm_stream_cmd_set_pp_params_vsp);
-	q6asm_add_hdr_async(ac, &cmd.hdr, sz, false);
+	q6asm_add_hdr_async(ac, &cmd.hdr, sz, TRUE);
 
 	cmd.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
 	cmd.param.data_payload_addr_lsw = 0;
@@ -3821,7 +3811,7 @@
 	}
 
 	sz = sizeof(struct asm_stream_cmd_set_pp_params_dha);
-	q6asm_add_hdr_async(ac, &cmd.hdr, sz, false);
+	q6asm_add_hdr_async(ac, &cmd.hdr, sz, TRUE);
 
 	cmd.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
 	cmd.param.data_payload_addr_lsw = 0;
@@ -3860,7 +3850,7 @@
 	}
 
 	sz = sizeof(struct asm_stream_cmd_set_pp_params_lrsm);
-	q6asm_add_hdr_async(ac, &cmd.hdr, sz, false);
+	q6asm_add_hdr_async(ac, &cmd.hdr, sz, TRUE);
 
 	cmd.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
 	cmd.param.data_payload_addr_lsw = 0;
@@ -3898,7 +3888,7 @@
 	}
 
 	sz = sizeof(struct asm_stream_cmd_set_pp_params_sa_ep);
-	q6asm_add_hdr_async(ac, &cmd.hdr, sz, false);
+	q6asm_add_hdr_async(ac, &cmd.hdr, sz, TRUE);
 
 	cmd.hdr.opcode = ASM_STREAM_CMD_SET_PP_PARAMS_V2;
 	cmd.param.data_payload_addr_lsw = 0;
@@ -4092,8 +4082,7 @@
 		read.buf_size = ab->size;
 		read.seq_id = port->dsp_buf;
 		read.hdr.token = port->dsp_buf;
-		port->dsp_buf = q6asm_get_next_buf(port->dsp_buf,
-						   port->max_buf_cnt);
+		port->dsp_buf = (port->dsp_buf + 1) & (port->max_buf_cnt - 1);
 		mutex_unlock(&port->lock);
 		pr_debug("%s:buf add[0x%x] token[%d] uid[%d]\n", __func__,
 						read.buf_addr_lsw,
@@ -4156,8 +4145,7 @@
 			}
 		}
 
-		port->dsp_buf = q6asm_get_next_buf(port->dsp_buf,
-						   port->max_buf_cnt);
+		port->dsp_buf = (port->dsp_buf + 1) & (port->max_buf_cnt - 1);
 		pr_debug("%s:buf add[0x%x] token[%d] uid[%d]\n", __func__,
 					read.buf_addr_lsw,
 					read.hdr.token,
@@ -4348,8 +4336,7 @@
 			write.flags = (0x00000000 | (flags & 0x800000FF));
 		else
 			write.flags = (0x80000000 | flags);
-		port->dsp_buf = q6asm_get_next_buf(port->dsp_buf,
-						   port->max_buf_cnt);
+		port->dsp_buf = (port->dsp_buf + 1) & (port->max_buf_cnt - 1);
 		buf_node = list_first_entry(&ac->port[IN].mem_map_handle,
 						struct asm_buffer_node,
 						list);
@@ -4420,8 +4407,7 @@
 			write.flags = (0x00000000 | (flags & 0x800000FF));
 		else
 			write.flags = (0x80000000 | flags);
-		port->dsp_buf = q6asm_get_next_buf(port->dsp_buf,
-						   port->max_buf_cnt);
+		port->dsp_buf = (port->dsp_buf + 1) & (port->max_buf_cnt - 1);
 
 		pr_debug("%s:ab->phys[0x%x]bufadd[0x%x]token[0x%x] buf_id[0x%x]buf_size[0x%x]mmaphdl[0x%x]"
 							, __func__,
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6audio-v2.c b/sound/soc/msm/qdsp6v2/q6audio-v2.c
--- a/sound/soc/msm/qdsp6v2/q6audio-v2.c	2016-01-06 15:00:44.662590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6audio-v2.c	2015-12-01 05:59:03.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -80,6 +80,67 @@
 	}
 }
 
+int q6audio_get_port_id_from_index(u16 port_idx)
+{
+	switch (port_idx) {
+	case IDX_PRIMARY_I2S_RX: return PRIMARY_I2S_RX;
+	case IDX_PRIMARY_I2S_TX: return PRIMARY_I2S_TX;
+	case IDX_AFE_PORT_ID_PRIMARY_PCM_RX:
+		return AFE_PORT_ID_PRIMARY_PCM_RX;
+	case IDX_AFE_PORT_ID_PRIMARY_PCM_TX:
+		return AFE_PORT_ID_PRIMARY_PCM_TX;
+	case IDX_AFE_PORT_ID_SECONDARY_PCM_RX:
+		return AFE_PORT_ID_SECONDARY_PCM_RX;
+	case IDX_AFE_PORT_ID_SECONDARY_PCM_TX:
+		return AFE_PORT_ID_SECONDARY_PCM_TX;
+	case IDX_SECONDARY_I2S_RX: return SECONDARY_I2S_RX;
+	case IDX_SECONDARY_I2S_TX: return SECONDARY_I2S_TX;
+	case IDX_MI2S_RX: return MI2S_RX;
+	case IDX_MI2S_TX: return MI2S_TX;
+	case IDX_HDMI_RX: return HDMI_RX;
+	case IDX_RSVD_2: return RSVD_2;
+	case IDX_RSVD_3: return RSVD_3;
+	case IDX_DIGI_MIC_TX: return DIGI_MIC_TX;
+	case IDX_VOICE_RECORD_RX: return VOICE_RECORD_RX;
+	case IDX_VOICE_RECORD_TX: return VOICE_RECORD_TX;
+	case IDX_VOICE_PLAYBACK_TX: return VOICE_PLAYBACK_TX;
+	case IDX_VOICE2_PLAYBACK_TX: return VOICE2_PLAYBACK_TX;
+	case IDX_SLIMBUS_0_RX: return SLIMBUS_0_RX;
+	case IDX_SLIMBUS_0_TX: return SLIMBUS_0_TX;
+	case IDX_SLIMBUS_1_RX: return SLIMBUS_1_RX;
+	case IDX_SLIMBUS_1_TX: return SLIMBUS_1_TX;
+	case IDX_SLIMBUS_2_RX: return SLIMBUS_2_RX;
+	case IDX_SLIMBUS_2_TX: return SLIMBUS_2_TX;
+	case IDX_SLIMBUS_4_TX: return SLIMBUS_4_TX;
+	case IDX_SLIMBUS_5_TX: return SLIMBUS_5_TX;
+	case IDX_INT_BT_SCO_RX: return INT_BT_SCO_RX;
+	case IDX_INT_BT_SCO_TX: return INT_BT_SCO_TX;
+	case IDX_INT_BT_A2DP_RX: return INT_BT_A2DP_RX;
+	case IDX_INT_FM_RX: return INT_FM_RX;
+	case IDX_INT_FM_TX: return INT_FM_TX;
+	case IDX_RT_PROXY_PORT_001_RX: return RT_PROXY_PORT_001_RX;
+	case IDX_RT_PROXY_PORT_001_TX: return RT_PROXY_PORT_001_TX;
+	case IDX_AFE_PORT_ID_PRIMARY_MI2S_RX:
+		return AFE_PORT_ID_PRIMARY_MI2S_RX;
+	case IDX_AFE_PORT_ID_PRIMARY_MI2S_TX:
+		return AFE_PORT_ID_PRIMARY_MI2S_TX;
+	case IDX_AFE_PORT_ID_QUATERNARY_MI2S_RX:
+		return AFE_PORT_ID_QUATERNARY_MI2S_RX;
+	case IDX_AFE_PORT_ID_QUATERNARY_MI2S_TX:
+		return AFE_PORT_ID_QUATERNARY_MI2S_TX;
+	case IDX_AFE_PORT_ID_SECONDARY_MI2S_RX:
+		return AFE_PORT_ID_SECONDARY_MI2S_RX;
+	case IDX_AFE_PORT_ID_SECONDARY_MI2S_TX:
+		return AFE_PORT_ID_SECONDARY_MI2S_TX;
+	case IDX_AFE_PORT_ID_TERTIARY_MI2S_RX:
+		return AFE_PORT_ID_TERTIARY_MI2S_RX;
+	case IDX_AFE_PORT_ID_TERTIARY_MI2S_TX:
+		return AFE_PORT_ID_TERTIARY_MI2S_TX;
+
+	default: return -EINVAL;
+	}
+}
+
 int q6audio_get_port_id(u16 port_id)
 {
 	switch (port_id) {
@@ -237,7 +298,8 @@
 	case AFE_PORT_ID_QUATERNARY_MI2S_TX:
 	case AFE_PORT_ID_SECONDARY_MI2S_RX:
 	case AFE_PORT_ID_SECONDARY_MI2S_TX:
-#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98505)
+#if defined (CONFIG_SND_SOC_MAX98504) || defined (CONFIG_SND_SOC_MAX98505) \
+ || defined (CONFIG_SND_SOC_MAX98506)
 	case AFE_PORT_ID_TERTIARY_MI2S_RX:
 	case AFE_PORT_ID_TERTIARY_MI2S_TX:
 #endif
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6core.c b/sound/soc/msm/qdsp6v2/q6core.c
--- a/sound/soc/msm/qdsp6v2/q6core.c	2016-01-06 15:00:44.662590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6core.c	2015-12-01 05:59:03.000000000 -0500
@@ -20,10 +20,11 @@
 #include <linux/slab.h>
 #include <mach/msm_smd.h>
 #include <mach/qdsp6v2/apr.h>
-#include "q6core.h"
 #include <mach/ocmem.h>
+#include <sound/q6core.h>
 
 #define TIMEOUT_MS 1000
+#define Q6_READY_TIMEOUT_MS 100
 
 struct q6core_str {
 	struct apr_svc *core_handle_q;
@@ -237,7 +238,7 @@
 
 	rc = wait_event_timeout(q6core_lcl.bus_bw_req_wait,
 				(q6core_lcl.bus_bw_resp_received == 1),
-				msecs_to_jiffies(TIMEOUT_MS));
+				msecs_to_jiffies(Q6_READY_TIMEOUT_MS));
 	if (rc > 0 && q6core_lcl.bus_bw_resp_received) {
 		/* ensure to read updated param by callback thread */
 		rmb();
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6core.h b/sound/soc/msm/qdsp6v2/q6core.h
--- a/sound/soc/msm/qdsp6v2/q6core.h	2016-01-06 15:00:44.662590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6core.h	1969-12-31 19:00:00.000000000 -0500
@@ -1,106 +0,0 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License version 2 and
- * only version 2 as published by the Free Software Foundation.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- */
-
-#ifndef __Q6CORE_H__
-#define __Q6CORE_H__
-#include <mach/qdsp6v2/apr.h>
-#include <mach/ocmem.h>
-
-
-#define AVCS_CMD_GET_LOW_POWER_SEGMENTS_INFO              0x00012903
-
-struct avcs_cmd_get_low_power_segments_info {
-	struct apr_hdr hdr;
-} __packed;
-
-
-#define AVCS_CMDRSP_GET_LOW_POWER_SEGMENTS_INFO           0x00012904
-
-#define AVCS_CMD_ADSP_EVENT_GET_STATE		0x0001290C
-#define AVCS_CMDRSP_ADSP_EVENT_GET_STATE	0x0001290D
-
-/* @brief AVCS_CMDRSP_GET_LOW_POWER_SEGMENTS_INFO payload
- * structure. Payload for this event comprises one instance of
- * avcs_cmd_rsp_get_low_power_segments_info_t, followed
- * immediately by num_segments number of instances of the
- * avcs_mem_segment_t structure.
- */
-
-/* Types of Low Power Memory Segments. */
-#define READ_ONLY_SEGMENT      1
-/*< Read Only memory segment. */
-#define READ_WRITE_SEGMENT     2
-/*< Read Write memory segment. */
-/*Category indicates whether audio/os/sensor segments. */
-#define AUDIO_SEGMENT          1
-/*< Audio memory segment. */
-#define OS_SEGMENT             2
-/*< QDSP6's OS memory segment. */
-
-/* @brief Payload structure for AVS low power memory segment
- *  structure.
- */
-struct avcs_mem_segment_t {
-	uint16_t              type;
-/*< Indicates which type of memory this segment is.
- *Allowed values: READ_ONLY_SEGMENT or READ_WRITE_SEGMENT only.
- */
-	uint16_t              category;
-/*< Indicates whether audio or OS segments.
- *Allowed values: AUDIO_SEGMENT or OS_SEGMENT only.
- */
-	uint32_t              size;
-/*< Size (in bytes) of this segment.
- * Will be a non-zero value.
- */
-	uint32_t              start_address_lsw;
-/*< Lower 32 bits of the 64-bit physical start address
- * of this segment.
- */
-	uint32_t              start_address_msw;
-/*< Upper 32 bits of the 64-bit physical start address
- * of this segment.
- */
-};
-
-struct avcs_cmd_rsp_get_low_power_segments_info_t {
-	uint32_t              num_segments;
-/*< Number of segments in this response.
- * 0: there are no known sections that should be mapped
- * from DDR to OCMEM.
- * >0: the number of memory segments in the following list.
- */
-
-	uint32_t              bandwidth;
-/*< Required OCMEM read/write bandwidth (in bytes per second)
- * if OCMEM is granted.
- * 0 if num_segments = 0
- * >0 if num_segments > 0.
- */
-	struct avcs_mem_segment_t mem_segment[OCMEM_MAX_CHUNKS];
-};
-
-
-int core_get_low_power_segments(
-			struct avcs_cmd_rsp_get_low_power_segments_info_t **);
-bool q6core_is_adsp_ready(void);
-
-#define ADSP_CMD_SET_DOLBY_MANUFACTURER_ID 0x00012918
-
-struct adsp_dolby_manufacturer_id {
-	struct apr_hdr hdr;
-	int manufacturer_id;
-};
-
-uint32_t core_set_dolby_manufacturer_id(int manufacturer_id);
-
-#endif /* __Q6CORE_H__ */
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6lsm.c b/sound/soc/msm/qdsp6v2/q6lsm.c
--- a/sound/soc/msm/qdsp6v2/q6lsm.c	2016-01-06 15:00:44.662590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6lsm.c	2015-12-01 05:59:03.000000000 -0500
@@ -26,12 +26,12 @@
 #include <linux/atomic.h>
 #include <sound/apr_audio-v2.h>
 #include <sound/lsm_params.h>
+#include <sound/q6core.h>
 #include <sound/q6lsm.h>
 #include <asm/ioctls.h>
 #include <mach/memory.h>
 #include <mach/debug_mm.h>
 #include "audio_acdb.h"
-#include "q6core.h"
 
 #define APR_TIMEOUT	(5 * HZ)
 #define LSM_CAL_SIZE	4096
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6voice.c b/sound/soc/msm/qdsp6v2/q6voice.c
--- a/sound/soc/msm/qdsp6v2/q6voice.c	2016-01-06 15:00:44.663590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6voice.c	2015-12-01 05:59:03.000000000 -0500
@@ -29,7 +29,7 @@
 #include "q6voice.h"
 
 
-#define TIMEOUT_MS 300
+#define TIMEOUT_MS 500
 
 
 #define CMD_STATUS_SUCCESS 0
@@ -5351,10 +5351,12 @@
 
 void voc_register_mvs_cb(ul_cb_fn ul_cb,
 			   dl_cb_fn dl_cb,
+			   voip_ssr_cb ssr_cb,
 			   void *private_data)
 {
 	common.mvs_info.ul_cb = ul_cb;
 	common.mvs_info.dl_cb = dl_cb;
+	common.mvs_info.ssr_cb = ssr_cb;
 	common.mvs_info.private_data = private_data;
 }
 
@@ -5558,6 +5560,14 @@
 		} else {
 			pr_debug("%s: Reset event received in Voice service\n",
 				__func__);
+
+			if (common.mvs_info.ssr_cb) {
+				pr_debug("%s: Informing reset event to VoIP\n",
+					__func__);
+				common.mvs_info.ssr_cb(data->opcode,
+						common.mvs_info.private_data);
+			}
+
 			apr_reset(c->apr_q6_mvm);
 			c->apr_q6_mvm = NULL;
 
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/q6voice.h b/sound/soc/msm/qdsp6v2/q6voice.h
--- a/sound/soc/msm/qdsp6v2/q6voice.h	2016-01-06 15:00:44.663590656 -0500
+++ b/sound/soc/msm/qdsp6v2/q6voice.h	2015-12-01 05:59:03.000000000 -0500
@@ -1295,6 +1295,9 @@
 				  char *session,
 				  void *private_data);
 
+typedef void (*voip_ssr_cb) (uint32_t opcode,
+				void *private_data);
+
 struct mvs_driver_info {
 	uint32_t media_type;
 	uint32_t rate;
@@ -1302,6 +1305,7 @@
 	uint32_t dtx_mode;
 	ul_cb_fn ul_cb;
 	dl_cb_fn dl_cb;
+	voip_ssr_cb ssr_cb;
 	void *private_data;
 	uint32_t evrc_min_rate;
 	uint32_t evrc_max_rate;
@@ -1437,6 +1441,7 @@
 
 void voc_register_mvs_cb(ul_cb_fn ul_cb,
 			dl_cb_fn dl_cb,
+			voip_ssr_cb ssr_cb,
 			void *private_data);
 
 void voc_register_dtmf_rx_detection_cb(dtmf_rx_det_cb_fn dtmf_rx_ul_cb,
diff -X dontdiff -Nuarb a/sound/soc/msm/qdsp6v2/rtac.c b/sound/soc/msm/qdsp6v2/rtac.c
--- a/sound/soc/msm/qdsp6v2/rtac.c	2016-01-06 15:00:44.663590656 -0500
+++ b/sound/soc/msm/qdsp6v2/rtac.c	2015-12-01 05:59:03.000000000 -0500
@@ -1,4 +1,4 @@
-/* Copyright (c) 2012-2013, The Linux Foundation. All rights reserved.
+/* Copyright (c) 2012-2014, The Linux Foundation. All rights reserved.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 and
@@ -24,6 +24,7 @@
 #include <mach/qdsp6v2/rtac.h>
 #include <sound/q6asm-v2.h>
 #include <sound/q6afe-v2.h>
+#include <sound/q6audio-v2.h>
 #include <sound/apr_audio-v2.h>
 #include <q6voice.h>
 #include "audio_acdb.h"
@@ -822,6 +823,7 @@
 	u32	bytes_returned = 0;
 	u32	port_index = 0;
 	u32	copp_id;
+	int	port_id;
 	u32	payload_size;
 	u32	data_size = 0;
 	struct apr_hdr	adm_params;
@@ -880,6 +882,13 @@
 		       __func__, copp_id);
 		goto done;
 	}
+	port_id = q6audio_get_port_id_from_index(port_index);
+
+	if (port_id < 0) {
+		pr_err("%s: Could not find port id mapped for port_idx %d\n",
+		       __func__, port_index);
+		goto done;
+	}
 
 	mutex_lock(&rtac_adm_apr_mutex);
 	if (rtac_adm_apr_data.apr_handle == NULL) {
@@ -936,7 +945,7 @@
 	adm_params.dest_svc = APR_SVC_ADM;
 	adm_params.dest_domain = APR_DOMAIN_ADSP;
 	adm_params.dest_port = copp_id;
-	adm_params.token = copp_id;
+	adm_params.token = port_id;
 	adm_params.opcode = opcode;
 
 	/* fill for out-of-band */
diff -X dontdiff -Nuarb a/sound/soc/soc-compress.c b/sound/soc/soc-compress.c
--- a/sound/soc/soc-compress.c	2016-01-06 15:00:44.672590656 -0500
+++ b/sound/soc/soc-compress.c	2015-12-01 05:59:05.000000000 -0500
@@ -600,14 +600,15 @@
 {
 	struct snd_soc_pcm_runtime *rtd = cstream->private_data;
 	struct snd_soc_platform *platform = rtd->platform;
+	int ret = 0;
 
 	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
 	if (platform->driver->compr_ops && platform->driver->compr_ops->pointer)
-		 platform->driver->compr_ops->pointer(cstream, tstamp);
+		ret = platform->driver->compr_ops->pointer(cstream, tstamp);
 
 	mutex_unlock(&rtd->pcm_mutex);
-	return 0;
+	return ret;
 }
 
 static int soc_compr_copy(struct snd_compr_stream *cstream,
diff -X dontdiff -Nuarb a/sound/soc/soc-pcm.c b/sound/soc/soc-pcm.c
--- a/sound/soc/soc-pcm.c	2016-01-06 15:00:44.673590656 -0500
+++ b/sound/soc/soc-pcm.c	2015-12-01 05:59:05.000000000 -0500
@@ -533,6 +533,11 @@
 
 	mutex_lock_nested(&rtd->pcm_mutex, rtd->pcm_subclass);
 
+	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
+		snd_soc_dapm_stream_event(rtd,
+		codec_dai->driver->playback.stream_name,
+		SND_SOC_DAPM_STREAM_START);
+
 	if (rtd->dai_link->ops && rtd->dai_link->ops->prepare) {
 		ret = rtd->dai_link->ops->prepare(substream);
 		if (ret < 0) {
@@ -572,11 +577,7 @@
 		cancel_delayed_work(&rtd->delayed_work);
 	}
 
-	if (substream->stream == SNDRV_PCM_STREAM_PLAYBACK)
-		snd_soc_dapm_stream_event(rtd,
-					  codec_dai->driver->playback.stream_name,
-					  SND_SOC_DAPM_STREAM_START);
-	else {
+	if (substream->stream == SNDRV_PCM_STREAM_CAPTURE) {
 		if (codec_dai->capture_active == 1)
 			snd_soc_dapm_stream_event(rtd,
 					  codec_dai->driver->capture.stream_name,
@@ -585,6 +586,13 @@
 	snd_soc_dai_digital_mute(codec_dai, 0);
 
 out:
+	if (ret < 0 && substream->stream == SNDRV_PCM_STREAM_PLAYBACK) {
+		pr_err("%s: Issue stop stream for codec_dai due to op failure %d = ret\n",
+		__func__, ret);
+		snd_soc_dapm_stream_event(rtd,
+		codec_dai->driver->playback.stream_name,
+		SND_SOC_DAPM_STREAM_STOP);
+	}
 	mutex_unlock(&rtd->pcm_mutex);
 	return ret;
 }
diff -X dontdiff -Nuarb a/sound/usb/card.c b/sound/usb/card.c
--- a/sound/usb/card.c	2016-01-06 15:00:44.678590656 -0500
+++ b/sound/usb/card.c	2015-12-01 05:59:05.000000000 -0500
@@ -48,7 +48,6 @@
 #include <linux/usb/audio.h>
 #include <linux/usb/audio-v2.h>
 #include <linux/module.h>
-#include <linux/switch.h>
 
 #include <sound/control.h>
 #include <sound/core.h>
@@ -87,9 +86,6 @@
 static bool async_unlink = 1;
 static int device_setup[SNDRV_CARDS]; /* device parameter for this card */
 static bool ignore_ctl_error;
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-struct switch_dev *usbaudiosdev;
-#endif
 
 module_param_array(index, int, NULL, 0444);
 MODULE_PARM_DESC(index, "Index value for the USB audio adapter.");
@@ -279,9 +275,6 @@
 		break;
 	}
 	}
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	switch_set_state(usbaudiosdev, 1);
-#endif
 	return 0;
 }
 
@@ -599,9 +592,6 @@
 		mutex_unlock(&chip->shutdown_mutex);
 		mutex_unlock(&register_mutex);
 	}
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	switch_set_state(usbaudiosdev, 0);
-#endif
 }
 
 /*
@@ -734,37 +724,17 @@
 
 static int __init snd_usb_audio_init(void)
 {
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	int err;
-#endif
 	if (nrpacks < 1 || nrpacks > MAX_PACKS) {
 		printk(KERN_WARNING "invalid nrpacks value.\n");
 		return -EINVAL;
 	}
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	usbaudiosdev = kzalloc(sizeof(*usbaudiosdev), GFP_KERNEL);
-	if (!usbaudiosdev) {
-		pr_err("Usb audio device memory allocation failed.\n");
-		return -ENOMEM;
-	}
 
-	usbaudiosdev->name = "usb_audio";
-
-	err = switch_dev_register(usbaudiosdev);
-	if (err)
-		pr_err("Usb-audio switch registration failed\n");
-	else
-		pr_debug("usb hs_detected\n");
-#endif
 	return usb_register(&usb_audio_driver);
 }
 
 static void __exit snd_usb_audio_cleanup(void)
 {
 	usb_deregister(&usb_audio_driver);
-#ifndef CONFIG_USB_ANDROID_SAMSUNG_COMPOSITE
-	kfree(usbaudiosdev);
-#endif
 }
 
 module_init(snd_usb_audio_init);
